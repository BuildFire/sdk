"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Created by Daniel on 9/29/2015.
 * single event handlers that enforce
 * limited lifespan event handlers that are not singletons
 */

var postMaster = {
    controlPluginAPI: null,
    widgetPluginAPI: null,
    launcherPluginAPI: null,
    servicePluginAPIs: {},
    postMessageHandler: function postMessageHandler(e) {

        if (!e.data) return;else if (_typeof(e.data) == "object") e.packet = e.data;else {
            /// parse data to once and not per pluginAPI
            try {
                e.packet = JSON.parse(e.data);
            } catch (err) {
                console.log("!! Post Master:: Ignore Invalid packet", err, e.data);
                return;
            }
        }

        postMaster._acceptRequest(e);
    },
    _acceptRequest: function _acceptRequest(e) {

        if (!e || !e.packet || !e.packet.cmd) return;

        function tryPMH(pluginAPI, e) {
            if (!pluginAPI || !pluginAPI.postMessageHandler || !e) return false;

            try {
                return pluginAPI.postMessageHandler(e);
            } catch (err) {
                console.error('postMessageHandler error:', err);
                return false;
            }
        }

        var foundHome = false;

        foundHome = tryPMH(postMaster.widgetPluginAPI, e);
        if (foundHome) return;

        if (postMaster.widgetPluginAPI != postMaster.launcherPluginAPI) foundHome = tryPMH(postMaster.launcherPluginAPI, e);
        if (foundHome) return;

        foundHome = tryPMH(postMaster.controlPluginAPI, e);
        if (foundHome) return;

        for (var p in postMaster.servicePluginAPIs) {
            foundHome = tryPMH(postMaster.servicePluginAPIs[p], e);
            if (foundHome) return;
        }

        if (!foundHome) console.warn('no home for this packet (sad face) ');
    },
    broadcast: function broadcast(packet, optionalInstanceFilter) {

        function trySendMessage(pluginAPI) {
            if (!pluginAPI) return;
            if (!optionalInstanceFilter || pluginAPI.context.instanceId == optionalInstanceFilter) pluginAPI.sendMessage(null, packet);
        }

        trySendMessage(postMaster.controlPluginAPI);

        if (postMaster.widgetPluginAPI && postMaster.widgetPluginAPI != postMaster.launcherPluginAPI) // if widget is same as launcher dont bother running twice
            trySendMessage(postMaster.widgetPluginAPI);

        if (postMaster.launcherPluginAPI && postMaster.widgetPluginAPI == postMaster.launcherPluginAPI) // if widget == launcher then make launcher handle it
            packet.fid = postMaster.launcherPluginAPI.iFrameId;

        if (postMaster.launcherPluginAPI) trySendMessage(postMaster.launcherPluginAPI);

        //broadcast to each service
        for (var p in postMaster.servicePluginAPIs) {
            trySendMessage(postMaster.servicePluginAPIs[p]);
        }
    },

    attachService: function attachService(instanceId, pluginAPI) {
        this.servicePluginAPIs[instanceId] = pluginAPI;
    },
    dettachService: function dettachService(instanceId) {
        delete this.servicePluginAPIs[instanceId];
    },

    isLauncherPluginActive: function isLauncherPluginActive() {
        return postMaster.widgetPluginAPI == null || postMaster.widgetPluginAPI == postMaster.launcherPluginAPI;
    }

};

window.addEventListener('message', postMaster.postMessageHandler, false);
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
!function (a, b, c, d) {
  "use strict";
  function e(a, b, c) {
    return setTimeout(k(a, c), b);
  }function f(a, b, c) {
    return Array.isArray(a) ? (g(a, c[b], c), !0) : !1;
  }function g(a, b, c) {
    var e;if (a) if (a.forEach) a.forEach(b, c);else if (a.length !== d) for (e = 0; e < a.length;) {
      b.call(c, a[e], e, a), e++;
    } else for (e in a) {
      a.hasOwnProperty(e) && b.call(c, a[e], e, a);
    }
  }function h(a, b, c) {
    for (var e = Object.keys(b), f = 0; f < e.length;) {
      (!c || c && a[e[f]] === d) && (a[e[f]] = b[e[f]]), f++;
    }return a;
  }function i(a, b) {
    return h(a, b, !0);
  }function j(a, b, c) {
    var d,
        e = b.prototype;d = a.prototype = Object.create(e), d.constructor = a, d._super = e, c && h(d, c);
  }function k(a, b) {
    return function () {
      return a.apply(b, arguments);
    };
  }function l(a, b) {
    return (typeof a === "undefined" ? "undefined" : _typeof(a)) == kb ? a.apply(b ? b[0] || d : d, b) : a;
  }function m(a, b) {
    return a === d ? b : a;
  }function n(a, b, c) {
    g(r(b), function (b) {
      a.addEventListener(b, c, !1);
    });
  }function o(a, b, c) {
    g(r(b), function (b) {
      a.removeEventListener(b, c, !1);
    });
  }function p(a, b) {
    for (; a;) {
      if (a == b) return !0;a = a.parentNode;
    }return !1;
  }function q(a, b) {
    return a.indexOf(b) > -1;
  }function r(a) {
    return a.trim().split(/\s+/g);
  }function s(a, b, c) {
    if (a.indexOf && !c) return a.indexOf(b);for (var d = 0; d < a.length;) {
      if (c && a[d][c] == b || !c && a[d] === b) return d;d++;
    }return -1;
  }function t(a) {
    return Array.prototype.slice.call(a, 0);
  }function u(a, b, c) {
    for (var d = [], e = [], f = 0; f < a.length;) {
      var g = b ? a[f][b] : a[f];s(e, g) < 0 && d.push(a[f]), e[f] = g, f++;
    }return c && (d = b ? d.sort(function (a, c) {
      return a[b] > c[b];
    }) : d.sort()), d;
  }function v(a, b) {
    for (var c, e, f = b[0].toUpperCase() + b.slice(1), g = 0; g < ib.length;) {
      if (c = ib[g], e = c ? c + f : b, e in a) return e;g++;
    }return d;
  }function w() {
    return ob++;
  }function x(a) {
    var b = a.ownerDocument;return b.defaultView || b.parentWindow;
  }function y(a, b) {
    var c = this;this.manager = a, this.callback = b, this.element = a.element, this.target = a.options.inputTarget, this.domHandler = function (b) {
      l(a.options.enable, [a]) && c.handler(b);
    }, this.init();
  }function z(a) {
    var b,
        c = a.options.inputClass;return new (b = c ? c : rb ? N : sb ? Q : qb ? S : M)(a, A);
  }function A(a, b, c) {
    var d = c.pointers.length,
        e = c.changedPointers.length,
        f = b & yb && d - e === 0,
        g = b & (Ab | Bb) && d - e === 0;c.isFirst = !!f, c.isFinal = !!g, f && (a.session = {}), c.eventType = b, B(a, c), a.emit("hammer.input", c), a.recognize(c), a.session.prevInput = c;
  }function B(a, b) {
    var c = a.session,
        d = b.pointers,
        e = d.length;c.firstInput || (c.firstInput = E(b)), e > 1 && !c.firstMultiple ? c.firstMultiple = E(b) : 1 === e && (c.firstMultiple = !1);var f = c.firstInput,
        g = c.firstMultiple,
        h = g ? g.center : f.center,
        i = b.center = F(d);b.timeStamp = nb(), b.deltaTime = b.timeStamp - f.timeStamp, b.angle = J(h, i), b.distance = I(h, i), C(c, b), b.offsetDirection = H(b.deltaX, b.deltaY), b.scale = g ? L(g.pointers, d) : 1, b.rotation = g ? K(g.pointers, d) : 0, D(c, b);var j = a.element;p(b.srcEvent.target, j) && (j = b.srcEvent.target), b.target = j;
  }function C(a, b) {
    var c = b.center,
        d = a.offsetDelta || {},
        e = a.prevDelta || {},
        f = a.prevInput || {};(b.eventType === yb || f.eventType === Ab) && (e = a.prevDelta = { x: f.deltaX || 0, y: f.deltaY || 0 }, d = a.offsetDelta = { x: c.x, y: c.y }), b.deltaX = e.x + (c.x - d.x), b.deltaY = e.y + (c.y - d.y);
  }function D(a, b) {
    var c,
        e,
        f,
        g,
        h = a.lastInterval || b,
        i = b.timeStamp - h.timeStamp;if (b.eventType != Bb && (i > xb || h.velocity === d)) {
      var j = h.deltaX - b.deltaX,
          k = h.deltaY - b.deltaY,
          l = G(i, j, k);e = l.x, f = l.y, c = mb(l.x) > mb(l.y) ? l.x : l.y, g = H(j, k), a.lastInterval = b;
    } else c = h.velocity, e = h.velocityX, f = h.velocityY, g = h.direction;b.velocity = c, b.velocityX = e, b.velocityY = f, b.direction = g;
  }function E(a) {
    for (var b = [], c = 0; c < a.pointers.length;) {
      b[c] = { clientX: lb(a.pointers[c].clientX), clientY: lb(a.pointers[c].clientY) }, c++;
    }return { timeStamp: nb(), pointers: b, center: F(b), deltaX: a.deltaX, deltaY: a.deltaY };
  }function F(a) {
    var b = a.length;if (1 === b) return { x: lb(a[0].clientX), y: lb(a[0].clientY) };for (var c = 0, d = 0, e = 0; b > e;) {
      c += a[e].clientX, d += a[e].clientY, e++;
    }return { x: lb(c / b), y: lb(d / b) };
  }function G(a, b, c) {
    return { x: b / a || 0, y: c / a || 0 };
  }function H(a, b) {
    return a === b ? Cb : mb(a) >= mb(b) ? a > 0 ? Db : Eb : b > 0 ? Fb : Gb;
  }function I(a, b, c) {
    c || (c = Kb);var d = b[c[0]] - a[c[0]],
        e = b[c[1]] - a[c[1]];return Math.sqrt(d * d + e * e);
  }function J(a, b, c) {
    c || (c = Kb);var d = b[c[0]] - a[c[0]],
        e = b[c[1]] - a[c[1]];return 180 * Math.atan2(e, d) / Math.PI;
  }function K(a, b) {
    return J(b[1], b[0], Lb) - J(a[1], a[0], Lb);
  }function L(a, b) {
    return I(b[0], b[1], Lb) / I(a[0], a[1], Lb);
  }function M() {
    this.evEl = Nb, this.evWin = Ob, this.allow = !0, this.pressed = !1, y.apply(this, arguments);
  }function N() {
    this.evEl = Rb, this.evWin = Sb, y.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
  }function O() {
    this.evTarget = Ub, this.evWin = Vb, this.started = !1, y.apply(this, arguments);
  }function P(a, b) {
    var c = t(a.touches),
        d = t(a.changedTouches);return b & (Ab | Bb) && (c = u(c.concat(d), "identifier", !0)), [c, d];
  }function Q() {
    this.evTarget = Xb, this.targetIds = {}, y.apply(this, arguments);
  }function R(a, b) {
    var c = t(a.touches),
        d = this.targetIds;if (b & (yb | zb) && 1 === c.length) return d[c[0].identifier] = !0, [c, c];var e,
        f,
        g = t(a.changedTouches),
        h = [],
        i = this.target;if (f = c.filter(function (a) {
      return p(a.target, i);
    }), b === yb) for (e = 0; e < f.length;) {
      d[f[e].identifier] = !0, e++;
    }for (e = 0; e < g.length;) {
      d[g[e].identifier] && h.push(g[e]), b & (Ab | Bb) && delete d[g[e].identifier], e++;
    }return h.length ? [u(f.concat(h), "identifier", !0), h] : void 0;
  }function S() {
    y.apply(this, arguments);var a = k(this.handler, this);this.touch = new Q(this.manager, a), this.mouse = new M(this.manager, a);
  }function T(a, b) {
    this.manager = a, this.set(b);
  }function U(a) {
    if (q(a, bc)) return bc;var b = q(a, cc),
        c = q(a, dc);return b && c ? cc + " " + dc : b || c ? b ? cc : dc : q(a, ac) ? ac : _b;
  }function V(a) {
    this.id = w(), this.manager = null, this.options = i(a || {}, this.defaults), this.options.enable = m(this.options.enable, !0), this.state = ec, this.simultaneous = {}, this.requireFail = [];
  }function W(a) {
    return a & jc ? "cancel" : a & hc ? "end" : a & gc ? "move" : a & fc ? "start" : "";
  }function X(a) {
    return a == Gb ? "down" : a == Fb ? "up" : a == Db ? "left" : a == Eb ? "right" : "";
  }function Y(a, b) {
    var c = b.manager;return c ? c.get(a) : a;
  }function Z() {
    V.apply(this, arguments);
  }function $() {
    Z.apply(this, arguments), this.pX = null, this.pY = null;
  }function _() {
    Z.apply(this, arguments);
  }function ab() {
    V.apply(this, arguments), this._timer = null, this._input = null;
  }function bb() {
    Z.apply(this, arguments);
  }function cb() {
    Z.apply(this, arguments);
  }function db() {
    V.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;
  }function eb(a, b) {
    return b = b || {}, b.recognizers = m(b.recognizers, eb.defaults.preset), new fb(a, b);
  }function fb(a, b) {
    b = b || {}, this.options = i(b, eb.defaults), this.options.inputTarget = this.options.inputTarget || a, this.handlers = {}, this.session = {}, this.recognizers = [], this.element = a, this.input = z(this), this.touchAction = new T(this, this.options.touchAction), gb(this, !0), g(b.recognizers, function (a) {
      var b = this.add(new a[0](a[1]));a[2] && b.recognizeWith(a[2]), a[3] && b.requireFailure(a[3]);
    }, this);
  }function gb(a, b) {
    var c = a.element;g(a.options.cssProps, function (a, d) {
      c.style[v(c.style, d)] = b ? a : "";
    });
  }function hb(a, c) {
    var d = b.createEvent("Event");d.initEvent(a, !0, !0), d.gesture = c, c.target.dispatchEvent(d);
  }var ib = ["", "webkit", "moz", "MS", "ms", "o"],
      jb = b.createElement("div"),
      kb = "function",
      lb = Math.round,
      mb = Math.abs,
      nb = Date.now,
      ob = 1,
      pb = /mobile|tablet|ip(ad|hone|od)|android/i,
      qb = "ontouchstart" in a,
      rb = v(a, "PointerEvent") !== d,
      sb = qb && pb.test(navigator.userAgent),
      tb = "touch",
      ub = "pen",
      vb = "mouse",
      wb = "kinect",
      xb = 25,
      yb = 1,
      zb = 2,
      Ab = 4,
      Bb = 8,
      Cb = 1,
      Db = 2,
      Eb = 4,
      Fb = 8,
      Gb = 16,
      Hb = Db | Eb,
      Ib = Fb | Gb,
      Jb = Hb | Ib,
      Kb = ["x", "y"],
      Lb = ["clientX", "clientY"];y.prototype = { handler: function handler() {}, init: function init() {
      this.evEl && n(this.element, this.evEl, this.domHandler), this.evTarget && n(this.target, this.evTarget, this.domHandler), this.evWin && n(x(this.element), this.evWin, this.domHandler);
    }, destroy: function destroy() {
      this.evEl && o(this.element, this.evEl, this.domHandler), this.evTarget && o(this.target, this.evTarget, this.domHandler), this.evWin && o(x(this.element), this.evWin, this.domHandler);
    } };var Mb = { mousedown: yb, mousemove: zb, mouseup: Ab },
      Nb = "mousedown",
      Ob = "mousemove mouseup";j(M, y, { handler: function handler(a) {
      var b = Mb[a.type];b & yb && 0 === a.button && (this.pressed = !0), b & zb && 1 !== a.which && (b = Ab), this.pressed && this.allow && (b & Ab && (this.pressed = !1), this.callback(this.manager, b, { pointers: [a], changedPointers: [a], pointerType: vb, srcEvent: a }));
    } });var Pb = { pointerdown: yb, pointermove: zb, pointerup: Ab, pointercancel: Bb, pointerout: Bb },
      Qb = { 2: tb, 3: ub, 4: vb, 5: wb },
      Rb = "pointerdown",
      Sb = "pointermove pointerup pointercancel";a.MSPointerEvent && (Rb = "MSPointerDown", Sb = "MSPointerMove MSPointerUp MSPointerCancel"), j(N, y, { handler: function handler(a) {
      var b = this.store,
          c = !1,
          d = a.type.toLowerCase().replace("ms", ""),
          e = Pb[d],
          f = Qb[a.pointerType] || a.pointerType,
          g = f == tb,
          h = s(b, a.pointerId, "pointerId");e & yb && (0 === a.button || g) ? 0 > h && (b.push(a), h = b.length - 1) : e & (Ab | Bb) && (c = !0), 0 > h || (b[h] = a, this.callback(this.manager, e, { pointers: b, changedPointers: [a], pointerType: f, srcEvent: a }), c && b.splice(h, 1));
    } });var Tb = { touchstart: yb, touchmove: zb, touchend: Ab, touchcancel: Bb },
      Ub = "touchstart",
      Vb = "touchstart touchmove touchend touchcancel";j(O, y, { handler: function handler(a) {
      var b = Tb[a.type];if (b === yb && (this.started = !0), this.started) {
        var c = P.call(this, a, b);b & (Ab | Bb) && c[0].length - c[1].length === 0 && (this.started = !1), this.callback(this.manager, b, { pointers: c[0], changedPointers: c[1], pointerType: tb, srcEvent: a });
      }
    } });var Wb = { touchstart: yb, touchmove: zb, touchend: Ab, touchcancel: Bb },
      Xb = "touchstart touchmove touchend touchcancel";j(Q, y, { handler: function handler(a) {
      var b = Wb[a.type],
          c = R.call(this, a, b);c && this.callback(this.manager, b, { pointers: c[0], changedPointers: c[1], pointerType: tb, srcEvent: a });
    } }), j(S, y, { handler: function handler(a, b, c) {
      var d = c.pointerType == tb,
          e = c.pointerType == vb;if (d) this.mouse.allow = !1;else if (e && !this.mouse.allow) return;b & (Ab | Bb) && (this.mouse.allow = !0), this.callback(a, b, c);
    }, destroy: function destroy() {
      this.touch.destroy(), this.mouse.destroy();
    } });var Yb = v(jb.style, "touchAction"),
      Zb = Yb !== d,
      $b = "compute",
      _b = "auto",
      ac = "manipulation",
      bc = "none",
      cc = "pan-x",
      dc = "pan-y";T.prototype = { set: function set(a) {
      a == $b && (a = this.compute()), Zb && (this.manager.element.style[Yb] = a), this.actions = a.toLowerCase().trim();
    }, update: function update() {
      this.set(this.manager.options.touchAction);
    }, compute: function compute() {
      var a = [];return g(this.manager.recognizers, function (b) {
        l(b.options.enable, [b]) && (a = a.concat(b.getTouchAction()));
      }), U(a.join(" "));
    }, preventDefaults: function preventDefaults(a) {
      if (!Zb) {
        var b = a.srcEvent,
            c = a.offsetDirection;if (this.manager.session.prevented) return void b.preventDefault();var d = this.actions,
            e = q(d, bc),
            f = q(d, dc),
            g = q(d, cc);return e || f && c & Hb || g && c & Ib ? this.preventSrc(b) : void 0;
      }
    }, preventSrc: function preventSrc(a) {
      this.manager.session.prevented = !0, a.preventDefault();
    } };var ec = 1,
      fc = 2,
      gc = 4,
      hc = 8,
      ic = hc,
      jc = 16,
      kc = 32;V.prototype = { defaults: {}, set: function set(a) {
      return h(this.options, a), this.manager && this.manager.touchAction.update(), this;
    }, recognizeWith: function recognizeWith(a) {
      if (f(a, "recognizeWith", this)) return this;var b = this.simultaneous;return a = Y(a, this), b[a.id] || (b[a.id] = a, a.recognizeWith(this)), this;
    }, dropRecognizeWith: function dropRecognizeWith(a) {
      return f(a, "dropRecognizeWith", this) ? this : (a = Y(a, this), delete this.simultaneous[a.id], this);
    }, requireFailure: function requireFailure(a) {
      if (f(a, "requireFailure", this)) return this;var b = this.requireFail;return a = Y(a, this), -1 === s(b, a) && (b.push(a), a.requireFailure(this)), this;
    }, dropRequireFailure: function dropRequireFailure(a) {
      if (f(a, "dropRequireFailure", this)) return this;a = Y(a, this);var b = s(this.requireFail, a);return b > -1 && this.requireFail.splice(b, 1), this;
    }, hasRequireFailures: function hasRequireFailures() {
      return this.requireFail.length > 0;
    }, canRecognizeWith: function canRecognizeWith(a) {
      return !!this.simultaneous[a.id];
    }, emit: function emit(a) {
      function b(b) {
        c.manager.emit(c.options.event + (b ? W(d) : ""), a);
      }var c = this,
          d = this.state;hc > d && b(!0), b(), d >= hc && b(!0);
    }, tryEmit: function tryEmit(a) {
      return this.canEmit() ? this.emit(a) : void (this.state = kc);
    }, canEmit: function canEmit() {
      for (var a = 0; a < this.requireFail.length;) {
        if (!(this.requireFail[a].state & (kc | ec))) return !1;a++;
      }return !0;
    }, recognize: function recognize(a) {
      var b = h({}, a);return l(this.options.enable, [this, b]) ? (this.state & (ic | jc | kc) && (this.state = ec), this.state = this.process(b), void (this.state & (fc | gc | hc | jc) && this.tryEmit(b))) : (this.reset(), void (this.state = kc));
    }, process: function process() {}, getTouchAction: function getTouchAction() {}, reset: function reset() {} }, j(Z, V, { defaults: { pointers: 1 }, attrTest: function attrTest(a) {
      var b = this.options.pointers;return 0 === b || a.pointers.length === b;
    }, process: function process(a) {
      var b = this.state,
          c = a.eventType,
          d = b & (fc | gc),
          e = this.attrTest(a);return d && (c & Bb || !e) ? b | jc : d || e ? c & Ab ? b | hc : b & fc ? b | gc : fc : kc;
    } }), j($, Z, { defaults: { event: "pan", threshold: 10, pointers: 1, direction: Jb }, getTouchAction: function getTouchAction() {
      var a = this.options.direction,
          b = [];return a & Hb && b.push(dc), a & Ib && b.push(cc), b;
    }, directionTest: function directionTest(a) {
      var b = this.options,
          c = !0,
          d = a.distance,
          e = a.direction,
          f = a.deltaX,
          g = a.deltaY;return e & b.direction || (b.direction & Hb ? (e = 0 === f ? Cb : 0 > f ? Db : Eb, c = f != this.pX, d = Math.abs(a.deltaX)) : (e = 0 === g ? Cb : 0 > g ? Fb : Gb, c = g != this.pY, d = Math.abs(a.deltaY))), a.direction = e, c && d > b.threshold && e & b.direction;
    }, attrTest: function attrTest(a) {
      return Z.prototype.attrTest.call(this, a) && (this.state & fc || !(this.state & fc) && this.directionTest(a));
    }, emit: function emit(a) {
      this.pX = a.deltaX, this.pY = a.deltaY;var b = X(a.direction);b && this.manager.emit(this.options.event + b, a), this._super.emit.call(this, a);
    } }), j(_, Z, { defaults: { event: "pinch", threshold: 0, pointers: 2 }, getTouchAction: function getTouchAction() {
      return [bc];
    }, attrTest: function attrTest(a) {
      return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold || this.state & fc);
    }, emit: function emit(a) {
      if (this._super.emit.call(this, a), 1 !== a.scale) {
        var b = a.scale < 1 ? "in" : "out";this.manager.emit(this.options.event + b, a);
      }
    } }), j(ab, V, { defaults: { event: "press", pointers: 1, time: 500, threshold: 5 }, getTouchAction: function getTouchAction() {
      return [_b];
    }, process: function process(a) {
      var b = this.options,
          c = a.pointers.length === b.pointers,
          d = a.distance < b.threshold,
          f = a.deltaTime > b.time;if (this._input = a, !d || !c || a.eventType & (Ab | Bb) && !f) this.reset();else if (a.eventType & yb) this.reset(), this._timer = e(function () {
        this.state = ic, this.tryEmit();
      }, b.time, this);else if (a.eventType & Ab) return ic;return kc;
    }, reset: function reset() {
      clearTimeout(this._timer);
    }, emit: function emit(a) {
      this.state === ic && (a && a.eventType & Ab ? this.manager.emit(this.options.event + "up", a) : (this._input.timeStamp = nb(), this.manager.emit(this.options.event, this._input)));
    } }), j(bb, Z, { defaults: { event: "rotate", threshold: 0, pointers: 2 }, getTouchAction: function getTouchAction() {
      return [bc];
    }, attrTest: function attrTest(a) {
      return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & fc);
    } }), j(cb, Z, { defaults: { event: "swipe", threshold: 10, velocity: .65, direction: Hb | Ib, pointers: 1 }, getTouchAction: function getTouchAction() {
      return $.prototype.getTouchAction.call(this);
    }, attrTest: function attrTest(a) {
      var b,
          c = this.options.direction;return c & (Hb | Ib) ? b = a.velocity : c & Hb ? b = a.velocityX : c & Ib && (b = a.velocityY), this._super.attrTest.call(this, a) && c & a.direction && a.distance > this.options.threshold && mb(b) > this.options.velocity && a.eventType & Ab;
    }, emit: function emit(a) {
      var b = X(a.direction);b && this.manager.emit(this.options.event + b, a), this.manager.emit(this.options.event, a);
    } }), j(db, V, { defaults: { event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 2, posThreshold: 10 }, getTouchAction: function getTouchAction() {
      return [ac];
    }, process: function process(a) {
      var b = this.options,
          c = a.pointers.length === b.pointers,
          d = a.distance < b.threshold,
          f = a.deltaTime < b.time;if (this.reset(), a.eventType & yb && 0 === this.count) return this.failTimeout();if (d && f && c) {
        if (a.eventType != Ab) return this.failTimeout();var g = this.pTime ? a.timeStamp - this.pTime < b.interval : !0,
            h = !this.pCenter || I(this.pCenter, a.center) < b.posThreshold;this.pTime = a.timeStamp, this.pCenter = a.center, h && g ? this.count += 1 : this.count = 1, this._input = a;var i = this.count % b.taps;if (0 === i) return this.hasRequireFailures() ? (this._timer = e(function () {
          this.state = ic, this.tryEmit();
        }, b.interval, this), fc) : ic;
      }return kc;
    }, failTimeout: function failTimeout() {
      return this._timer = e(function () {
        this.state = kc;
      }, this.options.interval, this), kc;
    }, reset: function reset() {
      clearTimeout(this._timer);
    }, emit: function emit() {
      this.state == ic && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
    } }), eb.VERSION = "2.0.4", eb.defaults = { domEvents: !1, touchAction: $b, enable: !0, inputTarget: null, inputClass: null, preset: [[bb, { enable: !1 }], [_, { enable: !1 }, ["rotate"]], [cb, { direction: Hb }], [$, { direction: Hb }, ["swipe"]], [db], [db, { event: "doubletap", taps: 2 }, ["tap"]], [ab]], cssProps: { userSelect: "none", touchSelect: "none", touchCallout: "none", contentZooming: "none", userDrag: "none", tapHighlightColor: "rgba(0,0,0,0)" } };var lc = 1,
      mc = 2;fb.prototype = { set: function set(a) {
      return h(this.options, a), a.touchAction && this.touchAction.update(), a.inputTarget && (this.input.destroy(), this.input.target = a.inputTarget, this.input.init()), this;
    }, stop: function stop(a) {
      this.session.stopped = a ? mc : lc;
    }, recognize: function recognize(a) {
      var b = this.session;if (!b.stopped) {
        this.touchAction.preventDefaults(a);var c,
            d = this.recognizers,
            e = b.curRecognizer;(!e || e && e.state & ic) && (e = b.curRecognizer = null);for (var f = 0; f < d.length;) {
          c = d[f], b.stopped === mc || e && c != e && !c.canRecognizeWith(e) ? c.reset() : c.recognize(a), !e && c.state & (fc | gc | hc) && (e = b.curRecognizer = c), f++;
        }
      }
    }, get: function get(a) {
      if (a instanceof V) return a;for (var b = this.recognizers, c = 0; c < b.length; c++) {
        if (b[c].options.event == a) return b[c];
      }return null;
    }, add: function add(a) {
      if (f(a, "add", this)) return this;var b = this.get(a.options.event);return b && this.remove(b), this.recognizers.push(a), a.manager = this, this.touchAction.update(), a;
    }, remove: function remove(a) {
      if (f(a, "remove", this)) return this;var b = this.recognizers;return a = this.get(a), b.splice(s(b, a), 1), this.touchAction.update(), this;
    }, on: function on(a, b) {
      var c = this.handlers;return g(r(a), function (a) {
        c[a] = c[a] || [], c[a].push(b);
      }), this;
    }, off: function off(a, b) {
      var c = this.handlers;return g(r(a), function (a) {
        b ? c[a].splice(s(c[a], b), 1) : delete c[a];
      }), this;
    }, emit: function emit(a, b) {
      this.options.domEvents && hb(a, b);var c = this.handlers[a] && this.handlers[a].slice();if (c && c.length) {
        b.type = a, b.preventDefault = function () {
          b.srcEvent.preventDefault();
        };for (var d = 0; d < c.length;) {
          c[d](b), d++;
        }
      }
    }, destroy: function destroy() {
      this.element && gb(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
    } }, h(eb, { INPUT_START: yb, INPUT_MOVE: zb, INPUT_END: Ab, INPUT_CANCEL: Bb, STATE_POSSIBLE: ec, STATE_BEGAN: fc, STATE_CHANGED: gc, STATE_ENDED: hc, STATE_RECOGNIZED: ic, STATE_CANCELLED: jc, STATE_FAILED: kc, DIRECTION_NONE: Cb, DIRECTION_LEFT: Db, DIRECTION_RIGHT: Eb, DIRECTION_UP: Fb, DIRECTION_DOWN: Gb, DIRECTION_HORIZONTAL: Hb, DIRECTION_VERTICAL: Ib, DIRECTION_ALL: Jb, Manager: fb, Input: y, TouchAction: T, TouchInput: Q, MouseInput: M, PointerEventInput: N, TouchMouseInput: S, SingleTouchInput: O, Recognizer: V, AttrRecognizer: Z, Tap: db, Pan: $, Swipe: cb, Pinch: _, Rotate: bb, Press: ab, on: n, off: o, each: g, merge: i, extend: h, inherit: j, bindFn: k, prefixed: v }), (typeof define === "undefined" ? "undefined" : _typeof(define)) == kb && define.amd ? define(function () {
    return eb;
  }) : "undefined" != typeof module && module.exports ? module.exports = eb : a[c] = eb;
}(window, document, "Hammer");
'use strict';

var WebPullToRefresh = function () {
	'use strict';

	/**
  * Hold all of the default parameters for the module
  * @type {object}
  */

	var defaults = {
		// ID of the element holding pannable content area
		contentEl: 'content',

		// ID of the element holding pull to refresh loading area
		ptrEl: 'ptr',

		// Number of pixels of panning until refresh 
		distanceToRefresh: 70,

		// Pointer to function that does the loading and returns a promise
		loadingFunction: false,

		// Dragging resistance level
		resistance: 2.5
	};

	/**
  * Hold all of the merged parameter and default module options
  * @type {object}
  */
	var options = {};

	/**
  * Pan event parameters
  * @type {object}
  */
	var pan = {
		enabled: false,
		distance: 0,
		startingPositionY: 0
	};

	/**
  * Easy shortener for handling adding and removing body classes.
  */
	var bodyClass = document.body.classList;

	/**
  * Initialize pull to refresh, hammer, and bind pan events.
  * 
  * @param {object=} params - Setup parameters for pull to refresh
  */
	var init = function init(params) {
		params = params || {};
		options = {
			contentEl: params.contentEl || document.getElementById(defaults.contentEl),
			ptrEl: params.ptrEl || document.getElementById(defaults.ptrEl),
			distanceToRefresh: params.distanceToRefresh || defaults.distanceToRefresh,
			loadingFunction: params.loadingFunction || defaults.loadingFunction,
			resistance: params.resistance || defaults.resistance
		};

		if (!options.contentEl || !options.ptrEl) {
			return false;
		}

		var h = new Hammer(options.contentEl);

		h.get('pan').set({ direction: Hammer.DIRECTION_VERTICAL });

		h.on('panstart', _panStart);
		h.on('pandown', _panDown);
		h.on('panup', _panUp);
		h.on('panend', _panEnd);
	};

	var disable = function disable() {
		if (options && options.contentEl) {
			var h = new Hammer(options.contentEl);
			if (h) h.get('pan').set({ enable: false });
		}
	};

	var enable = function enable() {
		if (options && options.contentEl) {
			var h = new Hammer(options.contentEl);
			if (h) h.get('pan').set({ enable: true });
		}
	};

	/**
  * Determine whether pan events should apply based on scroll position on panstart
  * 
  * @param {object} e - Event object
  */
	var _panStart = function _panStart(e) {
		pan.startingPositionY = document.body.scrollTop;

		if (pan.startingPositionY === 0) {
			pan.enabled = true;
		}
	};

	/**
  * Handle element on screen movement when the pandown events is firing.
  * 
  * @param {object} e - Event object
  */
	var _panDown = function _panDown(e) {
		if (!pan.enabled) {
			return;
		}

		e.preventDefault();
		pan.distance = e.distance / options.resistance;

		_setContentPan();
		_setBodyClass();
	};

	/**
  * Handle element on screen movement when the pandown events is firing.
  * 
  * @param {object} e - Event object
  */
	var _panUp = function _panUp(e) {
		if (!pan.enabled || pan.distance === 0) {
			return;
		}

		e.preventDefault();

		if (pan.distance < e.distance / options.resistance) {
			pan.distance = 0;
		} else {
			pan.distance = e.distance / options.resistance;
		}

		_setContentPan();
		_setBodyClass();
	};

	/**
  * Set the CSS transform on the content element to move it on the screen.
  */
	var _setContentPan = function _setContentPan() {
		// Use transforms to smoothly animate elements on desktop and mobile devices
		options.contentEl.style.transform = options.contentEl.style.webkitTransform = 'translate3d( 0, ' + pan.distance + 'px, 0 )';
		options.ptrEl.style.transform = options.ptrEl.style.webkitTransform = 'translate3d( 0, ' + (pan.distance - options.ptrEl.offsetHeight) + 'px, 0 )';
	};

	/**
  * Set/remove the loading body class to show or hide the loading indicator after pull down.
  */
	var _setBodyClass = function _setBodyClass() {
		if (pan.distance > options.distanceToRefresh) {
			bodyClass.add('ptr-refresh');
		} else {
			bodyClass.remove('ptr-refresh');
		}
	};

	/**
  * Determine how to animate and position elements when the panend event fires.
  * 
  * @param {object} e - Event object
  */
	var _panEnd = function _panEnd(e) {
		if (!pan.enabled) {
			return;
		}

		e.preventDefault();

		options.contentEl.style.transform = options.contentEl.style.webkitTransform = '';
		options.ptrEl.style.transform = options.ptrEl.style.webkitTransform = '';

		if (document.body.classList.contains('ptr-refresh')) {
			_doLoading();
		} else {
			_doReset();
		}

		pan.distance = 0;
		pan.enabled = false;
	};

	/**
  * Position content and refresh elements to show that loading is taking place.
  */
	var _doLoading = function _doLoading() {
		bodyClass.add('ptr-loading');

		// If no valid loading function exists, just reset elements
		if (!options.loadingFunction) {
			return _doReset();
		}

		// The loading function should return a promise
		var loadingPromise = options.loadingFunction();

		// For UX continuity, make sure we show loading for at least one second before resetting
		setTimeout(function () {
			// Once actual loading is complete, reset pull to refresh
			loadingPromise.then(_doReset);
		}, 1000);
	};

	/**
  * Reset all elements to their starting positions before any paning took place.
  */
	var _doReset = function _doReset() {
		bodyClass.remove('ptr-loading');
		bodyClass.remove('ptr-refresh');
		bodyClass.add('ptr-reset');

		var bodyClassRemove = function bodyClassRemove() {
			bodyClass.remove('ptr-reset');
			document.body.removeEventListener('transitionend', bodyClassRemove, false);
		};

		document.body.addEventListener('transitionend', bodyClassRemove, false);
	};

	return {
		init: init,
		disable: disable,
		enable: enable
	};
}();
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// 2016-07-07, Brian Grinstead, MIT License
!function (a) {
  function b(a, d) {
    if (a = a ? a : "", d = d || {}, a instanceof b) return a;if (!(this instanceof b)) return new b(a, d);var e = c(a);this._originalInput = a, this._r = e.r, this._g = e.g, this._b = e.b, this._a = e.a, this._roundA = P(100 * this._a) / 100, this._format = d.format || e.format, this._gradientType = d.gradientType, this._r < 1 && (this._r = P(this._r)), this._g < 1 && (this._g = P(this._g)), this._b < 1 && (this._b = P(this._b)), this._ok = e.ok, this._tc_id = O++;
  }function c(a) {
    var b = { r: 0, g: 0, b: 0 },
        c = 1,
        e = null,
        g = null,
        i = null,
        j = !1,
        k = !1;return "string" == typeof a && (a = K(a)), "object" == (typeof a === "undefined" ? "undefined" : _typeof(a)) && (J(a.r) && J(a.g) && J(a.b) ? (b = d(a.r, a.g, a.b), j = !0, k = "%" === String(a.r).substr(-1) ? "prgb" : "rgb") : J(a.h) && J(a.s) && J(a.v) ? (e = G(a.s), g = G(a.v), b = h(a.h, e, g), j = !0, k = "hsv") : J(a.h) && J(a.s) && J(a.l) && (e = G(a.s), i = G(a.l), b = f(a.h, e, i), j = !0, k = "hsl"), a.hasOwnProperty("a") && (c = a.a)), c = z(c), { ok: j, format: a.format || k, r: Q(255, R(b.r, 0)), g: Q(255, R(b.g, 0)), b: Q(255, R(b.b, 0)), a: c };
  }function d(a, b, c) {
    return { r: 255 * A(a, 255), g: 255 * A(b, 255), b: 255 * A(c, 255) };
  }function e(a, b, c) {
    a = A(a, 255), b = A(b, 255), c = A(c, 255);var d,
        e,
        f = R(a, b, c),
        g = Q(a, b, c),
        h = (f + g) / 2;if (f == g) d = e = 0;else {
      var i = f - g;switch (e = h > .5 ? i / (2 - f - g) : i / (f + g), f) {case a:
          d = (b - c) / i + (c > b ? 6 : 0);break;case b:
          d = (c - a) / i + 2;break;case c:
          d = (a - b) / i + 4;}d /= 6;
    }return { h: d, s: e, l: h };
  }function f(a, b, c) {
    function d(a, b, c) {
      return 0 > c && (c += 1), c > 1 && (c -= 1), 1 / 6 > c ? a + 6 * (b - a) * c : .5 > c ? b : 2 / 3 > c ? a + 6 * (b - a) * (2 / 3 - c) : a;
    }var e, f, g;if (a = A(a, 360), b = A(b, 100), c = A(c, 100), 0 === b) e = f = g = c;else {
      var h = .5 > c ? c * (1 + b) : c + b - c * b,
          i = 2 * c - h;e = d(i, h, a + 1 / 3), f = d(i, h, a), g = d(i, h, a - 1 / 3);
    }return { r: 255 * e, g: 255 * f, b: 255 * g };
  }function g(a, b, c) {
    a = A(a, 255), b = A(b, 255), c = A(c, 255);var d,
        e,
        f = R(a, b, c),
        g = Q(a, b, c),
        h = f,
        i = f - g;if (e = 0 === f ? 0 : i / f, f == g) d = 0;else {
      switch (f) {case a:
          d = (b - c) / i + (c > b ? 6 : 0);break;case b:
          d = (c - a) / i + 2;break;case c:
          d = (a - b) / i + 4;}d /= 6;
    }return { h: d, s: e, v: h };
  }function h(b, c, d) {
    b = 6 * A(b, 360), c = A(c, 100), d = A(d, 100);var e = a.floor(b),
        f = b - e,
        g = d * (1 - c),
        h = d * (1 - f * c),
        i = d * (1 - (1 - f) * c),
        j = e % 6,
        k = [d, h, g, g, i, d][j],
        l = [i, d, d, h, g, g][j],
        m = [g, g, i, d, d, h][j];return { r: 255 * k, g: 255 * l, b: 255 * m };
  }function i(a, b, c, d) {
    var e = [F(P(a).toString(16)), F(P(b).toString(16)), F(P(c).toString(16))];return d && e[0].charAt(0) == e[0].charAt(1) && e[1].charAt(0) == e[1].charAt(1) && e[2].charAt(0) == e[2].charAt(1) ? e[0].charAt(0) + e[1].charAt(0) + e[2].charAt(0) : e.join("");
  }function j(a, b, c, d, e) {
    var f = [F(P(a).toString(16)), F(P(b).toString(16)), F(P(c).toString(16)), F(H(d))];return e && f[0].charAt(0) == f[0].charAt(1) && f[1].charAt(0) == f[1].charAt(1) && f[2].charAt(0) == f[2].charAt(1) && f[3].charAt(0) == f[3].charAt(1) ? f[0].charAt(0) + f[1].charAt(0) + f[2].charAt(0) + f[3].charAt(0) : f.join("");
  }function k(a, b, c, d) {
    var e = [F(H(d)), F(P(a).toString(16)), F(P(b).toString(16)), F(P(c).toString(16))];return e.join("");
  }function l(a, c) {
    c = 0 === c ? 0 : c || 10;var d = b(a).toHsl();return d.s -= c / 100, d.s = B(d.s), b(d);
  }function m(a, c) {
    c = 0 === c ? 0 : c || 10;var d = b(a).toHsl();return d.s += c / 100, d.s = B(d.s), b(d);
  }function n(a) {
    return b(a).desaturate(100);
  }function o(a, c) {
    c = 0 === c ? 0 : c || 10;var d = b(a).toHsl();return d.l += c / 100, d.l = B(d.l), b(d);
  }function p(a, c) {
    c = 0 === c ? 0 : c || 10;var d = b(a).toRgb();return d.r = R(0, Q(255, d.r - P(255 * -(c / 100)))), d.g = R(0, Q(255, d.g - P(255 * -(c / 100)))), d.b = R(0, Q(255, d.b - P(255 * -(c / 100)))), b(d);
  }function q(a, c) {
    c = 0 === c ? 0 : c || 10;var d = b(a).toHsl();return d.l -= c / 100, d.l = B(d.l), b(d);
  }function r(a, c) {
    var d = b(a).toHsl(),
        e = (d.h + c) % 360;return d.h = 0 > e ? 360 + e : e, b(d);
  }function s(a) {
    var c = b(a).toHsl();return c.h = (c.h + 180) % 360, b(c);
  }function t(a) {
    var c = b(a).toHsl(),
        d = c.h;return [b(a), b({ h: (d + 120) % 360, s: c.s, l: c.l }), b({ h: (d + 240) % 360, s: c.s, l: c.l })];
  }function u(a) {
    var c = b(a).toHsl(),
        d = c.h;return [b(a), b({ h: (d + 90) % 360, s: c.s, l: c.l }), b({ h: (d + 180) % 360, s: c.s, l: c.l }), b({ h: (d + 270) % 360, s: c.s, l: c.l })];
  }function v(a) {
    var c = b(a).toHsl(),
        d = c.h;return [b(a), b({ h: (d + 72) % 360, s: c.s, l: c.l }), b({ h: (d + 216) % 360, s: c.s, l: c.l })];
  }function w(a, c, d) {
    c = c || 6, d = d || 30;var e = b(a).toHsl(),
        f = 360 / d,
        g = [b(a)];for (e.h = (e.h - (f * c >> 1) + 720) % 360; --c;) {
      e.h = (e.h + f) % 360, g.push(b(e));
    }return g;
  }function x(a, c) {
    c = c || 6;for (var d = b(a).toHsv(), e = d.h, f = d.s, g = d.v, h = [], i = 1 / c; c--;) {
      h.push(b({ h: e, s: f, v: g })), g = (g + i) % 1;
    }return h;
  }function y(a) {
    var b = {};for (var c in a) {
      a.hasOwnProperty(c) && (b[a[c]] = c);
    }return b;
  }function z(a) {
    return a = parseFloat(a), (isNaN(a) || 0 > a || a > 1) && (a = 1), a;
  }function A(b, c) {
    D(b) && (b = "100%");var d = E(b);return b = Q(c, R(0, parseFloat(b))), d && (b = parseInt(b * c, 10) / 100), a.abs(b - c) < 1e-6 ? 1 : b % c / parseFloat(c);
  }function B(a) {
    return Q(1, R(0, a));
  }function C(a) {
    return parseInt(a, 16);
  }function D(a) {
    return "string" == typeof a && -1 != a.indexOf(".") && 1 === parseFloat(a);
  }function E(a) {
    return "string" == typeof a && -1 != a.indexOf("%");
  }function F(a) {
    return 1 == a.length ? "0" + a : "" + a;
  }function G(a) {
    return 1 >= a && (a = 100 * a + "%"), a;
  }function H(b) {
    return a.round(255 * parseFloat(b)).toString(16);
  }function I(a) {
    return C(a) / 255;
  }function J(a) {
    return !!V.CSS_UNIT.exec(a);
  }function K(a) {
    a = a.replace(M, "").replace(N, "").toLowerCase();var b = !1;if (T[a]) a = T[a], b = !0;else if ("transparent" == a) return { r: 0, g: 0, b: 0, a: 0, format: "name" };var c;return (c = V.rgb.exec(a)) ? { r: c[1], g: c[2], b: c[3] } : (c = V.rgba.exec(a)) ? { r: c[1], g: c[2], b: c[3], a: c[4] } : (c = V.hsl.exec(a)) ? { h: c[1], s: c[2], l: c[3] } : (c = V.hsla.exec(a)) ? { h: c[1], s: c[2], l: c[3], a: c[4] } : (c = V.hsv.exec(a)) ? { h: c[1], s: c[2], v: c[3] } : (c = V.hsva.exec(a)) ? { h: c[1], s: c[2], v: c[3], a: c[4] } : (c = V.hex8.exec(a)) ? { r: C(c[1]), g: C(c[2]), b: C(c[3]), a: I(c[4]), format: b ? "name" : "hex8" } : (c = V.hex6.exec(a)) ? { r: C(c[1]), g: C(c[2]), b: C(c[3]), format: b ? "name" : "hex" } : (c = V.hex4.exec(a)) ? { r: C(c[1] + "" + c[1]), g: C(c[2] + "" + c[2]), b: C(c[3] + "" + c[3]), a: I(c[4] + "" + c[4]), format: b ? "name" : "hex8" } : (c = V.hex3.exec(a)) ? { r: C(c[1] + "" + c[1]), g: C(c[2] + "" + c[2]), b: C(c[3] + "" + c[3]), format: b ? "name" : "hex" } : !1;
  }function L(a) {
    var b, c;return a = a || { level: "AA", size: "small" }, b = (a.level || "AA").toUpperCase(), c = (a.size || "small").toLowerCase(), "AA" !== b && "AAA" !== b && (b = "AA"), "small" !== c && "large" !== c && (c = "small"), { level: b, size: c };
  }var M = /^\s+/,
      N = /\s+$/,
      O = 0,
      P = a.round,
      Q = a.min,
      R = a.max,
      S = a.random;b.prototype = { isDark: function isDark() {
      return this.getBrightness() < 128;
    }, isLight: function isLight() {
      return !this.isDark();
    }, isValid: function isValid() {
      return this._ok;
    }, getOriginalInput: function getOriginalInput() {
      return this._originalInput;
    }, getFormat: function getFormat() {
      return this._format;
    }, getAlpha: function getAlpha() {
      return this._a;
    }, getBrightness: function getBrightness() {
      var a = this.toRgb();return (299 * a.r + 587 * a.g + 114 * a.b) / 1e3;
    }, getLuminance: function getLuminance() {
      var b,
          c,
          d,
          e,
          f,
          g,
          h = this.toRgb();return b = h.r / 255, c = h.g / 255, d = h.b / 255, e = .03928 >= b ? b / 12.92 : a.pow((b + .055) / 1.055, 2.4), f = .03928 >= c ? c / 12.92 : a.pow((c + .055) / 1.055, 2.4), g = .03928 >= d ? d / 12.92 : a.pow((d + .055) / 1.055, 2.4), .2126 * e + .7152 * f + .0722 * g;
    }, setAlpha: function setAlpha(a) {
      return this._a = z(a), this._roundA = P(100 * this._a) / 100, this;
    }, toHsv: function toHsv() {
      var a = g(this._r, this._g, this._b);return { h: 360 * a.h, s: a.s, v: a.v, a: this._a };
    }, toHsvString: function toHsvString() {
      var a = g(this._r, this._g, this._b),
          b = P(360 * a.h),
          c = P(100 * a.s),
          d = P(100 * a.v);return 1 == this._a ? "hsv(" + b + ", " + c + "%, " + d + "%)" : "hsva(" + b + ", " + c + "%, " + d + "%, " + this._roundA + ")";
    }, toHsl: function toHsl() {
      var a = e(this._r, this._g, this._b);return { h: 360 * a.h, s: a.s, l: a.l, a: this._a };
    }, toHslString: function toHslString() {
      var a = e(this._r, this._g, this._b),
          b = P(360 * a.h),
          c = P(100 * a.s),
          d = P(100 * a.l);return 1 == this._a ? "hsl(" + b + ", " + c + "%, " + d + "%)" : "hsla(" + b + ", " + c + "%, " + d + "%, " + this._roundA + ")";
    }, toHex: function toHex(a) {
      return i(this._r, this._g, this._b, a);
    }, toHexString: function toHexString(a) {
      return "#" + this.toHex(a);
    }, toHex8: function toHex8(a) {
      return j(this._r, this._g, this._b, this._a, a);
    }, toHex8String: function toHex8String(a) {
      return "#" + this.toHex8(a);
    }, toRgb: function toRgb() {
      return { r: P(this._r), g: P(this._g), b: P(this._b), a: this._a };
    }, toRgbString: function toRgbString() {
      return 1 == this._a ? "rgb(" + P(this._r) + ", " + P(this._g) + ", " + P(this._b) + ")" : "rgba(" + P(this._r) + ", " + P(this._g) + ", " + P(this._b) + ", " + this._roundA + ")";
    }, toPercentageRgb: function toPercentageRgb() {
      return { r: P(100 * A(this._r, 255)) + "%", g: P(100 * A(this._g, 255)) + "%", b: P(100 * A(this._b, 255)) + "%", a: this._a };
    }, toPercentageRgbString: function toPercentageRgbString() {
      return 1 == this._a ? "rgb(" + P(100 * A(this._r, 255)) + "%, " + P(100 * A(this._g, 255)) + "%, " + P(100 * A(this._b, 255)) + "%)" : "rgba(" + P(100 * A(this._r, 255)) + "%, " + P(100 * A(this._g, 255)) + "%, " + P(100 * A(this._b, 255)) + "%, " + this._roundA + ")";
    }, toName: function toName() {
      return 0 === this._a ? "transparent" : this._a < 1 ? !1 : U[i(this._r, this._g, this._b, !0)] || !1;
    }, toFilter: function toFilter(a) {
      var c = "#" + k(this._r, this._g, this._b, this._a),
          d = c,
          e = this._gradientType ? "GradientType = 1, " : "";if (a) {
        var f = b(a);d = "#" + k(f._r, f._g, f._b, f._a);
      }return "progid:DXImageTransform.Microsoft.gradient(" + e + "startColorstr=" + c + ",endColorstr=" + d + ")";
    }, toString: function toString(a) {
      var b = !!a;a = a || this._format;var c = !1,
          d = this._a < 1 && this._a >= 0,
          e = !b && d && ("hex" === a || "hex6" === a || "hex3" === a || "hex4" === a || "hex8" === a || "name" === a);return e ? "name" === a && 0 === this._a ? this.toName() : this.toRgbString() : ("rgb" === a && (c = this.toRgbString()), "prgb" === a && (c = this.toPercentageRgbString()), ("hex" === a || "hex6" === a) && (c = this.toHexString()), "hex3" === a && (c = this.toHexString(!0)), "hex4" === a && (c = this.toHex8String(!0)), "hex8" === a && (c = this.toHex8String()), "name" === a && (c = this.toName()), "hsl" === a && (c = this.toHslString()), "hsv" === a && (c = this.toHsvString()), c || this.toHexString());
    }, clone: function clone() {
      return b(this.toString());
    }, _applyModification: function _applyModification(a, b) {
      var c = a.apply(null, [this].concat([].slice.call(b)));return this._r = c._r, this._g = c._g, this._b = c._b, this.setAlpha(c._a), this;
    }, lighten: function lighten() {
      return this._applyModification(o, arguments);
    }, brighten: function brighten() {
      return this._applyModification(p, arguments);
    }, darken: function darken() {
      return this._applyModification(q, arguments);
    }, desaturate: function desaturate() {
      return this._applyModification(l, arguments);
    }, saturate: function saturate() {
      return this._applyModification(m, arguments);
    }, greyscale: function greyscale() {
      return this._applyModification(n, arguments);
    }, spin: function spin() {
      return this._applyModification(r, arguments);
    }, _applyCombination: function _applyCombination(a, b) {
      return a.apply(null, [this].concat([].slice.call(b)));
    }, analogous: function analogous() {
      return this._applyCombination(w, arguments);
    }, complement: function complement() {
      return this._applyCombination(s, arguments);
    }, monochromatic: function monochromatic() {
      return this._applyCombination(x, arguments);
    }, splitcomplement: function splitcomplement() {
      return this._applyCombination(v, arguments);
    }, triad: function triad() {
      return this._applyCombination(t, arguments);
    }, tetrad: function tetrad() {
      return this._applyCombination(u, arguments);
    } }, b.fromRatio = function (a, c) {
    if ("object" == (typeof a === "undefined" ? "undefined" : _typeof(a))) {
      var d = {};for (var e in a) {
        a.hasOwnProperty(e) && (d[e] = "a" === e ? a[e] : G(a[e]));
      }a = d;
    }return b(a, c);
  }, b.equals = function (a, c) {
    return a && c ? b(a).toRgbString() == b(c).toRgbString() : !1;
  }, b.random = function () {
    return b.fromRatio({ r: S(), g: S(), b: S() });
  }, b.mix = function (a, c, d) {
    d = 0 === d ? 0 : d || 50;var e = b(a).toRgb(),
        f = b(c).toRgb(),
        g = d / 100,
        h = { r: (f.r - e.r) * g + e.r, g: (f.g - e.g) * g + e.g, b: (f.b - e.b) * g + e.b, a: (f.a - e.a) * g + e.a };return b(h);
  }, b.readability = function (c, d) {
    var e = b(c),
        f = b(d);return (a.max(e.getLuminance(), f.getLuminance()) + .05) / (a.min(e.getLuminance(), f.getLuminance()) + .05);
  }, b.isReadable = function (a, c, d) {
    var e,
        f,
        g = b.readability(a, c);switch (f = !1, e = L(d), e.level + e.size) {case "AAsmall":case "AAAlarge":
        f = g >= 4.5;break;case "AAlarge":
        f = g >= 3;break;case "AAAsmall":
        f = g >= 7;}return f;
  }, b.mostReadable = function (a, c, d) {
    var e,
        f,
        g,
        h,
        i = null,
        j = 0;d = d || {}, f = d.includeFallbackColors, g = d.level, h = d.size;for (var k = 0; k < c.length; k++) {
      e = b.readability(a, c[k]), e > j && (j = e, i = b(c[k]));
    }return b.isReadable(a, i, { level: g, size: h }) || !f ? i : (d.includeFallbackColors = !1, b.mostReadable(a, ["#fff", "#000"], d));
  };var T = b.names = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "0ff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "00f", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", burntsienna: "ea7e5d", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "0ff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "f0f", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "663399", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" },
      U = b.hexNames = y(T),
      V = function () {
    var a = "[-\\+]?\\d+%?",
        b = "[-\\+]?\\d*\\.\\d+%?",
        c = "(?:" + b + ")|(?:" + a + ")",
        d = "[\\s|\\(]+(" + c + ")[,|\\s]+(" + c + ")[,|\\s]+(" + c + ")\\s*\\)?",
        e = "[\\s|\\(]+(" + c + ")[,|\\s]+(" + c + ")[,|\\s]+(" + c + ")[,|\\s]+(" + c + ")\\s*\\)?";return { CSS_UNIT: new RegExp(c), rgb: new RegExp("rgb" + d), rgba: new RegExp("rgba" + e), hsl: new RegExp("hsl" + d), hsla: new RegExp("hsla" + e), hsv: new RegExp("hsv" + d), hsva: new RegExp("hsva" + e), hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/ };
  }();"undefined" != typeof module && module.exports ? module.exports = b : "function" == typeof define && define.amd ? define(function () {
    return b;
  }) : window.tinycolor = b;
}(Math);
'use strict';

(function () {
    console.log('httpClient is loading');
    function CustomPromise(callback) {
        this.promise = new Promise(callback);
        this.promise.success = function (callback) {
            this.then(callback);
            return this;
        };
        this.promise.error = function (callback) {
            this.then(null, callback);
            return this;
        };
        return this.promise;
    }

    function httpClient() {}
    httpClient.get = function (url, config) {
        return httpClient.request('GET', url, undefined, config);
    };
    httpClient.post = function (url, data, config) {
        return httpClient.request('POST', url, data);
    };
    httpClient.put = function (url, data, config) {
        return httpClient.request('PUT', url, data);
    };
    httpClient.jsonp = function (url, data, config) {
        var req = {
            url: url,
            data: data,
            config: config
        };
        throw new Error('jsonp not ready');
    };

    httpClient.request = function (method, url, data, config) {
        console.log('httpClient create request for url: ', url, ' using method: ', method);
        return new CustomPromise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.onload = function () {
                console.log('httpClient read response for url: ', url, ' using method: ', method);
                var options = {
                    status: xhr.status,
                    statusText: xhr.statusText
                };
                var body = 'response' in xhr ? xhr.response : xhr.responseText;
                resolve(body ? JSON.parse(body) : null);
            };
            xhr.onerror = function () {
                console.log('httpClient failed for url: ', url, ' using method: ', method);
                reject(new TypeError('Network request failed'));
            };
            xhr.ontimeout = function () {
                console.log('httpClient timed out for url: ', url, ' using method: ', method);
                reject(new TypeError('Network request failed'));
            };

            console.log('httpClient requesting for url: ', url, ' using method: ', method);
            xhr.open(method, url, true);
            xhr.send(data);
        });
    };

    window.httpClient = httpClient;
})();
"use strict";

/*Utility class for any random function we may neeed in the future  */

var bfUtils = {
    get deviceOnline() {
        if (typeof navigator != "undefined") {
            if (navigator.connection && navigator.connection.type) return navigator.connection.type != "none";else if (typeof navigator.onLine != "undefined") {
                return navigator.onLine;
            } else {
                return true;
            }
        } else return true;
    },
    get isMobileDevice() {
        return window.location.protocol.indexOf('http') < 0;
    },
    get isAndroid() {
        return window.location.protocol.indexOf('http') < 0 && typeof device != "undefined" && device.platform == "Android";
    },
    get isIOS() {
        return window.location.protocol.indexOf('http') < 0 && typeof device != "undefined" && device.platform == "iOS";
    },
    get isPwaAndroid() {
        var isMatch = navigator.userAgent.match(/Android/i) ? true : false;

        return isMatch;
    },
    get isPwaiOS() {
        return "standalone" in window.navigator && !window.navigator.standalone;
    },
    get isAppHtml5Version() {
        return window.self == window.top;
    },
    get isEmulatorCP() {
        return window.top && window.top != window && window.location.protocol.indexOf('http') == 0;
    },
    get isApp() {
        return window.siteConfig ? window.siteConfig.scope === "app" : false;
    },
    tryParseJSON: function tryParseJSON(str) {
        try {
            return JSON.parse(str);
        } catch (e) {
            console.error('Cannot parse data :: ' + str, e.message, e.stack);
            return undefined;
        }
    },
    get http() {
        if (window.$http) {
            return window.$http;
        } else {
            return window.httpClient;
        }
    }
};
"use strict";

var customRegistration = {
    googleMapServices: {},
    get wl_name() {
        var whitlabelName = 'Full ';

        if (appContext && appContext.currentApp && appContext.currentApp.config) {
            whitlabelName = appContext.currentApp.config.whitlabelName + ' ';
        }

        return whitlabelName;
    },
    getSettings: function getSettings(options, callback) {
        var tagName = 'appearance',
            context = {
            appId: window.appContext.currentApp.appId,
            pluginId: tagName,
            instanceId: tagName
        };

        var dsAppearance = new window.DatastoreAPI(context);

        dsAppearance.get({ tag: tagName, withDynamicData: true }, function (err, result) {
            if (err) {
                console.error(err);
                callback(err);
                return;
            }
            if (result && result.data && result.data.customRegistration && window.appContext.currentApp.config.type === "enterprise") {
                callback(null, result.data.customRegistration);
            } else {
                callback(null, null);
            }
        });
    },
    getFields: function getFields(options, callback) {
        var customRegistrationFields = options.customRegistrationSettings;
        if (customRegistrationFields && customRegistrationFields.singlePage && customRegistrationFields.singlePage.formControls) {
            var fields = [];
            var rules = {};
            var gdprLinks = [];
            var initializers = [];

            customRegistrationFields.singlePage.formControls.forEach(function (control, controlIndex) {
                switch (control.id) {
                    case 'fullName':
                        if (control.active) {
                            if (control.settings.displayNameEnabled) {
                                fields.push({
                                    type: "text",
                                    viewType: "none",
                                    name: "displayName",
                                    order: controlIndex,
                                    label: control.options.fieldsLabels.displayName,
                                    iconClass: control.icon,
                                    validate: function validate(value) {
                                        this.error = null;
                                        if ((!value || !value.trim().length) && control.settings.required) {
                                            this.error = control.options.errorMessages.fullNameRequired;
                                        }
                                    },
                                    touch: function touch(value) {
                                        this.validate(value);
                                    },
                                    messages: control.options.errorMessages,
                                    value: options.defaults ? options.defaults.displayName : undefined
                                });
                            }
                            if (control.settings.firstNameEnabled) {
                                fields.push({
                                    type: "text",
                                    viewType: "text",
                                    name: "firstName",
                                    order: controlIndex,
                                    label: control.options.fieldsLabels.firstName,
                                    iconClass: control.icon,
                                    validate: function validate(value) {
                                        this.error = null;
                                        if ((!value || !value.trim().length) && control.settings.required) {
                                            this.error = control.options.errorMessages.fullNameRequired;
                                        }
                                    },
                                    touch: function touch(value) {
                                        this.validate(value);
                                    },
                                    messages: control.options.errorMessages,
                                    value: options.defaults ? options.defaults.firstName : undefined
                                });
                            }
                            if (control.settings.lastNameEnabled) {
                                fields.push({
                                    type: "text",
                                    viewType: "text",
                                    name: "lastName",
                                    order: controlIndex,
                                    label: control.options.fieldsLabels.lastName,
                                    iconClass: control.icon,
                                    validate: function validate(value) {
                                        this.error = null;
                                        if ((!value || !value.trim().length) && control.settings.required) {
                                            this.error = control.options.errorMessages.fullNameRequired;
                                        }
                                    },
                                    touch: function touch(value) {
                                        this.validate(value);
                                    },
                                    messages: control.options.errorMessages,
                                    value: options.defaults ? options.defaults.lastName : undefined
                                });
                            }
                        }
                        break;
                    case 'email':
                        fields.push({
                            type: "email",
                            viewType: "email",
                            name: "email",
                            autocorrect: "off",
                            autocapitalize: "none",
                            order: controlIndex,
                            label: control.options.fieldsLabels.email,
                            iconClass: control.icon,
                            validate: function validate(value) {
                                this.error = null;
                                if (!value || !value.trim().length) {
                                    this.error = control.options.errorMessages.emailRequired;
                                    return;
                                }
                                if (!window.validator.validateEmail(value)) {
                                    this.error = control.options.errorMessages.emailInvalidFormat;
                                    return;
                                }
                                if (!value || !value.trim().length) {
                                    this.error = control.options.errorMessages.emailAlreadyInUse;
                                }
                            },
                            touch: function touch(value) {
                                this.validate(value);
                            },
                            messages: control.options.errorMessages,
                            value: options.defaults ? options.defaults.email : undefined
                        });
                        break;
                    case 'address':
                        if (control.active) {
                            var googleMapsApiKey = control.options.addressGoogleApiKey;
                            if (control.options.addressGoogleApiKey) {
                                initializers.push(function () {
                                    setTimeout(function () {
                                        var node = document.getElementById('customRegistrationScript');
                                        if (node) {
                                            document.getElementsByTagName('head')[0].removeChild(node);
                                        }
                                        customRegistration.googleMapServices.mapsApiKeyError = null;
                                        node = document.createElement('script');
                                        node.id = 'customRegistrationScript';
                                        node.src = 'https://maps.googleapis.com/maps/api/js?key=' + googleMapsApiKey + '&libraries=places&callback=googleMapsInitCallback';
                                        node.type = 'text/javascript';
                                        document.getElementsByTagName('head')[0].appendChild(node);

                                        window.googleMapsInitCallback = function () {
                                            customRegistration.googleMapServices.autoAddressCompleteService = new google.maps.places.AutocompleteService();
                                            customRegistration.googleMapServices.addressGeocoder = new google.maps.Geocoder();
                                        };
                                        if (options.refreshUI) options.refreshUI();
                                    }, 0);
                                });
                            }
                            if (control.settings.showFullAddress) {
                                fields.push({
                                    type: "text",
                                    viewType: "text",
                                    name: "address",
                                    order: controlIndex,
                                    label: control.options.fieldsLabels.address,
                                    iconClass: control.icon,
                                    change: function change(value) {
                                        var field = this;
                                        field.extra = null;
                                        if (customRegistration.googleMapServices.mapsApiKeyError) {
                                            field.error = customRegistration.googleMapServices.mapsApiKeyError;
                                        }
                                        if (customRegistration.googleMapServices.autoAddressCompleteService) {
                                            customRegistration.googleMapServices.checkMapsApiKeyErrors = true;
                                            // don't keep listening to google maps api authentication errors
                                            setTimeout(function () {
                                                customRegistration.googleMapServices.checkMapsApiKeyErrors = false;
                                            }, 3000);
                                            customRegistration.googleMapServices.autoAddressCompleteService.getPlacePredictions({
                                                input: value
                                            }, function (predictions, status) {
                                                if (status !== google.maps.places.PlacesServiceStatus.OK) {
                                                    field.error = control.options.errorMessages.invalidGoogleAddress;
                                                }
                                                field.suggestions = predictions;
                                                if (options.refreshUI) options.refreshUI();
                                            });
                                        } else {
                                            field.error = control.options.errorMessages.invalidGoogleAddress;
                                        }
                                    },
                                    selectSuggestion: function selectSuggestion(suggestion) {
                                        var field = this;
                                        field.error = null;
                                        field.suggestions = null;
                                        field.value = suggestion.description;

                                        customRegistration.googleMapServices.addressGeocoder.geocode({ placeId: suggestion.place_id }, function (results, status) {
                                            if (results && results[0] && results[0]) {
                                                var lat = results[0].geometry.location.lat();
                                                var lng = results[0].geometry.location.lng();
                                                if (control.settings.required) {
                                                    var street = results[0].address_components.find(function (addressComponent) {
                                                        return addressComponent.types && addressComponent.types.find(function (addressType) {
                                                            return addressType === "street_number";
                                                        });
                                                    });
                                                    if (!street) {
                                                        field.error = control.options.errorMessages.invalidGoogleAddress;
                                                    }
                                                }
                                                field.extra = { lat: lat, lng: lng, place: suggestion, addressComponents: results[0].address_components };
                                            } else {
                                                field.error = control.options.errorMessages.invalidGoogleAddress;
                                            }
                                            if (options.refreshUI) options.refreshUI();
                                        });
                                    },
                                    validate: function validate(value) {
                                        var field = this;
                                        field.error = null;
                                        if ((!value || !value.trim().length) && control.settings.required) {
                                            this.error = control.options.errorMessages.addressRequired;
                                            return;
                                        }
                                        if (!field.extra) {
                                            this.error = control.options.errorMessages.invalidGoogleAddress;
                                        }
                                    },
                                    touch: function touch(value) {
                                        if (!this.suggestions && !this.suggestions.length) {
                                            this.validate(value);
                                        }
                                    },
                                    messages: control.options.errorMessages,
                                    value: options.defaults && options.defaults.userProfile && options.defaults.userProfile.address ? options.defaults.userProfile.address.fullAddress : undefined,
                                    extra: options.defaults && options.defaults.userProfile && options.defaults.userProfile.address ? options.defaults.userProfile.address.geoLocation : undefined
                                });
                                if (control.settings.showAptNo) {
                                    fields.push({
                                        type: "text",
                                        viewType: "text",
                                        name: "aptNo",
                                        order: controlIndex,
                                        label: control.options.fieldsLabels.aptNo,
                                        iconClass: control.icon,
                                        containerClass: "small-login-field",
                                        validate: function validate(value) {
                                            this.error = null;
                                            if ((!value || !value.trim().length) && control.settings.required) {
                                                this.error = control.options.errorMessages.addressRequired;
                                            }
                                        },
                                        touch: function touch(value) {
                                            this.validate(value);
                                        },
                                        messages: control.options.errorMessages,
                                        value: options.defaults && options.defaults.userProfile && options.defaults.userProfile.address && options.defaults.userProfile.address.customFields ? options.defaults.userProfile.address.customFields.aptNo : undefined
                                    });
                                }
                            }
                            if (control.settings.showZipCode) {
                                fields.push({
                                    type: "text",
                                    viewType: "text",
                                    name: "zipCode",
                                    order: controlIndex,
                                    label: control.options.fieldsLabels.zipCode,
                                    iconClass: control.icon,
                                    validate: function validate(value) {
                                        this.error = null;
                                        if ((!value || !value.trim().length) && control.settings.required) {
                                            this.error = control.options.errorMessages.addressRequired;
                                        }
                                    },
                                    touch: function touch(value) {
                                        this.validate(value);
                                    },
                                    messages: control.options.errorMessages,
                                    value: options.defaults && options.defaults.userProfile && options.defaults.userProfile.address && options.defaults.userProfile.address.customFields ? options.defaults.userProfile.address.customFields.zipCode : undefined
                                });
                            }
                        }
                        break;
                    case 'password':
                        if (!options.isProfileMode) {
                            fields.push({
                                type: "password",
                                name: "password",
                                order: controlIndex,
                                label: control.options.fieldsLabels.password,
                                iconClass: control.icon,
                                togglePasswordVisibility: control.settings.validation === "showHidePassword",
                                info: control.settings.passwordStrength === "simple" ? control.options.infoMessages.passwordSimpleRules : control.options.infoMessages.passwordRules,
                                validate: function validate(value) {
                                    this.error = null;
                                    if (control.settings.validation === "retypePassword") {
                                        var retypePasswordField = fields.find(function (element) {
                                            return element.name === "retypePassword";
                                        });
                                        retypePasswordField.error = null;
                                    }
                                    if (!value || !value.trim().length) {
                                        this.error = control.options.errorMessages.passwordRequired;
                                        return;
                                    }
                                    if (!window.validator.validatePassword(value, { simplePasswordValidation: control.settings.passwordStrength === "simple" })) {
                                        this.error = control.settings.passwordStrength === "simple" ? control.options.errorMessages.invalidPasswordSimpleRules : control.options.errorMessages.invalidPasswordRules;
                                    }
                                },
                                touch: function touch(value) {
                                    this.validate(value);
                                },
                                messages: control.options.errorMessages
                            });
                            if (control.settings.validation === "retypePassword") {
                                fields.push({
                                    type: "password",
                                    name: "retypePassword",
                                    order: controlIndex,
                                    label: control.options.fieldsLabels.retypePassword,
                                    iconClass: control.icon,
                                    togglePasswordVisibility: control.settings.validation === "showHidePassword",
                                    validate: function validate(value) {
                                        var passwordField = fields.find(function (element) {
                                            return element.name === "password";
                                        });
                                        this.error = null;
                                        if (!value || !value.trim().length) {
                                            this.error = control.options.errorMessages.passwordRequired;
                                            return;
                                        }
                                        if (passwordField.value !== value) {
                                            this.error = control.options.errorMessages.passwordsDontMatch;
                                        }
                                    },
                                    touch: function touch(value) {
                                        this.validate(value);
                                    },
                                    messages: control.options.errorMessages
                                });
                            }
                        }
                        rules.passwordStrength = control.settings.passwordStrength;
                        break;
                    case 'bio':
                        if (control.active) {
                            fields.push({
                                type: "textarea",
                                viewType: "multiline",
                                name: "bio",
                                order: controlIndex,
                                label: control.options.fieldsLabels.bio,
                                iconClass: control.icon,
                                validate: function validate(value) {
                                    this.error = null;
                                    if ((!value || !value.trim().length) && control.settings.required) {
                                        this.error = control.options.errorMessages.bioRequired;
                                    }
                                },
                                touch: function touch(value) {
                                    this.validate(value);
                                },
                                messages: control.options.errorMessages,
                                value: options.defaults && options.defaults.userProfile ? options.defaults.userProfile.bio : undefined
                            });
                        }
                        break;
                    case 'telephone':
                        if (control.active) {
                            fields.push({
                                type: "text",
                                viewType: "text",
                                name: "tel",
                                order: controlIndex,
                                label: control.options.fieldsLabels.tel,
                                iconClass: control.icon,
                                validate: function validate(value) {
                                    this.error = null;
                                    if ((!value || !value.trim().length) && control.settings.required) {
                                        this.error = control.options.errorMessages.invalidEntry;
                                        return;
                                    }
                                    if (value) {
                                        var isValid = /^(?:(?:\(?(?:00|\+)([1-4]\d\d|[1-9]\d?)\)?)?[\-\.\ \\\/]?)?((?:\(?\d{1,}\)?[\-\.\ \\\/]?){0,})(?:[\-\.\ \\\/]?(?:#|ext\.?|extension|x)[\-\.\ \\\/]?(\d+))?$/i.test(value);
                                        if (!isValid) {
                                            this.error = control.options.errorMessages.invalidEntry;
                                        }
                                    }
                                },
                                info: control.settings.showReasonForTelephone ? control.options.infoMessages.reasonForTelephone : null,
                                touch: function touch(value) {
                                    this.validate(value);
                                },
                                messages: control.options.errorMessages,
                                value: options.defaults && options.defaults.userProfile ? options.defaults.userProfile.tel : undefined
                            });
                        }
                        break;
                    case 'birthDate':
                        if (control.active) {
                            var getDisplayValue = function getDisplayValue(value) {
                                if (value) {
                                    return moment(value).format('L');
                                }
                                return null;
                            };
                            fields.push({
                                type: "date",
                                viewType: "text",
                                name: "birthDate",
                                order: controlIndex,
                                label: control.options.fieldsLabels.dateBirth,
                                minDate: control.settings.maxAgeIsRequired && control.settings.maxAgeRequired ? moment().subtract(control.settings.maxAgeRequired, 'years').toDate() : undefined,
                                maxDate: control.settings.minAgeIsRequired && control.settings.minAgeRequired ? moment().subtract(control.settings.minAgeRequired, 'years').toDate() : undefined,
                                iconClass: control.icon,
                                displayValue: getDisplayValue(options.defaults && options.defaults.userProfile ? options.defaults.userProfile.birthDate : undefined),
                                validate: function validate(value) {
                                    this.error = null;
                                    if (!value) {
                                        if (control.settings.required) {
                                            this.error = control.options.errorMessages.birthRequired;
                                        }
                                        return;
                                    }
                                    var momentDate = moment(value);
                                    var years = moment().diff(momentDate, 'years');
                                    if (control.settings.maxAgeIsRequired && control.settings.maxAgeRequired && years > control.settings.maxAgeRequired) {
                                        this.error = control.options.errorMessages.maxAge + " " + control.settings.maxAgeRequired;
                                        return;
                                    }
                                    if (control.settings.minAgeIsRequired && control.settings.minAgeRequired && years < control.settings.minAgeRequired) {
                                        this.error = control.options.errorMessages.minAge + " " + control.settings.minAgeRequired;
                                    }
                                },
                                change: function change(value) {
                                    this.validate(value);
                                    this.displayValue = getDisplayValue(value);
                                },
                                touch: function touch(value) {
                                    this.validate(value);
                                },
                                messages: control.options.errorMessages,
                                value: options.defaults && options.defaults.userProfile ? options.defaults.userProfile.birthDate ? new Date(options.defaults.userProfile.birthDate) : null : undefined
                            });
                        }
                        break;
                    case 'termsConditionsAndPrivacyPolicy':
                        if (!options.isProfileMode) {
                            if (control.active) {
                                var tosLabel = customRegistration.wl_name + 'Terms Of Use';
                                var privacyLabel = customRegistration.wl_name + 'Privacy Policy';

                                gdprLinks.push({
                                    type: "check",
                                    name: "termsAndConditions",
                                    order: 1,
                                    preLinkText: control.options.fieldsLabels.iAccept,
                                    linkText: control.options.fieldsLabels.termsAndConditions,
                                    key: control.settings.termsAndConditionsDocumentKey,
                                    iconClass: control.icon,
                                    validate: function validate(value) {
                                        this.error = null;
                                        if (!value) {
                                            this.error = control.options.errorMessages.termsAndConditionsAcceptRequired;
                                        }
                                    },
                                    touch: function touch(value) {
                                        this.validate(value);
                                    },
                                    open: function open() {
                                        options.openGDPRContent({ key: control.settings.termsAndConditionsDocumentKey, defaultContentKey: 'bf_terms_and_conditions', defaultContentLabel: tosLabel });
                                    }
                                });
                                gdprLinks.push({
                                    type: "check",
                                    name: "privacyPolicy",
                                    order: 2,
                                    preLinkText: control.options.fieldsLabels.iAccept,
                                    linkText: control.options.fieldsLabels.privacyPolicy,
                                    key: control.settings.privacyPolicyDocumentKey,
                                    iconClass: control.icon,
                                    validate: function validate(value) {
                                        this.error = null;
                                        if (!value) {
                                            this.error = control.options.errorMessages.termsAndConditionsAcceptRequired;
                                        }
                                    },
                                    touch: function touch(value) {
                                        this.validate(value);
                                    },
                                    open: function open() {
                                        options.openGDPRContent({ key: control.settings.privacyPolicyDocumentKey, defaultContentKey: 'bf_privacy_policy', defaultContentLabel: privacyLabel });
                                    }
                                });
                            }
                        }
                        break;
                    default:
                        break;
                }
            });
            var fetch = function fetch(options, callback) {
                var hasErrors = false;
                var registrationInfo = {};
                if (options && options.validateFields) {
                    fields.forEach(function (field) {
                        field.validate(field.value);
                        if (field.error) {
                            hasErrors = true;
                        }
                        registrationInfo[field.name] = {
                            value: field.value,
                            extra: field.extra,
                            messages: field.messages
                        };
                    });
                }
                if (options && options.validateLinks) {
                    if (gdprLinks) {
                        gdprLinks.forEach(function (link) {
                            link.validate(link.value);
                            if (link.error) {
                                hasErrors = true;
                            }
                        });
                    }
                }
                if (!hasErrors) {

                    callback(null, {
                        // return an object that matches kauth schema
                        user: {
                            email: registrationInfo.email.value,
                            password: registrationInfo.password ? registrationInfo.password.value : undefined,
                            firstName: registrationInfo.firstName ? registrationInfo.firstName.value : undefined,
                            lastName: registrationInfo.lastName ? registrationInfo.lastName.value : undefined,
                            displayName: registrationInfo.displayName ? registrationInfo.displayName.value : undefined,
                            userProfile: {
                                address: {
                                    fullAddress: registrationInfo.address ? registrationInfo.address.value : undefined,
                                    customFields: {
                                        aptNo: registrationInfo.aptNo ? registrationInfo.aptNo.value : undefined,
                                        zipCode: registrationInfo.zipCode ? registrationInfo.zipCode.value : undefined
                                    },
                                    geoLocation: registrationInfo.address && registrationInfo.address.extra ? registrationInfo.address.extra : undefined
                                },
                                bio: registrationInfo.bio ? registrationInfo.bio.value : undefined,
                                birthDate: registrationInfo.birthDate ? registrationInfo.birthDate.value ? new Date(registrationInfo.birthDate.value) : null : undefined,
                                tel: registrationInfo.tel ? registrationInfo.tel.value : undefined
                            }
                        },
                        messages: {
                            emailAlreadyInUse: registrationInfo.email.messages.emailAlreadyInUse
                        }
                    });
                } else {
                    callback(true, null);
                }
            };
            callback(null, { fields: fields, rules: rules, gdprLinks: gdprLinks, initializers: initializers, fetch: fetch });
        } else {
            callback(null, null);
        }
    }
};

function gm_authFailure() {
    if (customRegistration.googleMapServices.checkMapsApiKeyErrors) {
        customRegistration.googleMapServices.mapsApiKeyError = "There seems to be an issue with google maps key";
    }
}
/**
 * Created by Rami on 03/08/2016.
 */
"use strict";

var userTags = {
    get isUserTaggingEnabled() {
        return window.appContext && window.appContext.currentApp && window.appContext.currentApp.config && window.appContext.currentApp.config.userTagging && window.appContext.currentApp.config.userTagging != "hidden" && window.appContext.currentApp.config.userTagging != "disabled";
    },
    init: function init() {},
    checkPluginAccessSettings: function checkPluginAccessSettings(pluginInstance, callback) {
        var accessSettings = pluginInstance.accessSettings;

        //skip the tag permission settings if the user on EmulatorCP
        if (!bfUtils.isEmulatorCP && pluginInstance.requiresLogin) {
            authAPI.getCurrentUser(function (err, user) {
                if (err) {
                    console.error(err);
                    callback(err, null);
                    return;
                }
                if (user) {
                    if (!userTags.isUserTaggingEnabled || window.appContext.currentApp.config.advancedPluginAccessSettings != 'enabled') {
                        callback(null, true);
                        return;
                    }

                    if (!accessSettings) {
                        callback(null, true);
                        return;
                    }

                    if (!accessSettings.requiresTags) {
                        callback(null, true);
                        return;
                    }

                    if (!accessSettings.requiredTags || accessSettings.requiredTags.length == 0) {
                        callback(null, true);
                        return;
                    }

                    if (accessSettings.giveAccessWhen) {
                        if (user.tags && user.tags[window.appContext.currentApp.appId] && user.tags[window.appContext.currentApp.appId].length > 0) {

                            var tags = user.tags[window.appContext.currentApp.appId];

                            if (accessSettings.giveAccessWhen == 'matchAllTags') {
                                for (var i = 0; i < accessSettings.requiredTags.length; i++) {
                                    var matched = false;
                                    for (var j = 0; j < tags.length; j++) {
                                        if (tags[j].tagName == accessSettings.requiredTags[i].name && accessSettings.requiredTags[i].appliedCount <= tags[j].appliedCount) {
                                            matched = true;
                                            break;
                                        }
                                    }

                                    if (!matched) {
                                        callback(null, false);
                                        return;
                                    }
                                }
                                callback(null, true);
                                /*If all the required tags have been checked and none of them doesn't match the criteria then return true*/
                            } else {
                                for (var i = 0; i < accessSettings.requiredTags.length; i++) {
                                    for (var j = 0; j < tags.length; j++) {
                                        if (tags[j].tagName == accessSettings.requiredTags[i].name && accessSettings.requiredTags[i].appliedCount <= tags[j].appliedCount) {
                                            callback(null, true);
                                            return;
                                        }
                                    }
                                }
                                callback(null, false);
                                /*If all the required tags have been checked and none of them match the criteria then return false*/
                            }
                        } else {
                            callback(null, false);
                        }
                    } else callback(null, false);
                } else {
                    callback(null, false);
                }
            });
        } else {
            callback(null, true);
        }
    },
    setBehavioralTags: function setBehavioralTags(instanceId) {
        //skip the BehavioralTags if the user on EmulatorCP
        if (!bfUtils.isEmulatorCP && bfUtils.deviceOnline && userTags.isUserTaggingEnabled) {
            authAPI.getCurrentUser(null, function (err, user) {
                if (err) console.log(err);else if (user) {
                    bfUtils.http.post(window.siteConfig.endPoints.appHost + "/api/userTagging/app/" + window.appContext.currentApp.appId + "/user/assignBehavioralTag", {
                        instanceId: instanceId,
                        accessToken: user.accessToken
                    }).success(function (requiresHardBuild) {}).error(function (err) {
                        console.log(err);
                    });
                }
            });
        }
    },
    removeProfileTags: function removeProfileTags(callback) {
        var tags = ["$$profile_birth_year:", "$$profile_birth_month:", "$$profile_zip:", "$$profile_city:", "$$profile_state:", "$$profile_town:", "$$profile_country:"];
        userTags.unassignUserTags(tags, { isPrefix: true, removeTag: true }, function (err, result) {
            if (err) callback(err, null);else callback(null, true);
        });
    },
    setRegistrationTags: function setRegistrationTags(userProfile, isNewRegistration, callback) {

        var getAddressComponent = function getAddressComponent(place, type) {
            var result = void 0;

            for (var i = 0; i < place.length; i++) {
                var addressType = place[i].types[0];
                if (addressType == type) {
                    result = place[i].short_name;
                    return result;
                }
            }
            return;
        };

        if (userTags.isUserTaggingEnabled) {
            var registrationTags = [];

            if (isNewRegistration) {
                var currentDate = new Date();
                registrationTags.push("$$registered");
                registrationTags.push("$$registered_year:" + currentDate.getFullYear());
                registrationTags.push("$$registered_month:" + (currentDate.getMonth() + 1));
            }

            if (userProfile) {
                if (userProfile.birthDate) {
                    registrationTags.push("$$profile_birth_year:" + userProfile.birthDate.getFullYear());
                    registrationTags.push("$$profile_birth_month:" + (userProfile.birthDate.getMonth() + 1));
                }

                if (userProfile.address && userProfile.address.customFields && userProfile.address.customFields.zipCode) {
                    registrationTags.push("$$profile_zip:" + userProfile.address.customFields.zipCode);
                }

                if (userProfile.address && userProfile.address.geoLocation && userProfile.address.geoLocation.addressComponents) {
                    var country = getAddressComponent(userProfile.address.geoLocation.addressComponents, "country");
                    if (country) registrationTags.push("$$profile_country:" + country.replace(/ /g, "_"));

                    var state = getAddressComponent(userProfile.address.geoLocation.addressComponents, "administrative_area_level_1");
                    if (state) registrationTags.push("$$profile_state:" + state.replace(/ /g, "_"));

                    var city = getAddressComponent(userProfile.address.geoLocation.addressComponents, "administrative_area_level_2");
                    if (city) registrationTags.push("$$profile_city:" + city.replace(/ /g, "_"));

                    var town = getAddressComponent(userProfile.address.geoLocation.addressComponents, "locality");
                    if (town) registrationTags.push("$$profile_town:" + town.replace(/ /g, "_"));
                }
            }

            if (!isNewRegistration) {
                userTags.removeProfileTags(function (err, result) {
                    if (err) callback(err);else {
                        userTags.assignUserTags(registrationTags, callback);
                    }
                });
            } else {
                userTags.assignUserTags(registrationTags, callback);
            }
        }
    },
    assignUserTags: function assignUserTags(tags, callback) {
        if (typeof tags == "string") tags = tags.split(",");

        authAPI.getCurrentUser(function (err, user) {
            if (err) {
                console.log(err);
                callback(err, null);
            } else if (user) {
                bfUtils.http.post(window.siteConfig.endPoints.appHost + "/api/userTagging/app/" + window.appContext.currentApp.appId + "/user/assign", {
                    tags: tags,
                    accessToken: user.accessToken
                }).success(function (result) {
                    callback(null, true);
                }).error(function (err) {
                    console.log(err);
                    callback(err);
                });
            }
        });
    },
    unassignUserTags: function unassignUserTags(tags, options, callback) {
        if (typeof tags == "string") tags = tags.split(",");

        authAPI.getCurrentUser(function (err, user) {
            if (err) {
                console.log(err);
                callback(err, null);
            } else if (user) {
                bfUtils.http.post(window.siteConfig.endPoints.appHost + "/api/userTagging/app/" + window.appContext.currentApp.appId + "/user/unassign", {
                    tags: tags,
                    isPrefix: options.isPrefix || false,
                    accessToken: user.accessToken,
                    removeTag: options.removeTag || false
                }).success(function (result) {
                    callback(null, true);
                }).error(function (err) {
                    console.log(err);
                    callback(err, null);
                });
            }
        });
    }

};

userTags.init();
"use strict";
/**
 * Created by Daniel on 3/30/2015.
 * only allow reads without secure api key
 * cache data here so that we dont hit the server for the same info over and over
 */

function RemoteDatastore(appId, pluginId, instanceId, liveMode, dataStoreUrl) {
    this.appId = appId;
    this.pluginId = pluginId;
    this.instanceId = instanceId;
    this.liveMode = liveMode;
    this.dataStoreUrl = dataStoreUrl;
}

RemoteDatastore.prototype = {
    createReadUrl: function createReadUrl(tag, id, withDynamicData) {

        var url = this.dataStoreUrl + "/plugin/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + this.liveMode + "/" + id;
        if (withDynamicData) {
            url += "?withDynamicData=true";
        }
        return url;
    },
    createSearchUrl: function createSearchUrl(tag) {
        return this.dataStoreUrl + "/plugin/search/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + this.liveMode + "/";
    },
    createWriteUrl: function createWriteUrl(tag) {
        return this.dataStoreUrl + "/plugin/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    },
    createCloneUrl: function createCloneUrl(tag) {
        return this.dataStoreUrl + "/app/" + this.appId + "/plugin/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/clone/";
    },
    createSearchAndUpdateUrl: function createSearchAndUpdateUrl(tag) {
        return this.dataStoreUrl + "/plugin/searchAndUpdate/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    },
    createDeleteUrl: function createDeleteUrl(tag, id) {
        return this.dataStoreUrl + "/plugin/delete/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + id;
    },
    createSaveUrl: function createSaveUrl(tag) {
        return this.dataStoreUrl + "/plugin/save/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    },
    createBulkInsertUrl: function createBulkInsertUrl(tag) {
        return this.dataStoreUrl + "/plugin/bulkInsert/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    },
    createPublishUrl: function createPublishUrl() {
        return this.dataStoreUrl + "/publish/" + this.appId;
    },
    createServicesUrl: function createServicesUrl() {
        return this.dataStoreUrl + "/app/" + this.appId + "/services/" + this.liveMode;
    },
    createDeletePluginInstanceUrl: function createDeletePluginInstanceUrl(id) {
        return this.dataStoreUrl + "/plugin/deletePluginInstance/" + this.appId + "/" + id;
    },
    resolveTag: function resolveTag(tag) {
        if (tag == null || tag == undefined || tag == "") return 'primary';
        return tag;
    },
    _httpGet: function _httpGet(url, context, callback) {
        if (typeof context == 'function' && !callback) {
            callback = context;
            context = this;
        }

        if (bfUtils.http) {
            bfUtils.http.get(url).success(function (data) {
                callback.apply(context, [null, data]);
            }).error(function (data, status, headers, config) {
                var errMsg = 'datastore GET Error with URL: ' + config.url;
                callback(errMsg);
                console.error('datastore GET Error: ' + config.url, status);
            });
        } else {
            callback('datastore GET Error:bfUtils.http is undefined. Try again later.');
        }
    },
    _httpPost: function _httpPost(url, data, callback) {

        bfUtils.http.post(url, data).success(function (result) {
            callback(null, result);
        }).error(function (data, status, headers, config) {
            var errMsg = 'datastore POST Error with URL: ' + config.url;
            callback(errMsg);
            console.error('datastore POST Result: ', status, config.url);
        });
    },
    _httpPut: function _httpPut(url, data, callback) {
        bfUtils.http.put(url, data).success(function (result) {
            callback(null, result);
        }).error(function (data, status, headers, config) {
            var errMsg = 'datastore PUT Error with URL: ' + config.url;
            callback(errMsg);
            console.error('datastore PUT Result: ', status, config.url);
        });
    },
    get: function get(id, tag, data, withDynamicData, callback) {
        this._httpGet(this.createReadUrl(tag, id, withDynamicData), data, callback);
        return this;
    },
    save: function save(tag, data, callback) {
        this._httpPost(this.createSaveUrl(tag), data, callback);
        return this;
    },
    insert: function insert(tag, data, callback) {
        this._httpPost(this.createWriteUrl(tag), data, callback);
        return this;
    },
    clone: function clone(tag, data, callback) {
        this._httpPost(this.createCloneUrl(tag), data, callback);
        return this;
    },
    bulkInsert: function bulkInsert(tag, data, callback) {
        this._httpPost(this.createBulkInsertUrl(tag), data, callback);
        return this;
    },
    update: function update(tag, data, callback) {
        this._httpPut(this.createWriteUrl(tag), data, callback);
        return this;
    },
    searchAndUpdate: function searchAndUpdate(tag, data, callback) {
        this._httpPost(this.createSearchAndUpdateUrl(tag), data, callback);
        return this;
    },
    delete: function _delete(tag, id, data, callback) {
        this._httpPost(this.createDeleteUrl(tag, id), data, callback);
        return this;
    },
    search: function search(tag, options, data, callback) {
        this._httpPost(this.createSearchUrl(tag), data, callback);
        return this;
    },
    publish: function publish(data, callback) {
        this._httpPost(this.createPublishUrl(), data, callback);
        return this;
    },
    getServices: function getServices(data, callback) {
        this._httpGet(this.createServicesUrl(), data, callback);
        return this;
    },
    deletePluginInstance: function deletePluginInstance(id, data, callback) {
        this._httpPost(this.createDeletePluginInstanceUrl(id), data, callback);
        return this;
    }
};
"use strict";
/**
 * Created by Daniel on 3/30/2015.
 * only allow reads without secure api key
 * cache data here so that we dont hit the server for the same info over and over
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function DatastoreAPI(appId, pluginId, instanceId, liveMode, writeKey /*, publishKey*/) {

    if (!window.appContext || !window.appContext.currentApp) {
        console.warn("invalid appContext in datastore");
        //return;
        //If this not an issue after Augest First , 2016 then remove this if statement
    }

    this.enableCache = window.location.protocol.indexOf('http') < 0; // enable for non web only
    this.dataStoreUrl = window.siteConfig.endPoints.datastoreHost;

    this._featureSecurityAccess = undefined;
    if (window.appContext && window.appContext.currentApp && window.appContext.currentApp.config) {
        if (typeof window.appContext.currentApp.config.featureSecurityAccess == 'undefined') {
            if (window.appContext.currentApp.config.type == "enterprise") {
                this._featureSecurityAccess = 'enabled';
            }
        } else {
            this._featureSecurityAccess = window.appContext.currentApp.config.featureSecurityAccess;
        }
    }

    if ((typeof appId === "undefined" ? "undefined" : _typeof(appId)) == "object") {
        var config = appId;
        this.appId = config.appId;
        this.pluginId = config.pluginId;
        this.instanceId = config.instanceId;
        this.liveMode = config.liveMode;
        this.writeKey = config.writeKey || (window.appContext.currentApp ? window.appContext.currentApp.keys.datastoreKey : null);
    } else {
        this.appId = appId;
        this.pluginId = pluginId;
        this.instanceId = instanceId;
        this.liveMode = liveMode;
        if (writeKey) this.writeKey = writeKey;else if (window.appContext.currentApp && window.appContext.currentApp.keys && window.appContext.currentApp.keys.datastoreKey) this.writeKey = window.appContext.currentApp.keys.datastoreKey;else if (window.appContext.currentApp && window.appContext.currentApp.datastoreWriteKey) this.writeKey = window.appContext.currentApp.datastoreWriteKey;else this.writeKey = null;
    }

    if (typeof CustomEvent == "undefined") console.warn("Browser doesn't support CustomEvent");

    // check for backward compatibility with old SDK versions. overrides.js loads in SDK only.
    if (typeof RemoteDatastore == "undefined" && document.querySelector('script[src="scripts/overrides.js"]')) {
        console.error("SDK is outdated. Please update to the most recent version.");
        throw "SDK is outdated. Please update to the most recent version.";
    }

    var remoteDatastoreProvider = new RemoteDatastore(this.appId, this.pluginId, this.instanceId, this.liveMode, this.dataStoreUrl);
    if (this.enableCache && typeof OfflineDatastore != 'undefined') {
        this._provider = new OfflineDatastore(this.appId, this.pluginId, this.instanceId, this.liveMode, remoteDatastoreProvider);
    } else {
        this._provider = remoteDatastoreProvider;
    }
}

DatastoreAPI.prototype = {
    deviceOnline: function deviceOnline() {
        if (typeof navigator != "undefined" && navigator.connection && navigator.connection.type) return navigator.connection.type != "none";else return true;
    },
    onUpdate: function onUpdate(callback) {},
    triggerOnUpdate: function triggerOnUpdate(data) {
        if (this.onUpdate) this.onUpdate(data);
    },
    onRefresh: function onRefresh(callback) {
        document.addEventListener('datastoreOnRefresh', callback, false);
    },
    triggerOnRefresh: function triggerOnRefresh(data) {
        var onUpdateEvent = new CustomEvent('datastoreOnRefresh', { 'detail': data });
        document.dispatchEvent(onUpdateEvent);
    },
    onDisableRefresh: function onDisableRefresh(callback) {
        document.addEventListener('datastoreOnDisableRefresh', callback, false);
    },
    disableRefresh: function disableRefresh() {
        document.dispatchEvent(new CustomEvent('datastoreOnDisableRefresh'));
    },
    resolveTag: function resolveTag(tag) {
        if (tag == null || tag == undefined || tag == "") return 'primary';
        return tag;
    },
    get: function get(obj, callback) {
        if (typeof callback != "function") return; // don't bother

        var self = this;

        var tag;
        var id = '';
        var withDynamicData = false;
        if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) == "object") {
            if (typeof obj.tag == "string") tag = obj.tag;else tag = '';
            if (typeof obj.id == "string") id = obj.id;else id = '';
            withDynamicData = obj.withDynamicData;
        } else if (typeof obj == "string") tag = obj;else if (tag == null || tag == undefined) tag = '';

        if (typeof tag != "string") tag = '';
        var requestTime = Date.now();
        this._provider.get(id, tag, { ds: this,
            obj: obj
        }, withDynamicData, function (err, data) {
            //var responseTime = Date.now() - requestTime;
            //console.log('datastore: response time ' + responseTime);
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                if (data == null) {
                    callback(null, null);
                } else {
                    var saveTag = data.tag;
                    data.tag = tag;
                    if (withDynamicData && data && data.data && data.data._buildfire) {
                        self._dynamicDataSecurityFilter(data.data._buildfire, function (err, result) {
                            data.data._buildfire = result;
                            callback(null, data);
                            data.tag = saveTag;
                        });
                    } else {
                        callback(null, data);
                        data.tag = saveTag;
                    }
                }
            }
        });
        return this;
    },
    save: function save(obj, callback) {
        if (window.toast) window.toast('saving...');
        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = obj.tag,
            data = obj.obj;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = this._cleanUp(data);
            if (typeof angular != "undefined") data = angular.toJson({ data: data, writeKey: this.writeKey, id: obj.id });else data = JSON.stringify({ data: data, writeKey: this.writeKey, id: obj.id });
        }

        var t = this;
        this._provider.save(tag, data, function (err) {
            if (err == 404) {
                if (window.toast) window.toast('404', 'danger');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error saving', 'danger');
                callback(err);
            } else {
                var result = {
                    id: obj.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    insert: function insert(obj, callback) {

        var tag = obj.tag,
            data = obj.obj,
            checkDuplicate = obj.checkDuplicate;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = this._cleanUp(data);
            data = { data: data, writeKey: this.writeKey };
            if (checkDuplicate) data.checkDuplicate = checkDuplicate;
            data = JSON.stringify(data);
        }

        var t = this;
        this._provider.insert(tag, data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                obj.id = response.id;
                var result = {
                    id: response.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    clone: function clone(obj, callback) {

        var tag = obj.tag,
            data = obj.obj,
            checkDuplicate = obj.checkDuplicate;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = this._cleanUp(data);
            data = { data: data, writeKey: this.writeKey };
            if (checkDuplicate) data.checkDuplicate = checkDuplicate;
            data = JSON.stringify(data);
        }

        var t = this;
        this._provider.clone(tag, data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                obj.id = response.id;
                var result = {
                    id: response.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    bulkInsert: function bulkInsert(obj, callback) {
        var tag = obj.tag,
            data = obj.obj;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = this._cleanUp(data);
            data = JSON.stringify({ data: data, writeKey: this.writeKey, checkDuplicate: false });
        }

        var t = this;
        this._provider.bulkInsert(tag, data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                var result = {
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    update: function update(args, callback) {
        if (window.toast) window.toast('saving...');
        var tag = args.tag,
            data = args.obj;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = this._cleanUp(data);
            data = JSON.stringify({ id: args.id, data: data, writeKey: this.writeKey });
        }

        var t = this;
        this._provider.update(tag, data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error updating');
                callback(err);
            } else {
                //if (window.toast)window.toast('saved.');
                response.record.tag = args.tag;
                callback(null, response.record);
                t.triggerOnUpdate(response.record);
            }
        });
        return this;
    },
    searchAndUpdate: function searchAndUpdate(args, callback) {
        if (window.toast) window.toast('saving...');
        var tag = args.tag,
            data = args.obj;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = this._cleanUp(data);
            data = JSON.stringify({ search: args.search, data: data, writeKey: this.writeKey });
        }

        var t = this;
        this._provider.searchAndUpdate(tag, data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error updating');
                callback(err);
            } else {
                //if (window.toast)window.toast('saved.');
                callback(null, response);
                t.triggerOnUpdate(response);
            }
        });
        return this;
    },
    delete: function _delete(args, callback) {

        var tag = args.tag;

        var data = JSON.stringify({ writeKey: this.writeKey });

        var t = this;
        this._provider.delete(tag, args.id, data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                callback(null, response);
                t.triggerOnUpdate(args);
            }
        });
        return this;
    },
    deletePluginInstance: function deletePluginInstance(args, callback) {
        var data = JSON.stringify({ writeKey: this.writeKey });

        var t = this;
        this._provider.deletePluginInstance(args.id, data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                callback(null, response);
                t.triggerOnUpdate(args);
            }
        });
        return this;
    },
    search: function search(packet, callback) {
        var self = this;
        var tag = packet.tag;
        var data = packet.obj;
        if (typeof callback != "function") return; // dont bother

        if (typeof tag != "string") tag = '';

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") data = JSON.stringify(data);

        this._provider.search(tag, packet.obj, data, function (err, data) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                /*try {*/

                if (data == null) callback(null, null);else if (typeof data == "string") callback(null, bfUtils.tryParseJSON(data));else {
                    if (self.pluginId === 'pluginInstances') {
                        //
                        if (typeof userTags != "undefined" && userTags.checkPluginAccessSettings && data.result) {
                            self._pluginInstancesSecurityFilter(data.result);
                        }
                        callback(null, data);
                    } else {
                        callback(null, data);
                    }
                }
                /*}
                catch (e) {
                    callback({data : 'cannot parse data: ' + JSON.stringify(packet) , error : JSON.stringify(e)  });
                }*/
            }
        });
        return this;
    },
    publish: function publish(callback) {
        var data = JSON.stringify({ publishKey: this.publishKey });
        var t = this;
        this._provider.publish(data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                /*try {*/
                callback(null, bfUtils.tryParseJSON(response));
                /*}
                catch (e) {
                    callback('cannot parse data: ' + response);
                }*/
                t.triggerOnUpdate(obj);
            }
        });
        return this;
    },
    getServices: function getServices(data, callback) {
        this._provider.getServices(data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                callback(null, response);
            }
        });
        return this;
    },
    _cleanUp: function _cleanUp(data) {
        if (data) {
            var clone = JSON.parse(JSON.stringify(data));
            this._cleanUpTree(clone);
            return clone;
        } else {
            return data;
        }
    },
    _cleanUpTree: function _cleanUpTree(node) {
        for (var property in node) {
            var subNode = node[property];
            if (property == '_buildfire' && subNode) {
                // clean auto injected _buildfire
                delete subNode.result;
                delete subNode.err;
            } else {
                if (subNode !== null && (typeof subNode === "undefined" ? "undefined" : _typeof(subNode)) == "object") {
                    this._cleanUpTree(node[property]);
                }
            }
        }
    },
    _dynamicDataSecurityFilter: function _dynamicDataSecurityFilter(_buildfire, callback) {
        if (typeof userTags != "undefined" && userTags.checkPluginAccessSettings) {
            for (var key in _buildfire) {
                if (!key) continue;
                var currentInstance = _buildfire[key];
                if (currentInstance && currentInstance.result) {
                    this._pluginInstancesSecurityFilter(currentInstance.result);
                }
            }
        }
        callback(null, _buildfire);
    },
    _pluginInstancesSecurityFilter: function _pluginInstancesSecurityFilter(pluginInstances) {
        var self = this;
        if (pluginInstances) {
            pluginInstances.forEach(function (pInstance) {
                if (pInstance && pInstance.data) {
                    pInstance.hasAccess = true;
                    if (self._featureSecurityAccess === 'enabled') {
                        userTags.checkPluginAccessSettings(pInstance.data, function (err, hasAccess) {
                            pInstance.hasAccess = hasAccess;
                        });
                    }
                }
            });
        }
    }
};
'use strict';

var appApiKeys = {
    _callbacksQueue: [],
    _getInProgress: false,
    get: function get(callback) {
        if (window.appContext) {
            if (window.appContext.currentApp.apiKeys) {
                if (callback) callback(null, window.appContext.currentApp.apiKeys);
                return window.appContext.currentApp.apiKeys;
            }

            if (callback) appApiKeys._callbacksQueue.splice(0, 0, callback);

            if (!appApiKeys._getInProgress) {
                appApiKeys._getInProgress = true;
                var _APIKeys = new window.DatastoreAPI({
                    appId: window.appContext.currentApp.appId,
                    pluginId: 'apiKeys',
                    instanceId: 'apiKeys'
                });

                _APIKeys.get({ tag: 'apiKeys' }, function (err, result) {
                    if (err) {
                        while (callback = appApiKeys._callbacksQueue.pop()) {
                            callback(err);
                        }
                        appApiKeys._getInProgress = false;
                        return;
                    }
                    if (result && result.data) {
                        //fetch the keys and save in memory to be ready when it needs
                        window.appContext.currentApp.apiKeys = result.data;
                    } else {
                        window.appContext.currentApp.apiKeys = {};
                    }
                    while (callback = appApiKeys._callbacksQueue.pop()) {
                        callback(null, window.appContext.currentApp.apiKeys);
                    }
                    appApiKeys._getInProgress = false;
                });
            }
        } else {
            if (callback) {
                callback('no appContext');
            }
        }
    }
};
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function UserDatastoreAPI(appId, pluginId, instanceId, isAppUser, writeKey) {

    if (!window.appContext || !window.appContext.currentApp) {
        console.error("invalid appCOntext in userstore");
        return;
    }

    this.enableCache = false; // don't enable, cache is not invalidated properly
    this.dataStoreUrl = window.siteConfig.endPoints.datastoreHost;

    if ((typeof appId === "undefined" ? "undefined" : _typeof(appId)) == "object") {
        var config = appId;
        this.appId = config.appId;
        this.pluginId = config.pluginId;
        this.instanceId = config.instanceId;
        this.isAppUser = config.type != 'control';
        if (!this.isAppUser) this.writeKey = config.writeKey || (window.appContext.currentApp ? window.appContext.currentApp.keys.datastoreKey : null);else this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;
    } else {
        this.appId = appId;
        this.pluginId = pluginId;
        this.instanceId = instanceId;

        this.isAppUser = isAppUser;
        if (!this.isAppUser) this.writeKey = writeKey || (window.appContext.currentApp ? window.appContext.currentApp.keys.datastoreKey : null);else this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;
    }

    if (typeof CustomEvent == "undefined") console.warn("Browser doesnt support CustomEvent");
}

UserDatastoreAPI.prototype = {
    onUpdate: function onUpdate(callback) {

        //document.addEventListener('datastoreOnUpdate', callback, false);
    },
    triggerOnUpdate: function triggerOnUpdate(data) {
        if (this.onUpdate) this.onUpdate(data);
        //var onUpdateEvent = new CustomEvent('datastoreOnUpdate', {'detail': data});
        //document.dispatchEvent(onUpdateEvent);
    },
    onRefresh: function onRefresh(callback) {
        document.addEventListener('userDataOnRefresh', callback, false);
    },
    triggerOnRefresh: function triggerOnRefresh(data) {
        var onUpdateEvent = new CustomEvent('userDataOnRefresh', { 'detail': data });
        document.dispatchEvent(onUpdateEvent);
    },
    onDisableRefresh: function onDisableRefresh(callback) {
        document.addEventListener('userDatastoreOnDisableRefresh', callback, false);
    },
    disableRefresh: function disableRefresh() {
        document.dispatchEvent(new CustomEvent('userDatastoreOnDisableRefresh'));
    },
    resolveTag: function resolveTag(tag) {
        if (tag == null || tag == undefined || tag == "") return 'primary';
        return tag;
    },
    createReadUrl: function createReadUrl(tag, userToken, id) {
        return this.dataStoreUrl + "/user/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken + "/" + id;
    },
    createSearchUrl: function createSearchUrl(tag) {
        return this.dataStoreUrl + "/user/search/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    },
    createWriteUrl: function createWriteUrl(tag, userToken) {
        return this.dataStoreUrl + "/user/insert/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken + "/";
    },
    createSearchAndUpdateUrl: function createSearchAndUpdateUrl(tag, userToken) {
        return this.dataStoreUrl + "/user/searchAndUpdate/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken + "/";
    },
    createDeleteUrl: function createDeleteUrl(tag, id, userToken) {
        return this.dataStoreUrl + "/user/delete/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken + "/" + id;
    },
    createSaveUrl: function createSaveUrl(tag, userToken) {
        return this.dataStoreUrl + "/user/save/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken + "/";
    },
    createBulkInsertUrl: function createBulkInsertUrl(tag, userToken) {
        return this.dataStoreUrl + "/user/bulkInsert/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken + "/";
    },

    _httpGet: function _httpGet(url, context, callback) {
        if (typeof context == 'function' && !callback) {
            callback = context;
            context = this;
        }
        bfUtils.http.get(url).success(function (data) {
            callback.apply(context, [null, data]);
        }).error(function (err, status) {
            err = err || "http error with status: " + status;
            callback.apply(context, [err]);
            console.error('user datastore GET Error: ', url, err);
        });
    },
    _httpPost: function _httpPost(url, data, callback) {

        bfUtils.http.post(url, data).success(function (result) {
            callback(null, result);
        }).error(function (err, status) {
            err = err || "http error with status: " + status;
            callback(err);
            console.error('user datastore POST Result: ', url, err);
        });
    },
    _httpPut: function _httpPut(url, data, callback) {
        bfUtils.http.put(url, data).success(function (result) {
            callback(null, result);
        }).error(function (err, status) {
            err = err || "http error with status: " + status;
            callback(err);
            console.error('user datastore PUT Result: ', url, err);
        });
    },
    get: function get(obj, callback) {
        console.log('user datastore: get ' + JSON.stringify(obj));
        if (typeof callback != "function") return; // don't bother

        /*
         ///create a delay
         console.warn('create artificial delay >>');
         var originalCallback=callback;;
         callback = function(err,data){ setTimeout(function(){
         console.warn('<< resume');
         originalCallback(err,data)
         },5000); };
         */
        if (this.isAppUser) this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;

        if (!this.writeKey) {
            console.error("no write key has been provided");
            callback('no logged in user found', null);
            return;
        }
        var tag;
        var id = '';
        var withDynamicData = false;
        if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) == "object") {
            if (typeof obj.tag == "string") tag = obj.tag;else tag = '';
            if (typeof obj.id == "string") id = obj.id;else id = '';
        } else if (typeof obj == "string") tag = obj;else if (tag == null || tag == undefined) tag = '';

        if (typeof tag != "string") tag = '';

        //check if the dataDump record exist
        //if true : return cached record in callback ,continue with http call (without callback) ,update local cache , trigger on update
        //else : continue with http normally

        var isCallBackDone = false;
        var cachedData = null;
        //check local storage
        try {
            if (this.enableCache && typeof userDataDumpAPI !== 'undefined') {
                console.log('data cache: check for cache');
                cachedData = userDataDumpAPI.getData(this.appId, this.pluginId, this.instanceId, this.resolveTag(tag), obj.id);
                if (cachedData) {
                    console.log('data cache: found cache');
                    var result = cachedData;
                    result.tag = obj.tag;
                    result.obj = obj.obj;
                    callback(null, result);
                    isCallBackDone = true;
                }
            }
        } catch (ex) {
            debugger;
            console.error('dataDump error: ' + ex);
        }

        //var t = this;
        var requestTime = Date.now();
        this._httpGet(this.createReadUrl(tag, this.writeKey, id, withDynamicData), { ds: this,
            isCallBackDone: isCallBackDone,
            obj: obj,
            userDataDumpAPI: window.userDataDumpAPI
        }, function (err, data) {
            var context = this;
            var responseTime = Date.now() - requestTime;
            console.log('user datastore: response time ' + responseTime);
            if (err) {
                if (!context.isCallBackDone) callback(err);
            } else if (err == 404) {
                if (!context.isCallBackDone) callback(null, null);
            } else {
                try {
                    if (data == null) {
                        if (!context.isCallBackDone) callback(null, null);
                    } else {
                        if (context.ds.enableCache && typeof context.userDataDumpAPI !== 'undefined') context.userDataDumpAPI.setData(context.ds.appId, context.ds.pluginId, context.ds.instanceId, context.ds.resolveTag(context.obj.tag), context.obj.id, data);

                        data.tag = context.obj.tag;
                        if (!context.isCallBackDone) callback(null, data);else if (cachedData && cachedData.lastUpdated != data.lastUpdated) {
                            console.log('data cache: send updated object onUpdate');
                            // needs some time to load before sending the update
                            //setTimeout(function(){context.ds.triggerOnUpdate(data);},3000);
                            context.ds.triggerOnUpdate(data);
                        }
                    }
                } catch (e) {
                    if (!isCallBackDone) callback(e);
                }
            }
        });
        return this;
    },
    save: function save(obj, callback) {
        if (window.toast) window.toast('saving...');
        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;
        }

        if (!this.writeKey) {
            console.error("no write key has been provided");
            if (callback) callback('no logged in user found', null);
            return;
        }
        var tag = obj.tag,
            data = obj.obj,
            userToken = obj.userToken ? obj.userToken : this.writeKey;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            if (typeof angular != "undefined") {
                if (this.isAppUser) data = angular.toJson({ data: data, userToken: this.writeKey, id: obj.id });else data = angular.toJson({ data: data, writeKey: this.writeKey, id: obj.id });
            } else {
                if (this.isAppUser) data = JSON.stringify({ data: data, userToken: this.writeKey, id: obj.id });else data = JSON.stringify({ data: data, writeKey: this.writeKey, id: obj.id });
            }
        }

        var t = this;
        this._httpPost(this.createSaveUrl(tag, userToken), data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404', 'danger');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error saving', 'danger');
                callback(err);
            } else {
                //if (window.toast)window.toast('saved');
                var result = {
                    id: obj.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    insert: function insert(obj, callback) {

        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;
        }

        if (!this.writeKey) {
            console.error("no write key has been provided");
            if (callback) callback('no logged in user found', null);
            return;
        }
        var tag = obj.tag,
            data = obj.obj,
            checkDuplicate = obj.checkDuplicate,
            userToken = obj.userToken ? obj.userToken : this.writeKey;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {

            if (this.isAppUser) data = { data: data, userToken: this.writeKey };else data = { data: data, writeKey: this.writeKey };

            if (checkDuplicate) data.checkDuplicate = checkDuplicate;
            data = JSON.stringify(data);
        }

        var t = this;
        this._httpPost(this.createWriteUrl(tag, userToken), data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                obj.id = response.id;
                var result = {
                    id: response.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    bulkInsert: function bulkInsert(obj, callback) {

        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;
        }

        if (!this.writeKey) {
            console.error("no write key has been provided");
            if (callback) callback('no logged in user found', null);
            return;
        }

        var tag = obj.tag,
            data = obj.obj,
            userToken = obj.userToken ? obj.userToken : this.writeKey;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {

            if (this.isAppUser) data = JSON.stringify({ data: data, userToken: this.writeKey, checkDuplicate: false });else data = JSON.stringify({ data: data, writeKey: this.writeKey, checkDuplicate: false });
        }

        var t = this;
        this._httpPost(this.createBulkInsertUrl(tag, userToken), data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                var result = {
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    update: function update(args, callback) {
        if (window.toast) window.toast('saving...');
        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;
        }

        if (!this.writeKey) {
            console.error("no write key has been provided");
            if (callback) callback('no logged in user found', null);
            return;
        }
        var tag = args.tag,
            data = args.obj,
            userToken = args.userToken ? args.userToken : this.writeKey;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {

            if (this.isAppUser) data = JSON.stringify({ id: args.id, data: data, userToken: this.writeKey });else data = JSON.stringify({ id: args.id, data: data, writeKey: this.writeKey });
        }

        var t = this;
        this._httpPut(this.createWriteUrl(tag, userToken), data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error updating');
                callback(err);
            } else {
                //if (window.toast)window.toast('saved.');
                response.record.tag = args.tag;
                callback(null, response.record);
                t.triggerOnUpdate(response.record);
            }
        });
        return this;
    },
    searchAndUpdate: function searchAndUpdate(args, callback) {
        if (window.toast) window.toast('saving...');
        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;
        }

        if (!this.writeKey) {
            console.error("no write key has been provided");
            if (callback) callback('no logged in user found', null);
            return;
        }
        var tag = args.tag,
            data = args.obj,
            userToken = args.userToken ? args.userToken : this.writeKey;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            if (this.isAppUser) data = JSON.stringify({ search: args.search, data: data, userToken: this.writeKey });else data = JSON.stringify({ search: args.search, data: data, writeKey: this.writeKey });
        }

        var t = this;
        this._httpPost(this.createSearchAndUpdateUrl(tag, userToken), data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error updating');
                callback(err);
            } else {
                //if (window.toast)window.toast('saved.');
                callback(null, response);
                t.triggerOnUpdate(response);
            }
        });
        return this;
    },
    delete: function _delete(args, callback) {
        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;
        }

        if (!this.writeKey) {
            console.error("no write key has been provided");
            if (callback) callback('no logged in user found', null);
            return;
        }
        var data = {};
        var tag = args.tag,
            userToken = args.userToken ? args.userToken : this.writeKey;

        if (this.isAppUser) data = JSON.stringify({ userToken: this.writeKey });else data = JSON.stringify({ writeKey: this.writeKey });

        var t = this;
        this._httpPost(this.createDeleteUrl(tag, args.id, userToken), data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                callback(null, response);
                t.triggerOnUpdate(args);
            }
        });
        return this;
    },
    search: function search(packet, callback) {

        if (this.isAppUser) this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;

        if (!this.writeKey) {
            console.error("no write key has been provided");
            if (callback) callback('no logged in user found', null);
            return;
        }
        var tag = packet.tag;
        var data = packet.obj;
        if (typeof callback != "function") return; // dont bother

        //if(typeof(data) != "object")debugger;

        if (typeof tag != "string") tag = '';

        if (typeof data == "string") data = JSON.parse(data);

        if (this.isAppUser) data.userToken = this.writeKey;else data.writeKey = this.writeKey;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") data = JSON.stringify(data);

        this._httpPost(this.createSearchUrl(tag), data, function (err, data) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                /*try {*/

                if (data == null) callback(null, null);else if (typeof data == "string") callback(null, bfUtils.tryParseJSON(data));else callback(null, data);
                /*}
                catch (e) {
                    callback('cannot parse data: ' + data);
                }*/
            }
        });
        return this;
    },

    dataDump: function dataDump(callback) {
        if (this.isAppUser) this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;

        if (!this.writeKey) {
            console.error("no write key has been provided");
            if (callback) callback('no logged in user found', null);
            return;
        }
        var t = this;
        this._httpget(this.createDataDumpUrl(), function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                /*try {*/
                callback(null, bfUtils.tryParseJSON(response));
                /*}
                catch (e) {
                    callback('cannot parse data: ' + response);
                }*/
                t.triggerOnUpdate(obj);
            }
        });
        return this;
    }

};
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function PublicDatastoreAPI(appId, pluginId, instanceId) {

    if (!window.appContext || !window.appContext.currentApp) {
        console.error("invalid appCOntext in publicdata");
        return;
    }

    this.enableCache = true; // window.location.protocol.indexOf('http') < 0; // enable for non web only
    this.dataStoreUrl = window.siteConfig.endPoints.datastoreHost;

    if ((typeof appId === "undefined" ? "undefined" : _typeof(appId)) == "object") {
        var config = appId;
        this.appId = config.appId;
        this.pluginId = config.pluginId;
        this.instanceId = config.instanceId;

        this.writeKey = "public";
    } else {
        this.appId = appId;
        this.pluginId = pluginId;
        this.instanceId = instanceId;

        this.writeKey = "public";
    }

    if (typeof CustomEvent == "undefined") console.warn("Browser doesnt support CustomEvent");
}

PublicDatastoreAPI.prototype = {
    onUpdate: function onUpdate(callback) {
        document.addEventListener('publicDataOnUpdate', callback, false);
    },
    triggerOnUpdate: function triggerOnUpdate(data) {
        if (this.onUpdate) this.onUpdate(data);
        var onUpdateEvent = new CustomEvent('publicDataOnUpdate', { 'detail': data });
        document.dispatchEvent(onUpdateEvent);
    },
    onRefresh: function onRefresh(callback) {
        document.addEventListener('publicDataOnRefresh', callback, false);
    },
    triggerOnRefresh: function triggerOnRefresh(data) {
        var onUpdateEvent = new CustomEvent('publicDataOnRefresh', { 'detail': data });
        document.dispatchEvent(onUpdateEvent);
    },
    onDisableRefresh: function onDisableRefresh(callback) {
        document.addEventListener('publicDatastoreOnDisableRefresh', callback, false);
    },
    disableRefresh: function disableRefresh() {
        document.dispatchEvent(new CustomEvent('publicDatastoreOnDisableRefresh'));
    },
    resolveTag: function resolveTag(tag) {
        if (tag == null || tag == undefined || tag == "") return 'primary';
        return tag;
    },
    createReadUrl: function createReadUrl(tag, id) {
        return this.dataStoreUrl + "/user/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/" + id;
    },
    createSearchUrl: function createSearchUrl(tag) {
        return this.dataStoreUrl + "/user/search/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    },
    createWriteUrl: function createWriteUrl(tag) {
        return this.dataStoreUrl + "/user/insert/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/";
    },
    createSearchAndUpdateUrl: function createSearchAndUpdateUrl(tag) {
        return this.dataStoreUrl + "/user/searchAndUpdate/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/";
    },
    createDeleteUrl: function createDeleteUrl(tag, id) {
        return this.dataStoreUrl + "/user/delete/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/" + id;
    },
    createSaveUrl: function createSaveUrl(tag) {
        return this.dataStoreUrl + "/user/save/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/";
    },
    createBulkInsertUrl: function createBulkInsertUrl(tag) {
        return this.dataStoreUrl + "/user/bulkInsert/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/";
    },

    _httpGet: function _httpGet(url, context, callback) {
        if (typeof context == 'function' && !callback) {
            callback = context;
            context = this;
        }
        bfUtils.http.get(url).success(function (data) {
            callback.apply(context, [null, data]);
        }).error(function (err) {
            callback.apply(context, [err]);
            console.error('public datastore GET Error: ', url, err);
        });
    },
    _httpPost: function _httpPost(url, data, callback) {

        bfUtils.http.post(url, data).success(function (result) {
            callback(null, result);
        }).error(function (err) {
            callback(err);
            console.error('public datastore POST Result: ', url, err);
        });
    },
    _httpPut: function _httpPut(url, data, callback) {
        bfUtils.http.put(url, data).success(function (result) {
            callback(null, result);
        }).error(function (err) {
            callback(err);
            console.error('public datastore PUT Result: ', url, err);
        });
    },
    get: function get(obj, callback) {
        console.log('public datastore: get ' + JSON.stringify(obj));
        if (typeof callback != "function") return; // don't bother

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag;
        var id = '';
        var withDynamicData = false;
        if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) == "object") {
            if (typeof obj.tag == "string") tag = obj.tag;else tag = '';
            if (typeof obj.id == "string") id = obj.id;else id = '';
        } else if (typeof obj == "string") tag = obj;else if (tag == null || tag == undefined) tag = '';

        if (typeof tag != "string") tag = '';

        //check if the dataDump record exist
        //if true : return cached record in callback ,continue with http call (without callback) ,update local cache , trigger on update
        //else : continue with http normally

        var isCallBackDone = false;
        var cachedData = null;
        //check local storage
        try {
            if (this.enableCache && typeof userDataDumpAPI !== 'undefined') {
                console.log('data cache: check for cache');
                cachedData = userDataDumpAPI.getData(this.appId, this.pluginId, this.instanceId, this.resolveTag(tag), obj.id);
                if (cachedData) {
                    console.log('data cache: found cache');
                    var result = cachedData;
                    result.tag = obj.tag;
                    result.obj = obj.obj;
                    callback(null, result);
                    isCallBackDone = true;
                }
            }
        } catch (ex) {
            debugger;
            console.error('dataDump error: ' + ex);
        }

        //var t = this;
        var requestTime = Date.now();
        this._httpGet(this.createReadUrl(tag, id, withDynamicData), {
            ds: this,
            isCallBackDone: isCallBackDone,
            obj: obj,
            userDataDumpAPI: window.userDataDumpAPI
        }, function (err, data) {
            var context = this;
            var responseTime = Date.now() - requestTime;
            console.log('public datastore: response time ' + responseTime);
            if (err) {
                if (!context.isCallBackDone) callback(err);
            } else if (err == 404) {
                if (!context.isCallBackDone) callback(null, null);
            } else {
                try {
                    if (data == null) {
                        if (!context.isCallBackDone) callback(null, null);
                    } else {
                        if (context.ds.enableCache && typeof context.userDataDumpAPI !== 'undefined') context.userDataDumpAPI.setData(context.ds.appId, context.ds.pluginId, context.ds.instanceId, context.ds.resolveTag(context.obj.tag), context.obj.id, data);

                        data.tag = context.obj.tag;
                        if (!context.isCallBackDone) callback(null, data);else if (cachedData && cachedData.lastUpdated != data.lastUpdated) {
                            console.log('data cache: send updated object onUpdate');
                            // needs some time to load before sending the update
                            //setTimeout(function(){context.ds.triggerOnUpdate(data);},3000);
                            context.ds.triggerOnUpdate(data);
                        }
                    }
                } catch (e) {
                    if (!isCallBackDone) callback(e);
                }
            }
        });
        return this;
    },
    save: function save(obj, callback) {
        if (window.toast) window.toast('saving...');

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = obj.tag,
            data = obj.obj;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            if (typeof angular != "undefined") {
                data = angular.toJson({ data: data, userToken: this.writeKey, id: obj.id });
            } else {
                data = JSON.stringify({ data: data, userToken: this.writeKey, id: obj.id });
            }
        }

        var t = this;
        this._httpPost(this.createSaveUrl(tag), data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404', 'danger');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error saving', 'danger');
                callback(err);
            } else {
                //if (window.toast)window.toast('saved');
                var result = {
                    id: obj.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    insert: function insert(obj, callback) {

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = obj.tag,
            data = obj.obj,
            checkDuplicate = obj.checkDuplicate;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {

            data = { data: data, userToken: this.writeKey };

            if (checkDuplicate) data.checkDuplicate = checkDuplicate;
            data = JSON.stringify(data);
        }

        var t = this;
        this._httpPost(this.createWriteUrl(tag), data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                obj.id = response.id;
                var result = {
                    id: response.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    bulkInsert: function bulkInsert(obj, callback) {

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }

        var tag = obj.tag,
            data = obj.obj;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = JSON.stringify({ data: data, userToken: this.writeKey, checkDuplicate: false });
        }

        var t = this;
        this._httpPost(this.createBulkInsertUrl(tag), data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                var result = {
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    update: function update(args, callback) {
        if (window.toast) window.toast('saving...');

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = args.tag,
            data = args.obj;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = JSON.stringify({ id: args.id, data: data, userToken: this.writeKey });
        }

        var t = this;
        this._httpPut(this.createWriteUrl(tag), data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error updating');
                callback(err);
            } else {
                //if (window.toast)window.toast('saved.');
                response.record.tag = args.tag;
                callback(null, response.record);
                t.triggerOnUpdate(response.record);
            }
        });
        return this;
    },
    searchAndUpdate: function searchAndUpdate(args, callback) {
        if (window.toast) window.toast('saving...');

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = args.tag,
            data = args.obj;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = JSON.stringify({ search: args.search, data: data, userToken: this.writeKey });
        }

        var t = this;
        this._httpPost(this.createSearchAndUpdateUrl(tag), data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error updating');
                callback(err);
            } else {
                //if (window.toast)window.toast('saved.');
                callback(null, response);
                t.triggerOnUpdate(response);
            }
        });
        return this;
    },
    delete: function _delete(args, callback) {
        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = args.tag;
        var data = JSON.stringify({ userToken: this.writeKey });

        var t = this;
        this._httpPost(this.createDeleteUrl(tag, args.id), data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                callback(null, response);
                t.triggerOnUpdate(args);
            }
        });
        return this;
    },
    search: function search(packet, callback) {

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = packet.tag;
        var data = packet.obj;
        if (typeof callback != "function") return; // dont bother

        //if(typeof(data) != "object")debugger;

        if (typeof tag != "string") tag = '';

        if (typeof data == "string") data = JSON.parse(data);

        data.userToken = this.writeKey;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") data = JSON.stringify(data);

        this._httpPost(this.createSearchUrl(tag), data, function (err, data) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                /*try {*/

                if (data == null) callback(null, null);else if (typeof data == "string") callback(null, bfUtils.tryParseJSON(data));else callback(null, data);
                /*}
                 catch (e) {
                 callback('cannot parse data: ' + data);
                 }*/
            }
        });
        return this;
    },

    dataDump: function dataDump(callback) {
        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var t = this;
        this._httpget(this.createDataDumpUrl(), function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                /*try {*/
                callback(null, bfUtils.tryParseJSON(response));
                /*}
                 catch (e) {
                 callback('cannot parse data: ' + response);
                 }*/
                t.triggerOnUpdate(obj);
            }
        });
        return this;
    }
};
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function AppDatastoreAPI(appId) {
	if (!window.appContext || !window.appContext.currentApp) {
		console.error('invalid appCOntext in publicdata');
		return;
	}

	this.enableCache = true; // window.location.protocol.indexOf('http') < 0; // enable for non web only
	this.dataStoreUrl = window.siteConfig.endPoints.datastoreHost;

	if ((typeof appId === 'undefined' ? 'undefined' : _typeof(appId)) == 'object') {
		var config = appId;
		this.appId = config.appId;
		this.pluginId = 'public';
		this.instanceId = 'public';

		this.writeKey = 'public';
	} else {
		this.appId = appId;
		this.pluginId = 'public';
		this.instanceId = 'public';

		this.writeKey = 'public';
	}

	if (typeof CustomEvent == 'undefined') console.warn('Browser doesnt support CustomEvent');
}

AppDatastoreAPI.prototype = {
	onUpdate: function onUpdate(callback) {
		document.addEventListener('appDataOnUpdate', callback, false);
	},
	triggerOnUpdate: function triggerOnUpdate(data) {
		if (this.onUpdate) this.onUpdate(data);
		var onUpdateEvent = new CustomEvent('appDataOnUpdate', { detail: data });
		document.dispatchEvent(onUpdateEvent);
	},
	onRefresh: function onRefresh(callback) {
		document.addEventListener('appDataOnRefresh', callback, false);
	},
	triggerOnRefresh: function triggerOnRefresh(data) {
		var onUpdateEvent = new CustomEvent('appDataOnRefresh', { detail: data });
		document.dispatchEvent(onUpdateEvent);
	},
	onDisableRefresh: function onDisableRefresh(callback) {
		document.addEventListener('appDatastoreOnDisableRefresh', callback, false);
	},
	disableRefresh: function disableRefresh() {
		document.dispatchEvent(new CustomEvent('appDatastoreOnDisableRefresh'));
	},
	resolveTag: function resolveTag(tag) {
		if (tag == null || tag == undefined || tag == '') return 'primary';
		return tag;
	},
	createReadUrl: function createReadUrl(tag, id) {
		return this.dataStoreUrl + '/user/' + this.appId + '/' + this.pluginId + '/' + this.instanceId + '/' + this.resolveTag(tag) + '/public/' + id;
	},
	createSearchUrl: function createSearchUrl(tag) {
		return this.dataStoreUrl + '/user/search/' + this.appId + '/' + this.pluginId + '/' + this.instanceId + '/' + this.resolveTag(tag) + '/';
	},
	createWriteUrl: function createWriteUrl(tag) {
		return this.dataStoreUrl + '/user/insert/' + this.appId + '/' + this.pluginId + '/' + this.instanceId + '/' + this.resolveTag(tag) + '/public/';
	},
	createSearchAndUpdateUrl: function createSearchAndUpdateUrl(tag) {
		return this.dataStoreUrl + '/user/searchAndUpdate/' + this.appId + '/' + this.pluginId + '/' + this.instanceId + '/' + this.resolveTag(tag) + '/public/';
	},
	createDeleteUrl: function createDeleteUrl(tag, id) {
		return this.dataStoreUrl + '/user/delete/' + this.appId + '/' + this.pluginId + '/' + this.instanceId + '/' + this.resolveTag(tag) + '/public/' + id;
	},
	createSaveUrl: function createSaveUrl(tag) {
		return this.dataStoreUrl + '/user/save/' + this.appId + '/' + this.pluginId + '/' + this.instanceId + '/' + this.resolveTag(tag) + '/public/';
	},
	createBulkInsertUrl: function createBulkInsertUrl(tag) {
		return this.dataStoreUrl + '/user/bulkInsert/' + this.appId + '/' + this.pluginId + '/' + this.instanceId + '/' + this.resolveTag(tag) + '/public/';
	},

	_httpGet: function _httpGet(url, context, callback) {
		if (typeof context == 'function' && !callback) {
			callback = context;
			context = this;
		}
		bfUtils.http.get(url).success(function (data) {
			callback.apply(context, [null, data]);
		}).error(function (err) {
			callback.apply(context, [err]);
			console.error('appDatastore GET Error: ', url, err);
		});
	},
	_httpPost: function _httpPost(url, data, callback) {
		bfUtils.http.post(url, data).success(function (result) {
			callback(null, result);
		}).error(function (err) {
			callback(err);
			console.error('appDatastore POST Result: ', url, err);
		});
	},
	_httpPut: function _httpPut(url, data, callback) {
		bfUtils.http.put(url, data).success(function (result) {
			callback(null, result);
		}).error(function (err) {
			callback(err);
			console.error('appDatastore PUT Result: ', url, err);
		});
	},
	get: function get(obj, callback) {
		console.log('appDatastore: get ' + JSON.stringify(obj));
		if (typeof callback != 'function') return; // don't bother

		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}
		var tag;
		var id = '';
		var withDynamicData = false;
		if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == 'object') {
			if (typeof obj.tag == 'string') tag = obj.tag;else tag = '';
			if (typeof obj.id == 'string') id = obj.id;else id = '';
		} else if (typeof obj == 'string') tag = obj;

		if (typeof tag != 'string' || !tag) {
			return callback(new Error('tag is required for appData'), null);
		}

		//check if the dataDump record exist
		//if true : return cached record in callback ,continue with http call (without callback) ,update local cache , trigger on update
		//else : continue with http normally

		var isCallBackDone = false;
		var cachedData = null;
		//check local storage
		try {
			if (this.enableCache && typeof userDataDumpAPI !== 'undefined') {
				console.log('data cache: check for cache');
				cachedData = userDataDumpAPI.getData(this.appId, this.pluginId, this.instanceId, this.resolveTag(tag), obj.id);
				if (cachedData) {
					console.log('data cache: found cache');
					var result = cachedData;
					result.tag = obj.tag;
					result.obj = obj.obj;
					callback(null, result);
					isCallBackDone = true;
				}
			}
		} catch (ex) {
			debugger;
			console.error('dataDump error: ' + ex);
		}

		var requestTime = Date.now();
		this._httpGet(this.createReadUrl(tag, id, withDynamicData), {
			ds: this,
			isCallBackDone: isCallBackDone,
			obj: obj,
			userDataDumpAPI: window.userDataDumpAPI
		}, function (err, data) {
			var context = this;
			var responseTime = Date.now() - requestTime;
			console.log('appDatastore: response time ' + responseTime);
			if (err) {
				if (!context.isCallBackDone) callback(err);
			} else if (err == 404) {
				if (!context.isCallBackDone) callback(null, null);
			} else {
				try {
					if (data == null) {
						if (!context.isCallBackDone) callback(null, null);
					} else {
						if (context.ds.enableCache && typeof context.userDataDumpAPI !== 'undefined') context.userDataDumpAPI.setData(context.ds.appId, context.ds.pluginId, context.ds.instanceId, context.ds.resolveTag(context.obj.tag), context.obj.id, data);

						data.tag = context.obj.tag;
						if (!context.isCallBackDone) callback(null, data);else if (cachedData && cachedData.lastUpdated != data.lastUpdated) {
							console.log('data cache: send updated object onUpdate');
							context.ds.triggerOnUpdate(data);
						}
					}
				} catch (e) {
					if (!isCallBackDone) callback(e);
				}
			}
		});
		return this;
	},
	save: function save(obj, callback) {
		if (window.toast) window.toast('saving...');

		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}
		var tag = obj.tag,
		    data = obj.obj;

		if (typeof tag != 'string' || !tag) {
			return callback(new Error('tag is required for appData'), null);
		}

		if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) == 'object') {
			if (typeof angular != 'undefined') {
				data = angular.toJson({ data: data, userToken: this.writeKey, id: obj.id });
			} else {
				data = JSON.stringify({ data: data, userToken: this.writeKey, id: obj.id });
			}
		}

		var t = this;
		this._httpPost(this.createSaveUrl(tag), data, function (err, response) {
			if (err == 404) {
				if (window.toast) window.toast('404', 'danger');
				callback(null, null);
			} else if (err) {
				if (window.toast) window.toast('error saving', 'danger');
				callback(err);
			} else {
				var result = {
					id: obj.id,
					data: obj.obj,
					tag: tag
				};
				callback(null, result);
				t.triggerOnUpdate(result);
			}
		});
		return this;
	},
	insert: function insert(obj, callback) {
		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}
		var tag = obj.tag,
		    data = obj.obj,
		    checkDuplicate = obj.checkDuplicate;

		if (typeof tag != 'string' || !tag) {
			return callback(new Error('tag is required for appData'), null);
		}

		if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) == 'object') {
			data = { data: data, userToken: this.writeKey };

			if (checkDuplicate) data.checkDuplicate = checkDuplicate;
			data = JSON.stringify(data);
		}

		var t = this;
		this._httpPost(this.createWriteUrl(tag), data, function (err, response) {
			if (err == 404) callback(null, null);else if (err) callback(err);else {
				obj.id = response.id;
				var result = {
					id: response.id,
					data: obj.obj,
					tag: tag
				};
				callback(null, result);
				t.triggerOnUpdate(result);
			}
		});
		return this;
	},
	bulkInsert: function bulkInsert(obj, callback) {
		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}

		var tag = obj.tag,
		    data = obj.obj;

		if (typeof tag != 'string' || !tag) {
			return callback(new Error('tag is required for appData'), null);
		}

		if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) == 'object') {
			data = JSON.stringify({ data: data, userToken: this.writeKey, checkDuplicate: false });
		}

		var t = this;
		this._httpPost(this.createBulkInsertUrl(tag), data, function (err, response) {
			if (err == 404) callback(null, null);else if (err) callback(err);else {
				var result = {
					data: obj.obj,
					tag: tag
				};
				callback(null, result);
				t.triggerOnUpdate(result);
			}
		});
		return this;
	},
	update: function update(args, callback) {
		if (window.toast) window.toast('saving...');

		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}
		var tag = args.tag,
		    data = args.obj;

		if (typeof tag != 'string' || !tag) {
			return callback(new Error('tag is required for appData'), null);
		}

		if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) == 'object') {
			data = JSON.stringify({ id: args.id, data: data, userToken: this.writeKey });
		}

		var t = this;
		this._httpPut(this.createWriteUrl(tag), data, function (err, response) {
			if (err == 404) {
				if (window.toast) window.toast('404');
				callback(null, null);
			} else if (err) {
				if (window.toast) window.toast('error updating');
				callback(err);
			} else {
				response.record.tag = args.tag;
				callback(null, response.record);
				t.triggerOnUpdate(response.record);
			}
		});
		return this;
	},
	searchAndUpdate: function searchAndUpdate(args, callback) {
		if (window.toast) window.toast('saving...');

		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}
		var tag = args.tag,
		    data = args.obj;

		if (typeof tag != 'string' || !tag) {
			return callback(new Error('tag is required for appData'), null);
		}

		if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) == 'object') {
			data = JSON.stringify({ search: args.search, data: data, userToken: this.writeKey });
		}

		var t = this;
		this._httpPost(this.createSearchAndUpdateUrl(tag), data, function (err, response) {
			if (err == 404) {
				if (window.toast) window.toast('404');
				callback(null, null);
			} else if (err) {
				if (window.toast) window.toast('error updating');
				callback(err);
			} else {
				callback(null, response);
				t.triggerOnUpdate(response);
			}
		});
		return this;
	},
	delete: function _delete(args, callback) {
		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}
		var tag = args.tag;
		var data = JSON.stringify({ userToken: this.writeKey });

		if (typeof tag != 'string' || !tag) {
			return callback(new Error('tag is required for appData'), null);
		}

		var t = this;
		this._httpPost(this.createDeleteUrl(tag, args.id), data, function (err, response) {
			if (err == 404) callback(null, null);else if (err) callback(err);else {
				callback(null, response);
				t.triggerOnUpdate(args);
			}
		});
		return this;
	},
	search: function search(packet, callback) {
		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}
		var tag = packet.tag;
		var data = packet.obj;
		if (typeof callback != 'function') return; // dont bother

		if (typeof tag != 'string' || !tag) {
			return callback(new Error('tag is required for appData'), null);
		}

		if (typeof data == 'string') data = JSON.parse(data);

		data.userToken = this.writeKey;

		if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) == 'object') data = JSON.stringify(data);

		this._httpPost(this.createSearchUrl(tag), data, function (err, data) {
			if (err == 404) callback(null, null);else if (err) callback(err);else {
				/*try {*/

				if (data == null) callback(null, null);else if (typeof data == 'string') callback(null, bfUtils.tryParseJSON(data));else callback(null, data);
				/*}
                 catch (e) {
                 callback('cannot parse data: ' + data);
                 }*/
			}
		});
		return this;
	},

	dataDump: function dataDump(callback) {
		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}
		var t = this;
		this._httpget(this.createDataDumpUrl(), function (err, response) {
			if (err == 404) callback(null, null);else if (err) callback(err);else {
				/*try {*/
				callback(null, bfUtils.tryParseJSON(response));
				/*}
                 catch (e) {
                 callback('cannot parse data: ' + response);
                 }*/
				t.triggerOnUpdate(obj);
			}
		});
		return this;
	}
};
"use strict";

/**
 * Created by Daniel on 3/30/2015.
 * only allow reads without secure api key
 * cache data here so that we dont hit the server for the same info over and over
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function AnalyticsAPI(appId, pluginId, instanceId, liveMode, developerId) {
    this.analyticsHostUrl = siteConfig.endPoints.analyticsHost;
    if ((typeof appId === "undefined" ? "undefined" : _typeof(appId)) == "object") {
        var config = appId;
        this.appId = config.appId;
        this.pluginId = config.pluginId;
        this.instanceId = config.instanceId;
        this.liveMode = config.liveMode;
        this.developerId = config.developerId;
    } else {
        this.appId = appId;
        this.pluginId = pluginId;
        this.instanceId = instanceId;
        this.liveMode = liveMode;
        this.developerId = developerId;
    }
    this.source = window.siteConfig && window.siteConfig.scope === "app" ? "app" : "web";

    this.secondLevelEmailVerificationEnabled = false;
    if (window.whitelabelContext && window.whitelabelContext.whitelabelId) {
        this.whitelabelId = window.whitelabelContext.whitelabelId;
        if (window.whitelabelContext.selfProvSettings) this.secondLevelEmailVerificationEnabled = window.whitelabelContext.selfProvSettings.secondLevelEmailVerificationEnabled;
    }

    this._user = this._getUser();

    //trackInstall in app and in pwa
    if (window.appContext && window.appContext.liveMode && this.appId) {
        this._trackInstall();
    }
}

AnalyticsAPI.prototype = {
    _getIpInfo: function _getIpInfo(callback) {
        var _this = this;

        function _daysDiff(date1, date2) {
            //Get 1 day in milliseconds
            var one_day = 1000 * 60 * 60 * 24;

            // Convert both dates to milliseconds
            var date1_ms = date1.getTime();
            var date2_ms = date2.getTime();

            // Calculate the difference in milliseconds
            var difference_ms = Math.abs(date2_ms - date1_ms);

            // Convert back to days and return
            return Math.round(difference_ms / one_day);
        }

        function getNewIPInfo() {
            var request = new XMLHttpRequest();
            request.open('GET', window.siteConfig.endPoints.crmHost + '/ipinfo', true);
            request.onreadystatechange = function () {
                if (request.readyState == 4) {
                    if (request.status >= 200 && request.status < 400) {
                        if (request.responseText) {
                            var data = {};
                            try {
                                data = JSON.parse(request.responseText);
                            } catch (e) {
                                data = {};
                            }
                        }
                        saveGeoLocation(data, true);
                    }
                    AnalyticsAPI.IPInfoCalled = false;
                }
            };
            request.send(null);
        }

        function saveGeoLocation(data, isNewData) {
            if (isNewData) {
                var _localData = {
                    data: data,
                    lastSyncDate: new Date()
                };
                localStorage.setItem("analyticsUserIpInfo", JSON.stringify(_localData));
            }
        }

        var analyticsUserIpInfo = localStorage.getItem('analyticsUserIpInfo');
        if (analyticsUserIpInfo) {
            try {
                analyticsUserIpInfo = JSON.parse(analyticsUserIpInfo);
            } catch (err) {
                analyticsUserIpInfo = null;
            }

            var _today = new Date();
            var _lastSyncDate = analyticsUserIpInfo && analyticsUserIpInfo.lastSyncDate ? new Date(analyticsUserIpInfo.lastSyncDate) : new Date();
            if (_daysDiff(_lastSyncDate, _today) <= 30 && analyticsUserIpInfo && analyticsUserIpInfo.data) {
                if (callback) {
                    callback(analyticsUserIpInfo.data);
                }
            } else {
                if (callback) {
                    callback(analyticsUserIpInfo ? analyticsUserIpInfo.data : null);
                }
                if (!AnalyticsAPI.IPInfoCalled) {
                    AnalyticsAPI.IPInfoCalled = true;
                    getNewIPInfo();
                }
            }
        } else {
            if (callback) {
                callback();
            }
            if (!AnalyticsAPI.IPInfoCalled) {
                AnalyticsAPI.IPInfoCalled = true;
                getNewIPInfo();
            }
        }
    },
    _updateMetadata: function _updateMetadata(metadata) {
        var _loggedUser = null;
        var _userObject = localStorage.user || localStorage.AUTH_CURRENT_USER;
        if (_userObject) {
            try {
                _userObject = JSON.parse(_userObject);
                if (localStorage.user) {
                    _loggedUser = {
                        userId: _userObject.userToken,
                        username: _userObject.username,
                        email: _userObject.email || _userObject.username,
                        displayName: _userObject.displayName,
                        firstName: _userObject.firstName,
                        lastName: _userObject.lastName
                    };
                } else {
                    _loggedUser = {
                        userId: _userObject._id,
                        username: _userObject.username,
                        email: _userObject.email || _userObject.username,
                        displayName: _userObject.displayName,
                        firstName: _userObject.firstName,
                        lastName: _userObject.lastName
                    };
                }
            } catch (e) {
                console.warn("could not load analytics user");
                _loggedUser = null;
            }
        }
        metadata.user = _loggedUser;
        if (typeof push != "undefined" && push.deviceId != null) {
            metadata.deviceId = push.deviceId;
        }
    },
    _getUser: function _getUser() {
        if (localStorage.user) {
            try {
                var loggedInUser = JSON.parse(localStorage.user);
                if (loggedInUser) {
                    return {
                        userId: loggedInUser.username,
                        isValidEmail: this.secondLevelEmailVerificationEnabled ? loggedInUser.isValidEmail : 1
                    };
                }
            } catch (e) {
                console.warn("could not load analytics user");
                return this._getAnonymousUser();
            }
        } else if (localStorage.AUTH_CURRENT_USER) {
            try {
                var loggedInUser = JSON.parse(localStorage.AUTH_CURRENT_USER);
                if (loggedInUser) {
                    return { userId: loggedInUser.username };
                } else if (typeof push != "undefined" && push.deviceId != null) {
                    return { userId: push.deviceId };
                } else return this._getAnonymousUser();
            } catch (e) {
                console.warn("could not load analytics user");
                if (typeof push != "undefined" && push.deviceId != null) {
                    return { userId: push.deviceId };
                } else {
                    return this._getAnonymousUser();
                }
            }
        } else if (typeof push != "undefined" && push.deviceId != null) {
            return { userId: push.deviceId };
        } else {
            return this._getAnonymousUser();
        }
    },
    _getAnonymousUser: function _getAnonymousUser() {
        var localAnalyticsUser = localStorage.getItem('analyticsUser');
        var user;
        if (localAnalyticsUser) {
            try {
                user = JSON.parse(localAnalyticsUser);
            } catch (err) {
                console.log(err);
            }
        }
        if (!user) {
            var segmentClientId = this._getCookie("ajs_anonymous_id");
            if (segmentClientId) {
                user = { anonymousId: segmentClientId.replace('%22', '').replace('%22', '') }; // remove quotes embedded in id
            } else {
                var c = 1;
                var cuniq = function cuniq() {
                    var d = new Date(),
                        m = d.getMilliseconds() + "",
                        u = ++d + m + (++c === 10000 ? c = 1 : c);

                    return u;
                };
                user = { anonymousId: cuniq() };
                try {
                    localStorage.setItem('analyticsUser', JSON.stringify(user));
                } catch (err) {
                    console.log(err);
                }
            }
        }
        return user;
    },
    _getBrowserInfo: function _getBrowserInfo() {
        var browserInfo = {
            path: document.location.pathname,
            referrer: document.referrer,
            url: document.location.href,
            title: document.title,
            platform: window.device && window.device.platform ? window.device.platform.toLowerCase() : ''
        };
        return browserInfo;
    },
    _getCookie: function _getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }if (c.indexOf(name) == 0) return c.substring(name.length, c.length);
        }
        return "";
    },
    _trackInstall: function _trackInstall() {
        var installTrackedItem = localStorage.getItem('INSTALL_TRACKED');
        if (!installTrackedItem) {
            this.trackAction('app/installed', { appId: this.appId });
            localStorage.setItem('INSTALL_TRACKED', 'true');
        }
    },
    trackAction: function trackAction(actionName, properties, callback) {
        var _this = this;
        if (properties) {
            var originalProperties = this._getBrowserInfo();
            for (var originalPropertyName in originalProperties) {
                properties[originalPropertyName] = originalProperties[originalPropertyName]; // keep original properties
            }
        }
        var properties = properties || this._getBrowserInfo();
        properties.source = this.source;
        this._updateMetadata(properties);
        if (this.analyticsHostUrl && actionName) {
            var forceSync = properties ? properties.forceSync : false;
            if (properties) {
                delete properties.forceSync;
            }
            this._getIpInfo(function (userIpInfo) {
                if (userIpInfo && userIpInfo.country) {
                    properties.ipInfo = userIpInfo;
                }
                _this._httpPost(_this.analyticsHostUrl + "/event", {
                    type: 'action',
                    value: actionName,
                    metadata: properties,
                    context: {
                        whitelabelId: _this.whitelabelId,
                        appId: _this.appId,
                        pluginId: _this.pluginId,
                        instanceId: _this.instanceId,
                        liveMode: _this.liveMode,
                        developerId: _this.developerId ? _this.developerId : undefined
                    },
                    user: _this._user
                }, !forceSync, function (err, response) {
                    if (callback) {
                        callback();
                    }
                });
            });
        }
        return this;
    },
    trackView: function trackView(viewName, properties, callback) {
        var _this = this;
        if (properties) {
            var originalProperties = this._getBrowserInfo();
            for (var originalPropertyName in originalProperties) {
                properties[originalPropertyName] = originalProperties[originalPropertyName]; // keep original properties
            }
        }
        var properties = properties || this._getBrowserInfo();
        properties.source = this.source;
        this._updateMetadata(properties);
        if (this.analyticsHostUrl && viewName) {
            var ga = this._getCookie('_ga');
            if (ga) {
                var gaContext;
                // send GA on view events only
                gaContext = {};
                gaContext.clientId = ga.substr(6); // remove GAX.X. part from the universal id
            }

            this._getIpInfo(function (userIpInfo) {
                if (userIpInfo) {
                    properties.ipInfo = userIpInfo;
                }
                _this._httpPost(_this.analyticsHostUrl + "/event", {
                    type: 'view',
                    value: viewName,
                    metadata: properties,
                    context: {
                        whitelabelId: _this.whitelabelId,
                        appId: _this.appId,
                        pluginId: _this.pluginId,
                        instanceId: _this.instanceId,
                        liveMode: _this.liveMode,
                        developerId: _this.developerId ? _this.developerId : undefined
                    },
                    segmentContext: {
                        'Google Analytics': gaContext
                    },
                    user: _this._user
                }, true, function (err, response) {
                    if (callback) {
                        callback();
                    }
                });
            });
        }
        return this;
    },
    registerPluginEvent: function registerPluginEvent(event, callback) {
        if (window.siteConfig.scope != 'cp' && window.siteConfig.scope != 'sdk') {
            if (callback) callback("This method works only on Control Side", null);
            return;
        }
        if (!event) {
            if (callback) callback("invalid params", null);
            return;
        }
        if (!event.data) event.data = {};
        if (!event.options) event.options = {};

        var data = event.data;
        if (!data.key) {
            if (callback) callback("Missing event key", null);
            return;
        }

        if (!data.title) {
            if (callback) callback("Missing event title", null);
            return;
        }

        data._titleLowerCase = data.title.toLowerCase();

        var _noAccesskey = this.instanceId + "_pluginEvents";
        var datastore = new DatastoreAPI(this.appId, this.pluginId, _noAccesskey, this.liveMode);

        datastore.searchAndUpdate({
            tag: "events",
            obj: { $set: data },
            search: {
                key: data.key
            }
        }, function (err, result) {
            if (err == null && result && result.nModified == 0) {
                //no event found, then add
                datastore.insert({
                    tag: "events",
                    obj: data,
                    checkDuplicate: false
                }, function (err, result) {
                    //dispatch new register event
                    var onRegisterPluginEvent = new CustomEvent('pluginAnalyticsRegisterEvent', {
                        detail: {
                            data: event.data,
                            options: event.options
                        }
                    });
                    document.dispatchEvent(onRegisterPluginEvent);
                    //#

                    if (callback) callback(err, result);
                });
            } else {
                if (callback) callback(err, result);
            }
        });
    },
    unregisterPluginEvent: function unregisterPluginEvent(event, callback) {
        if (!event || !event.key) {
            if (callback) callback("Missing event key", null);
            return;
        }

        var _noAccesskey = this.instanceId + "_pluginEvents";
        var datastore = new DatastoreAPI(this.appId, this.pluginId, _noAccesskey, this.liveMode);

        datastore.search({
            tag: "events",
            obj: { filter: { "$json.key": event.key } }
        }, function (err, events) {
            if (!err && events && events.length > 0) {
                for (var i = 0; i < events.length; i++) {
                    datastore.delete({ tag: "events", id: events[i].id }, function (err, data) {
                        if (callback) callback(err, data);
                    });
                }
            } else {
                if (callback) callback(err, events);
            }
        });
    },
    getPluginEvents: function getPluginEvents(options, callback) {
        var _noAccesskey = this.instanceId + "_pluginEvents";
        var datastore = new DatastoreAPI(this.appId, this.pluginId, _noAccesskey, this.liveMode);
        if (!options) {
            options = {};
        }

        options.skip = options.skip || 0;
        options.limit = options.limit || 50;

        datastore.search({
            tag: "events",
            obj: options
        }, function (err, data) {
            if (callback) callback(err, data);
        });
    },
    setUsername: function setUsername(username) {
        this._user.userId = username;
        if (this._user.anonymousId) {
            this._user.updateIdentity = true; // next request to bridge anonymousId with userId
        }
    },
    setUserProperties: function setUserProperties(properties) {
        this._user.properties = properties;
        this._user.updateIdentity = true; // next request to update user properties
    },
    _httpPost: function _httpPost(url, data, isAsync, callback) {
        if (window.__$haultEvents) return;
        var xhr = new XMLHttpRequest();
        xhr.open('POST', url, isAsync);
        xhr.setRequestHeader('Content-type', 'application/JSON');
        var t = this;

        //fix nested userId issue
        function _getLastUserIdObject(user) {
            if (user && _typeof(user.userId) == "object") {
                return _getLastUserIdObject(user.userId);
            } else {
                return user;
            }
        }

        if (data.user && data.user.userId && data.user.userId.userId) {
            data.user = _getLastUserIdObject(data.user);
            //override local storage
            localStorage.setItem('analyticsUser', JSON.stringify(data.user));
        }
        //#
        xhr.onreadystatechange = function () {
            //Call a function when the state changes.
            if (xhr.readyState == 4) {
                if (xhr.status >= 200 && xhr.status < 400) {
                    if (t._user && t._user.userId && t._user.userId.userId) {
                        t._user = _getLastUserIdObject(t._user);
                    }

                    if (t._user.updateIdentity) {
                        delete t._user.updateIdentity;
                        delete t._user.properties;
                        delete t._user.anonymousId;
                    }
                    localStorage.setItem('analyticsUser', JSON.stringify(t._user));
                    callback(null, xhr.responseText);
                } else if (xhr.status == 0) window.__$haultEvents = true; //if analytics server is down then stop trying
                else callback(xhr.status);
            }
        };
        var dataString = null;
        try {
            dataString = JSON.stringify(data);
        } catch (err) {
            console.error('error stringifying analytics data', data.context, data.type + ":" + data.value, data.metadata, data, err);
        }
        if (dataString) {
            try {
                xhr.send(dataString);
            } catch (err) {
                if (err.code) {
                    console.error('error sending analytics', err, data, data.context, data.type + ":" + data.value, data.metadata, dataString, err);
                }
            }
        }
    }
};
"use strict";
/**
 * Created by Daniel on 3/30/2015.
 */

function AppearanceAPI(pluginAPI) {
    this.pluginAPI = pluginAPI;
}

AppearanceAPI.prototype = {
    getCSSFiles: function getCSSFiles(data, callback) {
        callback(null, ['https://bootswatch.com/cerulean/bootstrap.css']);
        return this;
    },
    autosizeContainer: function autosizeContainer(data, callback) {
        //debugger;
        this.autosizeContainerHandler(data.height);
        callback(null, null);
    },
    autosizeContainerHandler: function autosizeContainerHandler() {},
    setHeaderVisibility: function setHeaderVisibility(value) {
        var e = document.getElementById('pluginControlHeader');
        var tabs = document.getElementById('pluginControlHeaderTabs');
        if (e) {
            if (value) e.classList.remove('hidden');else e.classList.add('hidden');
        }
        if (tabs) {
            if (value) tabs.classList.remove('hidden');else tabs.classList.add('hidden');
        }
    },
    beforeUpdate: function beforeUpdate(callback) {
        document.addEventListener('appearanceBeforeUpdate', callback, false);
    },
    triggerBeforeUpdate: function triggerBeforeUpdate(data) {
        var beforeUpdateEvent = new CustomEvent('appearanceBeforeUpdate');
        document.dispatchEvent(beforeUpdateEvent);
    },
    onUpdate: function onUpdate(callback) {
        document.addEventListener('appearanceOnUpdate', callback, false);
    },
    triggerOnUpdate: function triggerOnUpdate(data) {
        var onUpdateEvent = new CustomEvent('appearanceOnUpdate');
        document.dispatchEvent(onUpdateEvent);
    },
    applyToScope: function applyToScope(element, property, value) {
        var scope = undefined;
        scope = angular.element(element).scope();
        scope[property] = value;
        if (!scope.$$phase) {
            scope.$apply();
        }
    }, getFooterMenu: function getFooterMenu(data, callback) {
        if (typeof data == 'function') {
            callback = data;
        }
        var footerMenu = localStorage.getItem('footerMenu');
        var result = {};
        if (footerMenu) {
            result = JSON.parse(footerMenu);
        }
        callback(null, result);
    },
    titlebar: {
        show: function show() {
            AppearanceAPI.prototype.titlebar.toggleVisibility(true);
        },
        hide: function hide() {
            AppearanceAPI.prototype.titlebar.toggleVisibility(false);
        },
        toggleVisibility: function toggleVisibility(visible) {
            var pluginIFrame = document.getElementsByClassName('pluginFrame');
            var isLauncher = pluginIFrame.length ? false : true;

            if (isLauncher) {
                var launcherPlugin = document.getElementById('launcherPlugin');
                AppearanceAPI.prototype.applyToScope(launcherPlugin, "disableAutomaticNavigationBar", true);
                AppearanceAPI.prototype.applyToScope(launcherPlugin, "showNavigationBar", visible);
            } else {
                for (var i = 0; i < pluginIFrame.length; i++) {
                    AppearanceAPI.prototype.applyToScope(pluginIFrame[i], "disableAutomaticNavigationBar", true);
                    AppearanceAPI.prototype.applyToScope(pluginIFrame[i], "showNavigationBar", visible);
                }
            }
        }
    },
    ready: function ready() {
        var pluginIFrame = document.getElementsByClassName('pluginFrame');
        var isLauncher = pluginIFrame.length ? false : true;

        if (isLauncher) {
            var launcherPlugin = document.getElementById('launcherPlugin');
            AppearanceAPI.prototype.applyToScope(launcherPlugin, "readyToShow", true);
        } else {
            for (var i = 0; i < pluginIFrame.length; i++) {
                AppearanceAPI.prototype.applyToScope(pluginIFrame[i], "readyToShow", true);
            }
        }
        if (window.spinner) {
            window.spinner.hide();
        }
    }
};
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Created by Daniel on 8/25/2015.
 */

function Track(title, url, image, album, artist) {
    this.title = title;
    this.url = url;
    this.image = image;
    this.album = album;
    this.artist = artist;
    this.startAt = 0;
    this.lastPosition = 0;
}

var audioPlayer = {
    _audio: null,
    _allowPlay: true,
    _interval: {
        time: 5000,
        id: null
    },
    get audio() {
        if (this._audio == null) {
            if (typeof Audio != "undefined") //Fix phantomJs when calling the screenshot API , The audio object will be undefined
                this._audio = new Audio();else this._audio = {};
        }

        return this._audio;
    },
    _currentTrack: null,
    settings: {
        autoPlayNext: false,
        loopPlaylist: false,
        autoJumpToLastPosition: false,
        shufflePlaylist: false,
        volume: 1
    },
    getSettings: function getSettings(d, callback) {
        callback(null, this.settings);
    },
    setSettings: function setSettings(settings) {
        console.log('setSettings called');

        if (!settings) return;
        if (this.audio && this.settings) this.audio.volume = this.settings.volume;
        angular.extend(this.settings, settings);
        this.save();
    },
    resetSettingsToDefault: function resetSettingsToDefault() {
        audioPlayer.settings = {
            autoPlayNext: false,
            loopPlaylist: false,
            autoJumpToLastPosition: false,
            shufflePlaylist: false,
            volume: 1
        };
    },
    isStream: function isStream() {
        //Streams have an infinite time
        return !isFinite(audioPlayer.audio.duration);
    },
    isAndroid: function isAndroid() {
        var isAndroid = false;

        if (window.device && window.device.platform && window.device.platform.toLowerCase() === "android") {
            isAndroid = true;
        }

        return isAndroid;
    },

    retryAllowed: function retryAllowed() {
        var allowRetry = true;

        //Stalled seems to be called even when audio is working on Android, and we don't support background audio for Android
        //Only retry streams
        if (!audioPlayer.isStream()) {
            allowRetry = false;
        }

        return allowRetry;
    },
    retryAudio: function retryAudio() {
        console.warn('retryAudio');

        if (audioPlayer._interval.id == null) {
            audioPlayer._interval.id = setInterval(function () {
                audioPlayer.resumePlay();
            }, audioPlayer._interval.time);
        }
    },
    cancelRetry: function cancelRetry() {
        if (audioPlayer._interval.id != null) {
            clearInterval(audioPlayer._interval.id);
            audioPlayer._interval.id = null;
        }
    },
    resumePlay: function resumePlay() {
        if (!audioPlayer.audio.paused) {
            console.warn('restart audio', new Date());
            audioPlayer._allowPlay = true;
            audioPlayer.play(audioPlayer._currentTrack);
        }
    },
    init: function init() {
        var t = this;
        try {
            if (this.audio && this.audio.addEventListener) {
                this.audio.addEventListener('ended', function () {
                    t.triggerOnEvent('audioEnded', t._currentTrack);
                    if (t.settings.autoPlayNext) t.next();
                });
            }

            //Audio stopped playing midstream, possibly due to network loss
            if (this.audio && this.audio.addEventListener) {
                this.audio.addEventListener('stalled', function () {
                    console.warn('audio stalled', new Date());

                    if (audioPlayer.retryAllowed()) {
                        audioPlayer.retryAudio();
                    }
                });
            }

            //Error, such as a fail to play
            if (this.audio && this.audio.addEventListener) {
                this.audio.addEventListener('error', function () {
                    console.warn('audio error', new Date());

                    if (audioPlayer.retryAllowed()) {
                        audioPlayer.retryAudio();
                    }
                });
            }

            if (this.audio && this.audio.addEventListener) {
                this.audio.addEventListener('playing', function () {
                    console.warn('playing', new Date());
                    audioPlayer.cancelRetry();
                });
            }
        } catch (e) {
            console.warn('error', e);
        }

        var lastSavedTime = 0;
        if (this.audio && this.audio.addEventListener) this.audio.addEventListener('timeupdate', function () {
            if (t._currentTrack) t._currentTrack.lastPosition = t.audio.currentTime;

            if (Math.abs(lastSavedTime - t.audio.currentTime) > 5) {
                t.save();
                lastSavedTime = t.audio.currentTime;
            }

            t.triggerOnEvent('timeUpdate', {
                currentTime: t.audio.currentTime, duration: t.audio.duration,
                buffer: {
                    start: t.audio.buffered.length ? t.audio.buffered.start(0) : 0,
                    end: t.audio.buffered.length ? t.audio.buffered.end(0) : 0
                }
            });
        });

        if (this.audio && this.audio.addEventListener) this.audio.addEventListener('error', function (e) {
            t.triggerOnEvent('error', e);
        });

        var appContext = window.appContext;

        if (appContext != null && typeof appContext != 'undefined' && typeof appContext.currentApp != "undefined" && typeof appContext.currentApp.appId != "undefined") {
            /// get previously saved data
            var json = window.localStorage.getItem('audioPlayer');

            if (json != '{}') {
                try {
                    var rec = JSON.parse(json);

                    t.settings = rec.settings;
                    t.playlist = rec.playlist;
                    t._currentTrack = rec._currentTrack;
                    t.audio.volume = t.settings.volume;
                } catch (e) {
                    console.warn('audioPlayer localStorage error', e);
                }
            }
        } else console.warn("no app found for audioPlayer");
    },
    getCurrentTrack: function getCurrentTrack(d, callback) {
        // maintain PluginAPI format
        if (callback) callback(this._currentTrack);
        return this._currentTrack;
    },
    onEvent: function onEvent(callback) {
        var handler = function handler(e) {
            if (callback) callback(e.detail);
        };
        document.addEventListener('audioPlayer.onEvent', handler, false);
        return {
            clear: function clear() {
                document.removeEventListener('audioPlayer.onEvent', handler, false);
            }
        };
    },
    triggerOnEvent: function triggerOnEvent(event, data) {
        var event = new CustomEvent('audioPlayer.onEvent', { 'detail': { event: event, data: data } });
        document.dispatchEvent(event);
    },
    _tmrSave: null,
    save: function save() {

        /// save date with a delay
        if (this._tmrSave) clearTimeout(this._tmrSave);
        this._tmrSave = setTimeout(function () {
            try {
                var t = {
                    settings: audioPlayer.settings,
                    playlist: audioPlayer.playlist,
                    _currentTrack: audioPlayer._currentTrack
                };

                window.localStorage.setItem('audioPlayer', JSON.stringify(t));
            } catch (err) {
                var message = err.message ? err.message : '';

                console.error('Error with JSON.stringify. ', message);
            }
        }, 500);
    },
    play: function play(track) {
        //if the track is empty or has changed, allow play
        if (!audioPlayer._currentTrack || track && audioPlayer._currentTrack.url != track.url) {
            audioPlayer._allowPlay = true;
        }

        if (!audioPlayer._allowPlay) {
            return;
        }

        var trackType = typeof track === "undefined" ? "undefined" : _typeof(track);
        if (trackType == "string") track = { url: track };else if (trackType == "number") {

            var lookup = this.playlist.tracks[track];
            if (lookup) {
                this.playlist.lastIndex = track;
                track = lookup;
                this.save();
            } else return;
        } else if (!track) {
            if (this.audio.paused) {
                this.audio.play();
                this.triggerOnEvent('resume', { track: this._currentTrack });
            }
            return;
        }

        this.audio.src = track.url;
        this.audio.preload = 'auto';
        this._currentTrack = track;

        //played	Returns a TimeRanges object representing the played parts of the audio/video
        console.warn('this.audio.play()', new Date());
        this.audio.play();
        this.triggerOnEvent('play', { track: track });

        if (this.settings && this.settings.autoJumpToLastPosition && track.lastPosition) this.skip(track.lastPosition);

        if (track.startAt) this.skip(track.startAt);

        audioPlayer._allowPlay = false;
    },
    skip: function skip(value) {
        if (!this.audio) return;

        if (this.audio.currentTime + value < 0) this.audio.currentTime = 0;else if (this.audio.currentTime + value > this.audio.duration) this.audio.currentTime = this.audio.duration;else this.audio.currentTime += value;
        this.triggerOnEvent('skip', value);
    },
    pause: function pause() {
        audioPlayer.audio.pause();
        audioPlayer._allowPlay = true;
        audioPlayer.triggerOnEvent('pause');
    },
    isPaused: function isPaused(args, callback) {
        if (callback) callback(null, audioPlayer.audio.paused);
    },
    loopTrack: function loopTrack(val) {
        if (audioPlayer.audio) audioPlayer.audio.loop = val;
    },
    next: function next() {
        var track;
        if (audioPlayer.settings.shufflePlaylist) audioPlayer.playlist.lastIndex = Math.round((audioPlayer.playlist.tracks.length - 1) * Math.random());else audioPlayer.playlist.lastIndex++;

        if (audioPlayer.playlist.lastIndex >= audioPlayer.playlist.tracks.length) {
            if (audioPlayer.settings.loopPlaylist && audioPlayer.playlist.tracks.length) audioPlayer.playlist.lastIndex = 0;else {
                audioPlayer.playlist.lastIndex = audioPlayer.playlist.tracks.length - 1;
                return null;
            }
        }

        track = audioPlayer.playlist.tracks[audioPlayer.playlist.lastIndex];

        audioPlayer.save();

        audioPlayer.triggerOnEvent('next', { index: audioPlayer.playlist.lastIndex, track: track });
        if (track) audioPlayer.play(track);
        return track;
    },
    previous: function previous() {
        var track;
        if (audioPlayer.settings.shufflePlaylist) audioPlayer.playlist.lastIndex = Math.round((audioPlayer.playlist.tracks.length - 1) * Math.random());else audioPlayer.playlist.lastIndex--;

        if (audioPlayer.playlist.lastIndex < 0) {
            if (audioPlayer.settings.loopPlaylist && audioPlayer.playlist.tracks.length) audioPlayer.playlist.lastIndex = audioPlayer.playlist.tracks.length - 1;else {
                audioPlayer.playlist.lastIndex = 0;
                return null;
            }
        }

        track = audioPlayer.playlist.tracks[audioPlayer.playlist.lastIndex];

        audioPlayer.save();

        audioPlayer.triggerOnEvent('previous', { index: audioPlayer.playlist.lastIndex, track: track });
        if (track) audioPlayer.play(track);
        return track;
    },
    removeFromPlaylist: function removeFromPlaylist(index) {
        if (index < 0 || index >= audioPlayer.playlist.tracks.length) return;

        var track = audioPlayer.playlist.tracks.splice(index, 1);

        if (index == audioPlayer.playlist.lastIndex) audioPlayer.playlist.lastIndex = -1;else if (index < audioPlayer.playlist.lastIndex) audioPlayer.playlist.lastIndex--;

        audioPlayer.triggerOnEvent('removeFromPlaylist', { index: index, track: track, newPlaylist: audioPlayer.playlist });
    },
    addToPlaylist: function addToPlaylist(track) {
        audioPlayer.playlist.tracks.push(track);
        audioPlayer.save();

        audioPlayer.triggerOnEvent('addToPlaylist', { track: track, newPlaylist: audioPlayer.playlist });
    },
    setTime: function setTime(sec) {
        audioPlayer.audio.currentTime = sec;
        audioPlayer._currentTrack.lastPosition = audioPlayer.audio.currentTime;
        audioPlayer.save();
        audioPlayer.triggerOnEvent('timeUpdate', {
            currentTime: audioPlayer.audio.currentTime, duration: audioPlayer.audio.duration,
            buffer: {
                start: audioPlayer.audio.buffered.length ? audioPlayer.audio.buffered.start(0) : 0,
                end: audioPlayer.audio.buffered.length ? audioPlayer.audio.buffered.end(0) : 0
            }
        });
    },
    setVolume: function setVolume(percent) {
        if (percent < 0) percent = 0;else if (percent > 1 && percent <= 100) percent = percent / 100;

        if (audioPlayer.settings) audioPlayer.settings.volume = percent;
        if (audioPlayer.audio) audioPlayer.audio.volume = percent;
        audioPlayer.triggerOnEvent('volumeChange', { volume: percent });
        audioPlayer.save();
    },
    playlist: {
        tracks: [],
        lastIndex: -1
    },
    getPlaylist: function getPlaylist(d, callback) {
        callback(null, audioPlayer.playlist);
    }

};

if (typeof PluginAPI != "undefined" && !PluginAPI.prototype.mediaAPI) PluginAPI.prototype.mediaAPI = {
    audioPlayer: window.audioPlayer
};

window.addEventListener('load', function () {
    audioPlayer.init();

    if (typeof cordova !== 'undefined' && cordova.plugins && cordova.plugins.backgroundMode) {
        cordova.plugins.backgroundMode.setDefaults({
            text: 'Background mode enabled'
        });

        cordova.plugins.backgroundMode.enable();
        if (audioPlayer.isAndroid()) cordova.plugins.backgroundMode.disableWebViewOptimizations();
    }
});
"use strict";
/**
 * Created by Ayman on 7/30/2015.
 */

function NotificationsAPI(context) {
	this.context = context;
}

NotificationsAPI.prototype = {
	/*options:{
           title:
           message:
           okButton:{text:,type:}
 }*/
	alert: function (_alert) {
		function alert(_x, _x2) {
			return _alert.apply(this, arguments);
		}

		alert.toString = function () {
			return _alert.toString();
		};

		return alert;
	}(function (options, callback) {
		if (!options) {
			options = {};
		}
		if (!options.message) {
			callback("invalid parameter, messing message");
			return;
		}
		if (!options.okButton) {
			options.okButton = { text: "OK" };
		}
		if (!options.okButton.text) {
			options.okButton.text = "OK";
		}
		if (window.device && window.device.platform != "web" && typeof navigator != 'undefined' && navigator.notification && navigator.notification.alert) {
			navigator.notification.alert(options.message, // message
			callback, // callback
			options.title, // title
			options.okButton.text // buttonName
			);
		} else {
			alert(options.message);
			if (callback) callback();
		}
	}),

	/*options:{
               title:
               message:
               confirmButton:{text:,type:},
               cancelButton:{text:,type:}
 }*/
	confirm: function (_confirm) {
		function confirm(_x3, _x4) {
			return _confirm.apply(this, arguments);
		}

		confirm.toString = function () {
			return _confirm.toString();
		};

		return confirm;
	}(function (options, callback) {
		if (!options) {
			options = {};
		}
		if (!options.message) {
			callback("invalid parameter, missing message", null);
			return;
		}

		if (!options.confirmButton) {
			options.confirmButton = { text: "Confirm" };
		}
		if (!options.confirmButton.text) {
			options.confirmButton.text = "Confirm";
		}
		if (!options.cancelButton) {
			options.cancelButton = { text: "Cancel" };
		}
		if (!options.cancelButton.text) {
			options.cancelButton.text = "Cancel";
		}
		options.buttonLabels = [options.confirmButton.text, options.cancelButton.text];

		if (window.device && window.device.platform != "web" && typeof navigator != 'undefined' && navigator.notification && navigator.notification.confirm) {
			navigator.notification.confirm(options.message, // message
			callback, // callback to invoke with index of button pressed
			options.title, // title
			options.buttonLabels // buttonLabels
			);
		} else {
			var val = confirm(options.message);
			if (callback) callback(val);
		}
	}),

	prompt: function (_prompt) {
		function prompt(_x5, _x6) {
			return _prompt.apply(this, arguments);
		}

		prompt.toString = function () {
			return _prompt.toString();
		};

		return prompt;
	}(function (options, callback) {
		if (window.device && window.device.platform != "web" && typeof navigator != 'undefined' && navigator.notification && navigator.notification.prompt) {
			navigator.notification.prompt(options.message, // message
			callback, // callback to invoke
			options.title, // title
			options.buttonLabels, // buttonLabels
			options.defaultText // defaultText
			);
		} else {
			var val = prompt(options.message);
			if (callback) callback(val);
		}
	}),

	beep: function beep(options, callback) {
		console.log("calling NotificationsAPI.beep ...");
		if (window.device && window.device.platform != "web" && typeof navigator != 'undefined' && navigator.notification && navigator.notification.beep) {
			navigator.notification.beep(options.times);
			if (callback) callback();
		} else {
			if (callback) callback();
		}
	},

	vibrate: function vibrate(options, callback) {
		console.log("calling NotificationsAPI.vibrate ...");
		if (window.device && window.device.platform != "web" && typeof navigator != 'undefined' && navigator.notification && navigator.notification.vibrate) {
			navigator.notification.vibrate(options.milliseconds);
			if (callback) callback();
		} else {
			if (callback) callback();
		}
	}
};
"use strict";

/**
 * Created by Daniel on 3/30/2015.
 * only allow reads without secure api key
 * cache data here so that we dont hit the server for the same info over and over
 */
function appAPI(context) {
    this.appId = context.appId;
    this.liveMode = context.liveMode;
    this.appHost = context.endPoints.appHost;
    if (typeof CustomEvent == "undefined") console.warn("Browser doesnt support CustomEvent");
};

appAPI.prototype = {
    getPluginInstances: function getPluginInstances(data, callback) {
        var ds = new DatastoreAPI(this.appId, "pluginInstances", 1, this.liveMode, null);
        if (!data) data = {};

        //if(!data.pageSize)           data.pageSize = 10;

        if (!data.pageIndex) data.pageIndex = 1;

        var packet = {
            obj: {
                filter: { "$json.title": { "$regex": data.title != null ? data.title : '' } },
                page: data.pageIndex - 1,
                pageSize: data.pageSize // the plus one is to check if there are any more
                , withDynamicData: true,
                recordCount: true
            },
            tag: ''
        };

        ds.search(packet, function (err, results) {

            if (!err) {
                callback(null, { data: results.result, totals: results.totalRecord });
            }
        });
    }
};
'use strict';

if (typeof ActionItemsAPI == 'undefined') {

    window.ActionItemsAPI = function (context) {
        this.templateUrl = 'pages/share/actionBuilder.html';
        this.listTemplateUrl = window._appRoot + 'pages/templates/actionItemsListDialog.html';
        this.controller = 'actionItemsCtrl';
        this.context = context;
        this.init();
    };
}

ActionItemsAPI.prototype.init = function () {};

ActionItemsAPI.prototype.list = function (data, callback) {
    var openDialogOptions = {
        templateUrl: this.listTemplateUrl,
        controller: 'actionItemsListDialogCtrl',
        size: 'lg',
        data: data
    };

    window.openDialog(openDialogOptions, function (result) {
        if (callback) callback(null, result);
    });
};
ActionItemsAPI.prototype.openWebLink = function (url, openIn, callback) {
    if (url) {
        var isInAppBrowser = openIn === '_blank';
        var windowReference = window.open(url, openIn, 'location=no');
        var timeout = void 0;

        //If the in app pop-up fails, fall back the system's browser
        if (isInAppBrowser) {
            timeout = setTimeout(function () {
                ActionItemsAPI.prototype.openWebLink(url, '_system', callback);
                windowReference && windowReference.close();
            }, 1000);
        }

        //If this event fires then the window is being opened
        windowReference && windowReference.addEventListener('loadstart', function () {
            if (timeout) clearTimeout(timeout);
        });

        if (callback) {
            callback(!windowReference ? "failed to open window" : null);
        }

        if (!windowReference) {
            ActionItemsAPI.prototype.popUpCtrlScope.show(url);
        }
    }
};

ActionItemsAPI.prototype.sendEmail = function (email, subject, body) {
    var url = "mailto:" + (email != null && email != '' ? email : '') + "?" + (subject != null && subject != '' ? 'subject=' + subject : '') + "&" + (body != null && body != '' ? 'body=' + body : '');
    window.open(url, "_system");
};

ActionItemsAPI.prototype.navigateToAddress = function (lat, lng) {
    if (lat && lng) {
        var url = "https://maps.google.com/?q=";
        if (window.device && window.device.platform != null) {
            if (window.device.platform.toLowerCase() == "android") {
                url = 'geo:?q=';
            } else if (window.device.platform.toLowerCase() == "ios") {
                url = 'maps://maps.apple.com?q=';
            }
        }

        window.open(url + lat + "," + lng, '_system', 'location=no,menubar=no,titlebar=no,toolbar=no');
    }
};

ActionItemsAPI.prototype.callNumber = function (phoneNumber) {
    if (phoneNumber) {
        phoneNumber = phoneNumber.replace(/ /, '');
        window.open('tel:' + phoneNumber + '', '_system', 'location=no,menubar=no,titlebar=no,toolbar=no');
    }
};

ActionItemsAPI.prototype.sendSms = function (phoneNumber) {
    if (phoneNumber) {
        phoneNumber = phoneNumber.replace(/ /, '');

        if (navigator.platform.indexOf("Android") != -1 || navigator.platform.indexOf("Linux") != -1 || navigator.platform == null) {
            var url = "sms:" + phoneNumber;
            window.open(url, "_system");
        } else if (navigator.platform.indexOf("iPhone") != -1 || navigator.platform.indexOf("iPad") != -1) {
            var url = "sms:" + phoneNumber;
            window.open(url, "_system");
        } else {
            console.error("This action can't be used on browser , it should be used on actual device");
        }
    }
};

ActionItemsAPI.prototype.linkToAppContent = function (instanceId, params) {
    var dsPluginInstance = new DatastoreAPI(appContext.currentApp.appId, "pluginInstances", 1, appContext.liveMode);

    var options = {};
    options.obj = {
        filter: { "$json.instanceId": instanceId },
        pageSize: 1,
        withDynamicData: true
    };
    dsPluginInstance.search(options, function (err, result) {
        if (result && result.length) {
            var instanceId = result[0].data.instanceId;
            var token = result[0].data._buildfire.pluginType.result[0].token;
            var folderName = result[0].data._buildfire.pluginType.result[0].folderName;
            var title = result[0].data.title;
            var pluginAPI = window.appContext.currentPlugin ? window.appContext.currentPlugin.pluginAPI : window.postMaster.launcherPluginAPI;
            if (pluginAPI) {
                pluginAPI.navigation.navigateTo({
                    pluginId: token,
                    instanceId: instanceId,
                    title: title,
                    folderName: folderName,
                    pushToHistory: true,
                    queryString: params ? params.queryString : null
                }, null);
            } else console.warn("Plugin API is empty");
        }
    });
};

ActionItemsAPI.prototype.navigateToPage = function (pageName, options) {
    if (!options) {
        options = {};
    }

    if (!pageName) {
        console.error("Action Items", 'navigateToPage', 'Please specify Page Name!');
        return;
    }

    if (pageName == "login") {
        if (window.authAPI && window.authAPI.login) {
            window.authAPI.login();
        }
        return;
    }

    if (pageName == "appSearch" && window.appContext.currentApp.config.type != "enterprise") {
        console.info("Action Items", "Search page only available for Enterprise Plan");
        return;
    }

    if (options.queryString) {
        var esc = encodeURIComponent;
        var queryString = Object.keys(options.queryString).map(function (k) {
            return esc(k) + '=' + esc(options.queryString[k]);
        }).join('&');

        pageName = pageName + "?" + queryString;
    }

    window.location.hash = pageName;
};

ActionItemsAPI.prototype.purchase = function (purchaseType, prodObj, successMessage, errorMessage, navigateToPluginInstanceId, callback) {
    if (!bfUtils.isMobileDevice) {
        // alert("This action can't be used on browser , it should be used on actual device");
        return;
    }
    if (typeof inAppPurchaseAPI == 'undefined') {
        console.error('inAppPurchaseAPI is undefined');
        return;
    }
    var purchaseResultCallback = function purchaseResultCallback(err, purchase) {
        if (!err) {
            if (purchase && purchase.isApproved) {
                if (!bfUtils.isIOS) {
                    var options = {
                        data: {
                            title: ' ',
                            body: successMessage,
                            disableCancel: true
                        }
                    };

                    window.openDialog(options, function () {});

                    if (navigateToPluginInstanceId) {
                        ActionItemsAPI.prototype.linkToAppContent(navigateToPluginInstanceId);
                    }
                }
            }
        } else {
            var options = {
                data: {
                    title: ' ',
                    body: errorMessage,
                    disableCancel: true
                }
            };

            window.openDialog(options, function () {});
        }
        callback(err, purchase);
    };
    inAppPurchaseAPI.checkAccess(prodObj, function (err, product) {
        if (err) {
            console.error("error while checking product", err);
        }
        if (product && product.owned) {
            if (navigateToPluginInstanceId) {
                ActionItemsAPI.prototype.linkToAppContent(navigateToPluginInstanceId);
            }
            callback(null, { product: product, isApproved: true });
        } else {
            var productId = prodObj.productId;
            if (prodObj.purchaseType === "subscriptions" && prodObj.subscription) {
                productId = prodObj.subscription.subscriptionId;
            }
            inAppPurchaseAPI.purchase({ productId: productId, purchaseType: purchaseType }, purchaseResultCallback);
        }
    });
};

ActionItemsAPI.prototype.execute = function (actionItem, callback) {

    var actionSupportsCallback = false;
    switch (actionItem.action) {
        case 'linkToApp':
            this.linkToAppContent(actionItem.instanceId, { queryString: actionItem.queryString });
            break;
        case 'linkToWeb':
            actionSupportsCallback = true;
            this.openWebLink(actionItem.url, actionItem.openIn, callback);
            break;
        case 'sendEmail':
            this.sendEmail(actionItem.email, actionItem.subject, actionItem.body);
            break;
        case 'callNumber':
            this.callNumber(actionItem.phoneNumber);
            break;
        case 'sendSms':
            this.sendSms(actionItem.phoneNumber);
            break;
        case 'navigateToAddress':
            this.navigateToAddress(actionItem.lat, actionItem.lng);
            break;
        case 'navigateToAppSettings':
            this.navigateToPage('appSettings');
            break;
        case 'navigateToNotifications':
            this.navigateToPage("pushGroups");
            break;
        case 'navigateToBookmarks':
            this.navigateToPage("bookmarks");
            break;
        case 'navigateToSearch':
            var options = {};
            if (actionItem.searchAppValue) {
                options.queryString = {
                    searchTerm: actionItem.searchAppValue
                };
            }

            this.navigateToPage("appSearch", options);
            break;
        case 'navigateToLogin':
            this.navigateToPage("login");
            break;
        case 'navigateToNotes':
            window.notesAPI.openDialog();
            break;
        case 'linkToSocialGoogle':
            this.openWebLink(actionItem.url, "_system");
            break;
        case 'linkToSocialFacebook':
            this.openWebLink(actionItem.url, "_system");
            break;
        case 'linkToSocialInstagram':
            this.openWebLink(actionItem.url, "_system");
            break;
        case 'linkToSocialTwitter':
            this.openWebLink(actionItem.url, "_system");
            break;
        case 'linkToSocialLinkedIn':
            this.openWebLink(actionItem.url, "_system");
            break;
        case 'purchase':
            actionSupportsCallback = true;
            var prodObj = {
                productId: actionItem.productId,
                subscriptions: actionItem.subscriptions,
                subscription: actionItem.subscription,
                purchaseType: actionItem.purchaseType
            };
            this.purchase(actionItem.purchaseType, prodObj, actionItem.successMessage, actionItem.errorMessage, actionItem.instanceId, callback);
            break;
    }
    if (!actionSupportsCallback) {
        callback(null, true);
    }
};

if (typeof $app != "undefined") $app.controller('actionItemsListDialogCtrl', ['$scope', '$data', '$dialog', function ($scope, $data, $dialog) {
    $scope.actionItems = $data.actionItems;
    $scope.executeItem = true;
    $scope.close = function () {
        $dialog.close(null);
    };
    if ($data.options && $data.options.executeItem) $scope.executeItem = $data.options.executeItem;
    $scope.openActionItem = function (actionItem) {
        if ($scope.executeItem) {
            var pluginAPI = window.appContext.currentPlugin ? window.appContext.currentPlugin.pluginAPI : window.postMaster.launcherPluginAPI;
            pluginAPI.actionItems.execute(actionItem, function (err, result) {
                $dialog.close(actionItem);
            });
        } else $dialog.close(actionItem);
    };
}]);
'use strict';

function PluginInstanceAPI(context) {
    this.templateUrl = 'pages/plugins/pluginInstanceDialog/pluginInstanceDialog.html';
    this.controller = 'pluginInstanceDialog';
    this.appId = context.appId;
    this.liveMode = context.liveMode;
    this.appHost = window.siteConfig.endPoints.appHost;
    var dContext = JSON.parse(JSON.stringify(context)); // make a copy
    dContext.pluginId = "pluginInstances";
    dContext.instanceId = 1;
    this.ds = new DatastoreAPI(dContext);
};

PluginInstanceAPI.prototype = {
    showDialog: function showDialog(data, callback) {

        if (!window.openDialog) {
            console.error("openDialog isnt defined");
            return;
        }

        var openDialogOptions = {
            templateUrl: this.templateUrl,
            controller: this.controller,
            size: 'lg',
            data: data
        };

        window.openDialog(openDialogOptions, function (result) {
            if (callback) callback(null, result);
        });
    },
    get: function get(instanceId, callback) {
        /*var params = {};
         if (ids instanceof Array) {
         params.ids = ids.join(", ")
         } else
         params.ids = ids;
          var url = this._createReadUrl();
          this._httpGet(url, params, function (err, result) {
         if (err)
         callback(err, null);
         else
         callback(null, result);
         });*/

        var options = {};
        options.obj = {
            filter: { "$json.instanceId": instanceId },
            pageSize: 1,
            withDynamicData: true
        };

        this.ds.search(options, function (err, result) {
            if (!err) {
                if (result && result.length) {
                    callback(null, result[0].data);
                } else callback(null);
            } else callback(err, null);
        });
    },
    _createReadUrl: function _createReadUrl() {
        return this.appHost + "/api/appPluginInstances/getByIds/" + this.appId;
    },
    _httpGet: function _httpGet(url, params, callback) {
        bfUtils.http.get(url, { params: params }).success(function (data) {
            callback(null, data);
        }).error(function (err) {
            callback(err);
        });
    },
    search: function search(options, callback) {

        var filter;
        if (options.title) filter = { "$json.title": { "$regex": options.title, "$options": "-i" } };
        var packet = {
            obj: {
                filter: filter,
                page: options.pageIndex,
                pageSize: options.pageSize // the plus one is to check if there are any more
                , withDynamicData: true,
                recordCount: true
            },
            tag: ''
        };

        this.ds.search(packet, callback);
    }
};
"use strict";

var deviceAPI = {
    calendar: {
        /*
        * event {
        * title
        * ,location
        * ,notes
        * ,startDate
        * ,endDate
        * ,options: {
        *    ,firstReminderMinutes = 120; // default is 60, pass in null for no reminder (alarm)
             ,secondReminderMinutes = 5;
             ,recurrence = "monthly"; // supported are: daily, weekly, monthly, yearly
             ,recurrenceEndDate = new Date(2015,6,1,0,0,0,0,0); // leave null to add events into infinity and beyond
        *   }
        * }
        * */
        addEvent: function addEvent(event, callback) {
            var cal;

            if (window.plugins && window.plugins.calendar) cal = window.plugins.calendar;

            if (!cal) {
                console.warn("cannot complete action add event to calendar. so fake it");
                if (window.location.protocol.indexOf('http') >= 0) alert('Adding to calendar requires native app.');else console.error('Calendar feature not installed');
                return;
            }

            if (!(event.startDate instanceof Date)) event.startDate = new Date(event.startDate); // beware: month 0 = january, 11 = december

            if (!(event.endDate instanceof Date)) event.endDate = new Date(event.endDate); // beware: month 0 = january, 11 = december

            var success = function success(message) {
                callback(null, message);
            };
            var error = function error(message) {
                callback(message);
            };

            /*
            var calOptions = cal.getCalendarOptions(); // grab the defaults
            calOptions.firstReminderMinutes = 120; // default is 60, pass in null for no reminder (alarm)
            calOptions.secondReminderMinutes = 5;
            calOptions.recurrence = "daily"; // supported are: daily, weekly, monthly, yearly
            calOptions.recurrenceEndDate = new Date(2025, 4, 15, 19, 30, 0, 0, 0); //
            */

            if (event.options) {
                var calOptions;
                calOptions = cal.getCalendarOptions();
                calOptions.firstReminderMinutes = event.options.firstReminderMinutes || calOptions.firstReminderMinutes;
                calOptions.secondReminderMinutes = event.options.secondReminderMinutes || calOptions.secondReminderMinutes;
                calOptions.recurrence = event.options.recurrence || calOptions.recurrence;
                if (event.options.recurrenceEndDate) calOptions.recurrenceEndDate = new Date(event.options.recurrenceEndDate);
                cal.createEventWithOptions(event.title, event.location, event.notes, event.startDate, event.endDate, calOptions, success, error);
            } else {

                cal.createEvent(event.title, event.location, event.notes, event.startDate, event.endDate, success, error);
            }
        }
    },
    share: function share(messageObj, callback) {
        if (window.plugins && window.plugins.socialsharing) {
            window.plugins.socialsharing.share(messageObj.text, messageObj.subject, messageObj.image, messageObj.link);
            callback(null, true);
        } else {
            console.warn("device sharing plugin not found. defaulting to email sending");
            window.location = 'mailto:?subject=' + encodeURIComponent(messageObj.subject) + '&body=' + encodeURIComponent(messageObj.text + ' ' + messageObj.link);
            callback(null, true);
        }
    },
    onAppBackgrounded: function onAppBackgrounded(callback) {
        document.addEventListener('deviceAppBackgrounded', callback, false);
    },
    onAppResumed: function onAppResumed(callback) {
        document.addEventListener('deviceAppResumed', callback, false);
    }
};
"use strict";
/**
 * Created by Daniel on 3/30/2015.
 * only allow reads without secure api key
 * cache data here so that we dont hit the server for the same info over and over
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function HistoryAPI(appId, pluginId, instanceId, liveMode) {
    if ((typeof appId === "undefined" ? "undefined" : _typeof(appId)) == "object") {
        var config = appId;
        this.appId = config.appId;
        this.pluginId = config.pluginId;
        this.instanceId = config.instanceId;
        this.liveMode = config.liveMode;
    } else {
        this.appId = appId;
        this.pluginId = pluginId;
        this.instanceId = instanceId;
        this.liveMode = liveMode;
    }
}

HistoryAPI.prototype = {
    historyItems: [],
    push: function push(pushedItem, callback) {
        if (typeof emulatorSync === 'undefined') {
            // we are on the correct side
            if (pushedItem.source != "plugin") {
                // remove all breadcrumbs added by the current plugin when pushing history for a new plugin
                var pluginBreadcrumbIndex = -1;
                if (this.historyItems.length > 1) {
                    for (var i = 1; i < this.historyItems.length; i++) {
                        if (this.historyItems[i].source == "plugin") {
                            // keep launcher own breadcrumbs, remove only other plugin breadcrumbs
                            if (this.historyItems[i - 1].source == "control") {
                                pluginBreadcrumbIndex = i;
                                break;
                            }
                        }
                    }
                    if (pluginBreadcrumbIndex >= 0) {
                        this.historyItems.splice(pluginBreadcrumbIndex);
                    }
                }
            }
            pushedItem.uid = new Date().getTime();
            this.historyItems.push(pushedItem);
            var onPushEvent = new CustomEvent('historyOnPush', { detail: { pushedItem: pushedItem } });
            document.dispatchEvent(onPushEvent);
            var onUpdateEvent = new CustomEvent('historyOnUpdate', { detail: { historyItems: this.historyItems } });
            document.dispatchEvent(onUpdateEvent);
        } else {
            // no history items here. delegate call to the app side
            var packet = new Packet(null, 'history.pushAppHistory', pushedItem);
            emulatorSync.sendMessage(packet);
        }

        if (callback) {
            callback(null, true);
        }
        return this;
    },
    get: function get(options, callback) {
        if (options && options.pluginBreadcrumbsOnly) {
            var pluginBreadcrumbs = [];
            for (var i = 0; i < this.historyItems.length; i++) {
                if (this.historyItems[i].source == "plugin") {
                    pluginBreadcrumbs.push(this.historyItems[i]);
                }
            }
            callback(null, pluginBreadcrumbs);
        } else {
            callback(null, this.historyItems);
        }
        return this;
    },
    getNext: function getNext(breadcrumb) {
        var nextBreadcrumb = null;
        if (this.historyItems) {
            for (var i = 0; i < this.historyItems.length; i++) {
                if (this.historyItems[i] == breadcrumb || this.historyItems[i].uid == breadcrumb.uid) {
                    if (i < this.historyItems.length) {
                        nextBreadcrumb = this.historyItems[i + 1];
                    }
                    break;
                }
            }
        }
        return nextBreadcrumb;
    },
    pop: function pop(breadcrumb, callback) {
        if (typeof emulatorSync === 'undefined') {
            // we are on the correct side
            if (!breadcrumb && this.historyItems) {
                if (this.historyItems.length > 1) {
                    var lastBreadcrumb = this.historyItems[this.historyItems.length - 1];
                    if (lastBreadcrumb && lastBreadcrumb.source == "plugin") {
                        breadcrumb = this.historyItems[this.historyItems.length - 2]; // pop to the previous one
                    }
                } else {
                    if (this.historyItems[0] && this.historyItems[0].source == "plugin") {
                        breadcrumb = this.historyItems[0];
                    }
                }
            }
            if (breadcrumb) {
                var breadcrumbIndex = -1;
                var isPluginTopBreadcrumb = false; // if this is the top level breadcrumb within the same plugin instance
                for (var i = 0; i < this.historyItems.length; i++) {
                    if (this.historyItems[i] == breadcrumb || this.historyItems[i].uid == breadcrumb.uid) {
                        breadcrumbIndex = i;
                        if (i + 1 < this.historyItems.length && this.historyItems[i + 1].source == "plugin") {
                            isPluginTopBreadcrumb = true;
                        }
                        break;
                    }
                }
                if (breadcrumbIndex >= 0 && breadcrumbIndex <= this.historyItems.length) {
                    this.historyItems.splice(breadcrumbIndex + 1);
                }
                var onPopEvent = new CustomEvent('historyOnPop', { detail: { poppedItem: breadcrumb } });
                document.dispatchEvent(onPopEvent);
                var onUpdateEvent = new CustomEvent('historyOnUpdate', { detail: { historyItems: this.historyItems } });
                document.dispatchEvent(onUpdateEvent);
                if ((isPluginTopBreadcrumb || breadcrumb.source == "plugin") && postMaster) {
                    var packet = new Packet(null, "history.triggerOnPop", breadcrumb);
                    if (postMaster.widgetPluginAPI) {
                        postMaster.widgetPluginAPI.sendMessage(null, packet);
                    } else if (postMaster.launcherPluginAPI) {
                        postMaster.launcherPluginAPI.sendMessage(null, packet);
                    }
                }
            } else {
                if (callback) {
                    callback("breadcrumb not found");
                    return this;
                }
            }
        } else {
            // no history items here. delegate call to the app side
            var packet = new Packet(null, 'history.popAppHistory', breadcrumb);
            emulatorSync.sendMessage(packet);
        }
        if (callback) {
            callback(null, true);
        }
        return this;
    },
    popToHome: function popToHome() {
        if (this.historyItems && this.historyItems.length > 1) {
            for (var i = 1; i < this.historyItems.length; i++) {
                if (this.historyItems[i].source == 'control') {
                    this.pop(this.historyItems[i - 1]);
                }
            }
        }
    },
    popToPlugin: function popToPlugin() {
        if (this.historyItems && this.historyItems.length > 1) {
            for (var i = this.historyItems.length - 1; i > 1; i--) {
                if (this.historyItems[i].source == 'plugin') {
                    this.pop(this.historyItems[i - 1]);
                } else {
                    break;
                }
            }
        }
    },
    clear: function clear(options, callback) {
        var poppedItem = this.historyItems[0];
        this.historyItems.splice(0);
        if (callback) {
            callback(null);
        }
        var onUpdateEvent = new CustomEvent('historyOnUpdate', { detail: { historyItems: this.historyItems } });
        document.dispatchEvent(onUpdateEvent);
        if (poppedItem) {
            var onPopEvent = new CustomEvent('historyOnPop', { detail: { poppedItem: poppedItem } });
            document.dispatchEvent(onPopEvent);
        }
        return this;
    },
    triggerOnPop: function triggerOnPop(poppedItem) {
        var onPopEvent = new CustomEvent('historyOnPop', { detail: { poppedItem: poppedItem } });
        document.dispatchEvent(onPopEvent);
        return this;
    },
    triggerOnUpdate: function triggerOnUpdate(historyItems) {
        this.historyItems = historyItems;
        var onUpdateEvent = new CustomEvent('historyOnUpdate', { detail: { historyItems: historyItems } });
        document.dispatchEvent(onUpdateEvent);
        return this;
    },
    onUpdate: function onUpdate(callback) {
        var handler = function handler(e) {
            if (callback) callback({ historyItems: e.detail.historyItems });
        };
        document.addEventListener('historyOnUpdate', handler, false);
        return {
            clear: function clear() {
                document.removeEventListener('historyOnUpdate', handler, false);
            }
        };
    },
    onPop: function onPop(callback) {
        var handler = function handler(e) {
            if (callback) callback(e.detail);
        };
        document.addEventListener('historyOnPop', handler, false);
        return {
            clear: function clear() {
                document.removeEventListener('historyOnPop', handler, false);
            }
        };
    },
    onPush: function onPush(callback) {
        var handler = function handler(e) {
            if (callback) callback({ historyItems: e.detail.historyItems, pushedItem: e.detail.pushedItem });
        };
        document.addEventListener('historyOnPush', handler, false);
        return {
            clear: function clear() {
                document.removeEventListener('historyOnPush', handler, false);
            }
        };
    }
};
"use strict";
/**
 * Created by Daniel on 3/30/2015.
 * this class is whats used for the plugin frame to communicate with he parent app shell
 * this only allows certain interactions to occur for security purposes
 * all functionality should return *this* and accept a callback
 * *** this also handel's messages sent from the CP
 */

function Packet(id, cmd, data, error) {
	this.id = id;
	this.cmd = cmd;
	this.data = data;
	this.error = error;
	this.instanceId;
}
var pluginCount = 0;

if (typeof logger == "undefined") var logger = {
	log: function log() {}
}; //fail safe

function PluginAPI(iFrameId, appId, pluginId, instanceId, liveMode, datastoreWriteKey, type, title) {
	pluginCount++;
	this.datastore = this.analytics = this.appearance = null;
	this.iFrameId = iFrameId;
	this.iFrame = document.getElementById(iFrameId);
	this.init(appId, pluginId, instanceId, liveMode, datastoreWriteKey, type, title);
}

PluginAPI.prototype = {
	getContentWindow: function getContentWindow() {
		//if(!this.iFrame)return null;

		//if(this.iFrame && !this.iFrame.contentWindow)
		this.iFrame = document.getElementById(this.iFrameId);

		if (this.iFrame) return this.iFrame.contentWindow;else return null;
	},
	debugTag: null,
	init: function init(appId, pluginId, instanceId, liveMode, datastoreWriteKey, type, title) {

		if (!window.appContext || !window.appContext.currentApp) {
			console.error('invalid appContext cant create pluginAPI');
			return;
		}

		var cpDomain = window.appContext && window.appContext.currentApp && window.appContext.currentApp.config && window.appContext.currentApp.config.cpDomain ? window.appContext.currentApp.config.cpDomain : window.siteConfig.endPoints.appHost;

		this.context = {
			appId: appId,
			pluginId: pluginId,
			instanceId: instanceId,
			liveMode: liveMode || 0,
			endPoints: window.siteConfig.endPoints,
			cpDomain: cpDomain,
			device: window.device,
			deviceId: typeof push != "undefined" ? push.deviceId : null,
			debugTag: this.debugTag,
			datastoreWriteKey: datastoreWriteKey || undefined,
			type: type,
			appTheme: PluginAPI.appTheme,
			configType: PluginAPI.configType,
			title: title
		};

		var currentAppManifestString = localStorage.getItem("currentAppManifest");
		if (currentAppManifestString) {
			var currentAppManifest = null;
			try {
				currentAppManifest = JSON.parse(currentAppManifestString);
			} catch (err) {
				console.error("bad currentAppManifest", err);
			}
			this.context.offlineModeEnabled = currentAppManifest.offlineModeEnabled;
		}

		if (!this.context.device) {
			this.context.device = {
				platform: 'web'
			};
		}

		if (typeof AppearanceAPI != "undefined") this.appearance = new AppearanceAPI(this.context);
		if (typeof DatastoreAPI != "undefined") this.datastore = new DatastoreAPI(this.context);
		if (typeof UserDatastoreAPI != "undefined") this.userData = new UserDatastoreAPI(this.context);
		if (typeof AnalyticsAPI != "undefined") {
			this.analytics = new AnalyticsAPI(this.context);
		}
		if (typeof ImageLibAPI != "undefined") this.imageLib = new ImageLibAPI(this.context);
		if (typeof ColorLibAPI != "undefined") {
			this.colorLib = new ColorLibAPI(this.context);
			this.colorLib.onChange(function (data) {
				t.sendMessage(null, new Packet(null, 'colorLib._triggerOnChange', data));
			});
		}
		if (typeof appAPI != "undefined") this.appAPI = new appAPI(this.context);
		if (typeof ActionItemsAPI != "undefined") this.actionItems = new ActionItemsAPI(this.context);
		if (typeof NotificationsAPI != "undefined") this.notificationsAPI = new NotificationsAPI(this.context);
		if (typeof PopupLibAPI != "undefined") this.notificationsAPI = PopupLibAPI;
		if (typeof HistoryAPI != "undefined") this.history = new HistoryAPI(this.context);
		if (typeof PluginInstanceAPI != "undefined") this.pluginInstances = new PluginInstanceAPI(this.context);
		if (typeof inAppPurchaseAPI != "undefined") {
			this.inAppPurchase = inAppPurchaseAPI;
		}
		if (typeof barcodeScannerAPI != "undefined") {
			this.barcodeScanner = barcodeScannerAPI;
		}
		if (typeof UsersLibAPI != "undefined") {
			this.usersLib = new UsersLibAPI(this.context);
		}
		if (typeof PublicDatastoreAPI != "undefined") this.publicData = new PublicDatastoreAPI(this.context);
		if (typeof AppDatastoreAPI != "undefined") this.appData = new AppDatastoreAPI(this.context);

		if (typeof localStorageAPI != "undefined") this.localStorage = localStorageAPI;

		if (typeof LocalNotificationsAPI != "undefined") {
			this.localNotifications = new LocalNotificationsAPI(this.context);
		}

		if (typeof deviceAPI != "undefined") {
			this.device = deviceAPI;
			this.device.onAppBackgrounded(function (data) {
				t.sendMessage(null, new Packet(null, 'device.triggerOnAppBackgrounded', data.detail));
			});
			this.device.onAppResumed(function (data) {
				t.sendMessage(null, new Packet(null, 'device.triggerOnAppResumed', data.detail));
			});
		}
		if (typeof geoAPI != "undefined") this.geo = geoAPI;
		if (typeof inputAPI != "undefined") this.input = inputAPI;
		if (typeof notesAPI != "undefined") this.notes = notesAPI;
		if (typeof bookmarkAPI != "undefined") this.bookmarkAPI = bookmarkAPI;
		if (typeof deepLinkAPI != "undefined") this.deepLink = deepLinkAPI;
		if (typeof imagePreviewerAPI != "undefined") this.imagePreviewer = imagePreviewerAPI;

		if (typeof bluetoothAPI != "undefined") this.bluetooth = bluetoothAPI;
		if (typeof BleCentralAPI != "undefined") this.bleCentral = new BleCentralAPI();
		if (typeof iBeaconAPI != "undefined") this.iBeacon = iBeaconAPI;

		if (typeof CameraAPI != "undefined") this.camera = new CameraAPI(this.context);
		if (typeof fileManagerAPI != "undefined") this.fileManager = fileManagerAPI;
		if (typeof imageCacheAPI != "undefined") this.imageCache = imageCacheAPI;

		if (typeof PushNotificationsAPI != "undefined") this.pushNotifications = new PushNotificationsAPI(this.context);

		if (typeof FirebaseAPI != "undefined") this.firebase = new FirebaseAPI(this.context);

		if (typeof ComponentUIAPI != "undefined") this.componentUI = new ComponentUIAPI(this.context);

		if (typeof authAPI != "undefined") {
			this.auth = authAPI;
			this.auth.init(this.context);
			var t = this;
			this.auth.onLogin(function (data) {
				t.sendMessage(null, new Packet(null, 'auth.triggerOnLogin', data.detail));
			});
			this.auth.onLogout(function () {
				t.sendMessage(null, new Packet(null, 'auth.triggerOnLogout'));
			});
		}

		if (typeof richModal != "undefined") {
			this.popup = richModal;
		}

		var t = this;
		this.mediaAPI = new Object();
		if (typeof audioPlayer != "undefined") {
			this.mediaAPI.audioPlayer = audioPlayer;

			this.mediaAPI.audioPlayer.onEvent(function (e) {
				t.sendMessage(null, new Packet(null, 'services.media.audioPlayer.triggerOnEvent', e));
			});
		}

		/*****************************************************/
		///should be placed somewhere else
		this.analytics.trackActionCommand = function (obj, callback) {
			if (!obj) {
				return false;
			}
			return t.analytics.trackAction(obj.value, obj.metadata, callback);
		};
		this.analytics.trackViewCommand = function (obj, callback) {
			if (!obj) {
				return false;
			}
			return t.analytics.trackView(obj.value, obj.metadata, callback);
		};
		/*****************************************************/

		this.navigation.pluginAPI = this;

		if (typeof PublicFilesAPI != "undefined") {
			this.publicFiles = new PublicFilesAPI(this.context);
			this.publicFiles.onProgress(function (files) {
				t.sendMessage(null, new Packet(null, 'services.publicFiles._triggerOnProgress', { file: files }));
			});

			this.publicFiles.onComplete(function (files) {
				t.sendMessage(null, new Packet(null, 'services.publicFiles._triggerOnComplete', { file: files }));
			});
		}

		if (typeof searchEngineAPI != "undefined") {
			this.searchEngine = new searchEngineAPI(this.context);
		}

		if (typeof CreditsAPI != "undefined") {
			this.credits = new CreditsAPI(this.context);
		}

		if (typeof StripeAPI != "undefined") {
			this.stripe = new StripeAPI(this.context);
		}
	},
	postMessageHandler: function postMessageHandler(e) {

		if (!this.iFrameId) return false;

		var req = undefined;

		try {
			req = e.packet || JSON.parse(e.data);
		} catch (err) {
			console.warn('error parsing post message data.');
			return;
		}

		if (!req || !req.cmd || !req.cmd.split) return;

		if (e.source != this.getContentWindow() && req.fid != this.iFrameId ///dont catch your own //e.source != window.parent && if buidfire.js sends back your id then its ok
		&& this.context.instanceId != req.instanceId) {
			return;
		} //none of hour business, ignore


		//console.log(this.tag, ' received << ', e.data, window.location.href);

		var t = this;
		var callback = function callback(err, result) {
			if (err) console.warn(e.data, err);
			var packet = new Packet(req.id, req.cmd, result, err);
			t.sendMessage(null, packet);
		};

		/// prone to error but thats ok
		var sequence = req.cmd.split('.');
		var obj = this;
		var parent = this;
		for (var i = 0; i < sequence.length; i++) {
			if (i > 0) parent = obj;
			if (obj[sequence[i]]) obj = obj[sequence[i]];else {
				return true; // cant handle request but request was for me
			}
		}
		//console.log("PluginAPI", this.tag, "execute command", req.cmd);
		obj.apply(parent, [req.data, callback]);
		return true;
	},
	sendMessage: function sendMessage(destination, packet) {
		//if(!destination)
		destination = this.getContentWindow();

		if (destination && destination.postMessage) {
			//if (typeof(packet) != "string")	packet = JSON.stringify(packet);
			//console.log(this.tag, ' sent >> ', packet, window.location.href);
			packet = JSON.parse(JSON.stringify(packet)); // avoid 'object could not be cloned'
			destination.postMessage(packet, '*');
		}
	},
	getContext: function getContext(data, callback) {
		var context = Object.assign({}, this.context); // shallow copy
		if (typeof appApiKeys != 'undefined') {
			//app
			appApiKeys.get(function (err, keys) {
				context.apiKeys = keys || {}; // attach to the copy only to discourage using context.apiKeys since it might be null initially
				if (callback) callback(null, context);
			});
		} else {
			// cp
			if (window.appContext && window.appContext.currentApp && window.appContext.currentApp.apiKeys) {
				context.apiKeys = window.appContext.currentApp.apiKeys || {};
			}
			if (callback) callback(null, context);
		}
		return this;
	},
	navigation: {
		displayPopUpInstructions: function displayPopUpInstructions() {
			window.location.hash = '/popUp';
		},
		_navigateTo: function _navigateTo(pluginData, callback) {
			if (!(pluginData.pushToHistory === false)) {
				pluginData.pushToHistory = true;
			}
			var samePluginNavigation = false;
			var hash = '/pluginContainer/' + pluginData.pluginId + '/' + pluginData.instanceId + '/' + encodeURIComponent(pluginData.title) + '/' + pluginData.folderName + '/' + pluginData.pushToHistory; // + (pluginData.query  ? ('?' + pluginData.query) : '' );
			var historyAPI = new HistoryAPI();
			if (!pluginData.pushToHistory) {
				historyAPI.popToHome(); // clear to start new breadcrumbs
			}
			if (historyAPI.historyItems.length == 0) {
				historyAPI.push({ label: "Home", options: { pluginData: undefined }, source: "home" });
			}
			if (historyAPI.historyItems.length == 1 && postMaster.launcherPluginAPI && pluginData.instanceId == postMaster.launcherPluginAPI.context.instanceId && pluginData.pluginId == postMaster.launcherPluginAPI.context.pluginId) {
				// already on home
			} else {
				var currentBreadcrumb = historyAPI.historyItems[historyAPI.historyItems.length - 1];
				if (currentBreadcrumb.source == 'control') {
					if (pluginData.instanceId != currentBreadcrumb.options.pluginData.instanceId || pluginData.pluginId != currentBreadcrumb.options.pluginData.pluginId) historyAPI.push({
						label: decodeURIComponent(pluginData.title),
						options: { pluginData: pluginData, context: window.location.href },
						source: "control"
					});else {
						samePluginNavigation = true;
					}
				} else {

					var label;
					try {
						label = decodeURIComponent(pluginData.title);
					} catch (e) {
						console.error('BAD Title', pluginData.title, e);
						label = 'TITLE';
					}

					historyAPI.push({
						label: label,
						options: { pluginData: pluginData, context: window.location.href },
						source: "control"
					});
				}
			}

			/// push any data that the user wants to send to the next plugin in here
			/// the pluginCtrl will pop it and pass it along to the next plugin
			if (pluginData && pluginData.queryString) window.pluginControllerHelper.pluginPassThroughqueryString = pluginData.queryString;

			if (pluginData && (pluginData.dontTriggerHashChangeEvent || samePluginNavigation)) cpSync.navigation.silentNavigation(hash);else window.location.hash = hash;
			if (callback) callback(null, { status: 'completed' });
		},
		navigateTo: function navigateTo(pluginData, callback) {

			if (pluginData && pluginData.pluginId && pluginData.instanceId && pluginData.title && pluginData.folderName) {
				// we have everything we need
				this._navigateTo(pluginData, callback);
				return;
			}

			if (!pluginData || !pluginData.pluginId && !pluginData.instanceId && !pluginData.folderName) {
				callback('either pluginId, instanceId or folderName must be specified', false);
				return;
			}

			var that = this;

			var dsPluginInstance = new DatastoreAPI(appContext.currentApp.appId, "pluginInstances", 1, appContext.liveMode);
			var options = {};
			options.obj = {
				filter: {},
				pageSize: 1,
				withDynamicData: true
			};

			if (pluginData.instanceId) {
				options.obj.filter["$json.instanceId"] = pluginData.instanceId;
			}
			if (pluginData.pluginId) {
				options.obj.filter["$json.token"] = pluginData.pluginId;
			}

			dsPluginInstance.search(options, function (err, result) {
				if (err) {
					callback('error fetching pluginInstance', false);
				} else if (result && result.length) {
					var instanceId = result[0].data.instanceId;
					var token = result[0].data._buildfire.pluginType.result[0].token;
					var folderName = result[0].data._buildfire.pluginType.result[0].folderName;
					var title = result[0].data.title;
					that._navigateTo({
						pluginId: token,
						instanceId: instanceId,
						title: pluginData.title || title,
						folderName: folderName,
						pushToHistory: pluginData.pushToHistory,
						queryString: pluginData.queryString
					}, callback);
				} else {
					if (callback) callback('pluginInstance not found', false);
				}
			});
		},

		// params:
		// .instanceId
		// .data (optional)
		navigateToPluginInstance: function navigateToPluginInstance(params, callback) {
			var that = this;

			if (!params || !params.instanceId) {
				callback("Invalid parameters. Need to pass instanceId.");
				return;
			}

			var dsPluginInstance = new DatastoreAPI(appContext.currentApp.appId, "pluginInstances", 1, appContext.liveMode);
			var options = {};
			options.obj = {
				filter: { "$json.instanceId": params.instanceId },
				pageSize: 1,
				withDynamicData: true
			};
			dsPluginInstance.search(options, function (err, result) {
				if (err) {
					callback('error fetching pluginInstance', false);
				} else if (result && result.length) {
					var token = result[0].data._buildfire.pluginType.result[0].token;
					var folderName = result[0].data._buildfire.pluginType.result[0].folderName;
					var title = result[0].data.title;
					//var pluginAPI =  window.appContext.currentPlugin  ? window.appContext.currentPlugin.pluginAPI :window.postMaster.launcherPluginAPI ;
					//if(pluginAPI) {
					that._navigateTo({
						pluginId: token,
						instanceId: params.instanceId,
						title: title,
						folderName: folderName,
						pushToHistory: false,
						queryString: params.queryString
					}, callback);
					//}
				} else {
					if (callback) callback('pluginInstance not found', false);
				}
			});
		},
		navigateToAppearance: function navigateToAppearance(options) {
			if (options && options.dontTriggerHashChangeEvent) cpSync.navigation.silentNavigation('/appearanceSample');else window.location.hash = '/appearanceSample';
		},
		navigateHome: function navigateHome(options, callback) {
			if (options && options.dontTriggerHashChangeEvent) cpSync.navigation.silentNavigation('/');else window.location.hash = '/';
			var historyAPI = new HistoryAPI();
			historyAPI.clear(); // clear to start new breadcrumbs
			historyAPI.push({ label: "Home", options: { pluginData: undefined }, source: "home" });
			if (callback) callback();
		},
		navigateBack: function navigateBack() {
			var historyAPI = new HistoryAPI();
			var me = this;
			if (historyAPI.historyItems && historyAPI.historyItems.length > 1) {
				var poppedBreadcrumb = historyAPI.historyItems[historyAPI.historyItems.length - 1];
				var previousBreadcrumb = historyAPI.historyItems[historyAPI.historyItems.length - 2];
				if (previousBreadcrumb && previousBreadcrumb.options) {
					switch (previousBreadcrumb.source) {
						case 'control':
							var pluginData = null;
							if (poppedBreadcrumb.source == 'plugin') {
								historyAPI.pop(previousBreadcrumb);
								if (previousBreadcrumb.options.pluginData) {
									pluginData = JSON.parse(JSON.stringify(previousBreadcrumb.options.pluginData)); // clone pluginData
									me._navigateTo(pluginData);
								}
							} else {
								// navigate then pop when navigating from a plugin to another to compare that plugin has changed
								if (previousBreadcrumb.options.pluginData) {
									pluginData = JSON.parse(JSON.stringify(previousBreadcrumb.options.pluginData)); // clone pluginData
									me._navigateTo(pluginData);
								}
								historyAPI.pop(previousBreadcrumb);
							}
							break;
						case 'plugin':
							if (poppedBreadcrumb.source == 'control') {
								// must be launcher breadcrumbs
								if (window.location.protocol.indexOf('http') < 0) {
									// on device just bring the user back to the launcher plugin as is
									historyAPI.pop(previousBreadcrumb);
									window.location.hash = '/';
								} else {
									// if your on CP reset the launcher plugin so that the emulator is in sync with the reloaded content area
									historyAPI.clear(); // clear to start new breadcrumbs
									historyAPI.push({ label: "Home", options: { pluginData: undefined }, source: "home" });
									window.location.hash = '/';
								}
							} else {
								historyAPI.pop(previousBreadcrumb);
							}
							break;
						case 'home':
							if (poppedBreadcrumb.source == 'plugin') {
								// still on home
								historyAPI.pop(previousBreadcrumb);
								break;
							}
						// continue to default
						default:
							historyAPI.clear(); // clear to start new breadcrumbs
							historyAPI.push({ label: "Home", options: { pluginData: undefined }, source: "home" });
							window.location.hash = '/';
					}
				}
			} else {
				historyAPI.clear(); // clear to start new breadcrumbs
				historyAPI.push({ label: "Home", options: { pluginData: undefined }, source: "home" });
				window.location.hash = '/';
			}
		},
		scrollTop: function scrollTop(val, callback) {
			document.body.scrollTop = val ? val : 0;
			if (callback) callback();
		},
		navigateEmulator: function navigateEmulator() {
			if (!cordova || !cordova.file || !cordova.file.applicationDirectory) {
				console.log("Cant load emulator bc cordova.file.applicationDirectory is undefined");
				return;
			}

			if (!window.appContext || !window.appContext.environment) {
				console.log("Cant load emulator bc window.appContext.environment is undefined");
				return;
			}

			if (window.location.href.indexOf('http://') < 0) window.location.href = cordova.file.applicationDirectory + 'www/emulator/login.html?env=' + window.appContext.environment + '&lastUrl=' + encodeURIComponent(window.location.href);
		},
		navigateToApp: function navigateToApp(options) {
			/// dont expose. used internally
			window.location.search = '?env=' + window.appContext.environment + '&appId=' + options.appId + '&mode=' + window.appContext.currentApp.liveMode + '&lastUrl=' + encodeURIComponent(window.location.href);
		}
	},
	messaging: {
		triggerOnNewControlMessage: function triggerOnNewControlMessage(message) {
			console.warn('unhandled message [onNewControlMessage]');
		},
		triggerOnNewWidgetMessage: function triggerOnNewWidgetMessage(message) {
			/*console.warn('unhandled message [onNewWidgetMessage]');*/
			var packet = new Packet(null, 'messaging.onReceivedMessage', message);
			if (postMaster.widgetPluginAPI) postMaster.widgetPluginAPI.sendMessage(null, packet);else postMaster.launcherPluginAPI.sendMessage(null, packet);
		}
		//send message from widget to current widget service
		, sendMessageToService: function sendMessageToService(message, callback) {
			var currentPlugin = postMaster.widgetPluginAPI;
			if (!currentPlugin) {
				currentPlugin = postMaster.launcherPluginAPI;
			}
			if (currentPlugin && currentPlugin.context && postMaster.servicePluginAPIs) {
				var servicePluginAPI = postMaster.servicePluginAPIs[currentPlugin.context.instanceId];
				if (servicePluginAPI && servicePluginAPI.sendMessage) {
					var packet = new Packet(null, "messaging.onReceivedMessage", message);
					servicePluginAPI.sendMessage(null, packet);

					if (callback) {
						callback(null, true);
					}
				}
			}
			if (callback) {
				callback('no service available for current widget', null);
			}
		}
	},
	spinner: {
		show: function show(data, callback) {

			if (window.spinner) window.spinner.show();
			if (callback) callback();
		},
		hide: function hide(data, callback) {
			if (window.spinner) window.spinner.hide();
			if (callback) callback();
		}
	}

};
"use strict";
/**
 * Created by Daniel on 3/30/2015.
 */

var geoAPI = {
    currentPosition: null,
    convertPosition: function convertPosition(position) {
        var p = {
            coords: {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                altitude: position.coords.altitude,
                accuracy: position.coords.accuracy,
                altitudeAccuracy: position.coords.altitudeAccuracy,
                heading: position.coords.heading,
                speed: position.coords.speed

            },
            timestamp: position.timestamp,
            isBackground: position.isBackground ? position.isBackground : false
        };
        return p;
    },
    convertBackGroundPosition: function convertBackGroundPosition(position) {
        var p = {
            coords: {
                latitude: position.latitude,
                longitude: position.longitude,
                altitude: position.altitude,
                accuracy: position.accuracy,
                speed: position.speed

            },
            timestamp: position.time,
            isBackground: true
        };
        return p;
    },
    getCurrentPosition: function getCurrentPosition(options, callback) {

        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(function (position) {
                callback(null, geoAPI.convertPosition(position));
            }, onError, options);
        } else {
            console.error("navigator.geolocation is undefined");
        }

        return this;

        function onError(error) {
            /**
             * If getCurrentPosition failed, but a position
             * was already fetched by watchPosition
             * use the cached position
             */
            if (useCache()) {
                callback(null, geoAPI.currentPosition);
            } else {
                callback(error, null);
            }
        }

        function useCache() {
            /**
             * if no cached position, return false
             * if maximum age is not specified, or
             * the age of the cache is under the
             * maximum age, return true
             * */
            if (!geoAPI.currentPosition) return false;else if (!options.maximumAge) return true;else if (Date.now() - geoAPI.currentPosition.timestamp < options.maximumAge) return true;
        }
    },
    isAndroid: false,
    watchPosition: function watchPosition(options, callback) {
        function gotPosition(p) {
            p = geoAPI.convertPosition(p);
            p.watchId = watchId;
            // cache the fetched position
            geoAPI.currentPosition = p;

            var debugInfo = 'location: ' + p.coords.latitude + ',' + p.coords.longitude + ' ,isBackground: ' + p.isBackground + ' ' + new Date();
            console.log(debugInfo);

            var packet = new Packet(null, 'geo.onPositionChange', p);
            postMaster.broadcast(packet);
        }

        function onError(error) {
            console.log('Geo watchPosition: ', error.message);
            error.watchId = watchId;
            callback(error);
        }

        var watchId;

        if (navigator.geolocation && navigator.geolocation.watchPosition) {
            watchId = navigator.geolocation.watchPosition(gotPosition, onError, options);

            var bgSuccess = function bgSuccess(location) {
                gotPosition(geoAPI.convertBackGroundPosition(location));

                //backgroundGeolocation.finish();
            };

            var bgFailure = function bgFailure(error) {
                console.error('Background geo error', error);
            };

            var onDeviceReadyBGLocation = function onDeviceReadyBGLocation() {
                // var isAndroid = (navigator.platform.indexOf("Android") != -1
                //     || navigator.platform.indexOf("Linux") != -1
                //     || navigator.platform == null);

                //Only run custom background logic for Android
                // if(!isAndroid){
                //     return;
                // }

                // as of mauron85/cordova-plugin-background-geolocation v 3.x it was changed from
                // backgroundGeolocation to BackgroundGeolocation
                if (typeof BackgroundGeolocation === 'undefined' && typeof backgroundGeolocation === 'undefined') {
                    return;
                }

                if (typeof cordova !== 'undefined' && cordova.plugins && cordova.plugins.backgroundMode) {
                    if (cordova.plugins.backgroundMode.enable) {
                        cordova.plugins.backgroundMode.enable();
                    }
                    cordova.plugins.backgroundMode.on('activate', function () {
                        cordova.plugins.backgroundMode.disableWebViewOptimizations();
                    });
                }

                if (typeof backgroundGeolocation === 'undefined') {
                    // use >= 3.x implementation

                    BackgroundGeolocation.configure({
                        locationProvider: BackgroundGeolocation.ACTIVITY_PROVIDER,
                        desiredAccuracy: BackgroundGeolocation.HIGH_ACCURACY,
                        stationaryRadius: 1,
                        distanceFilter: 1,
                        debug: false,
                        interval: 10000,
                        fastestInterval: 5000,
                        activitiesInterval: 10000
                    });

                    BackgroundGeolocation.on('location', bgSuccess);
                    BackgroundGeolocation.on('error', bgFailure);
                    BackgroundGeolocation.on('authorization', function (status) {
                        console.log('[INFO] BackgroundGeolocation authorization status: ' + status);
                        if (status !== BackgroundGeolocation.AUTHORIZED) {
                            // we need to set delay or otherwise alert may not be shown
                            // setTimeout(function() {
                            //     var showSettings = confirm('App requires location tracking permission. Would you like to open app settings?');
                            //     if (showSettings) {
                            //         return BackgroundGeolocation.showAppSettings();
                            //     }
                            // }, 1000);
                        }
                    });

                    BackgroundGeolocation.checkStatus(function (status) {
                        console.log('[INFO] BackgroundGeolocation service is running', status.isRunning);
                        console.log('[INFO] BackgroundGeolocation services enabled', status.locationServicesEnabled);
                        console.log('[INFO] BackgroundGeolocation auth status: ' + status.authorization);

                        // you don't need to check status before start (this is just the example)
                        if (!status.isRunning) {
                            BackgroundGeolocation.start(); //triggers start on start event
                        }
                    });
                } else {
                    backgroundGeolocation.configure(bgSuccess, bgFailure, {
                        desiredAccuracy: 0,
                        stationaryRadius: 1,
                        distanceFilter: 1,
                        interval: 1000,
                        locationProvider: backgroundGeolocation.provider.ANDROID_ACTIVITY_PROVIDER
                        //ANDROID_DISTANCE_FILTER_PROVIDER
                    });
                    backgroundGeolocation.start();
                }
            };

            if (bfUtils.isMobileDevice) {
                appState.subscribe({ state: appState.RUNNING }, onDeviceReadyBGLocation);
            }
        } else {
            console.log('HTML5 position');
            watchId = setInterval(function () {
                geoAPI.getCurrentPosition(options, function (e, p) {
                    if (e) onError(e);else gotPosition(p);
                });
            }, options && options.timeout ? options.timeout : 5000);
        }
        callback();
    },
    clearWatch: function clearWatch(watchId, callback) {
        if (navigator.geolocation && navigator.geolocation.watchPosition) navigator.geolocation.clearWatch(watchId);else clearInterval(watchId);

        if (callback) callback();
    }
};
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var inputAPI = {

  /**
   * Know if the api has been initialized already or not
   * @type {Boolean}
   */
  initialized: false,

  timer: null,
  currentStepData: null,
  currentStepOptions: null,

  /**
   * Initialize the api by creating the dialog we are going to be using
   * @return {[type]} [description]
   */
  init: function init() {
    var _this = this;

    if (this.inputDialog) {
      this.inputDialog.innerHTML = '';
    } else {
      this.inputDialog = document.createElement('div');
      this.inputDialog.style.display = 'none';
    }

    if (this.listDialog) {
      this.listDialog.innerHTML = '';
    } else {
      this.listDialog = document.createElement('div');
      this.listDialog.style.display = 'none';
    }

    if (this.backdrop) {
      this.backdrop.className = '';
    } else {
      this.backdrop = document.createElement('div');
      this.backdrop.id = 'input-backdrop';
    }

    if (window.location.pathname.indexOf('pluginTester') >= 0) {
      this.inputDialog.style.height = document.getElementById('app').offsetHeight + 'px';
      this.inputDialog.style.position = 'absolute';

      this.listDialog.style.height = document.getElementById('app').offsetHeight + 'px';
      this.listDialog.style.position = 'absolute';
    } else {
      this.inputDialog.style.height = '100vh';
      this.inputDialog.style.maxHeight = '100vh';

      this.listDialog.style.height = '100vh';
      this.listDialog.style.maxHeight = '100vh';
    }

    //----------------// DIALOG BODY, NAV, USER AND TEXT AREA //----------------//
    var footerMenu = localStorage.getItem('footerMenu');

    this.inputDialog.id = 'inputDialog';
    this.inputDialog.className = footerMenu ? 'has-footer-menu' : '';

    var wrapper = document.createElement('div');
    wrapper.className = 'input-dialog-container backgroundColorTheme';
    this.inputDialog.appendChild(wrapper);

    this.dialogNav = document.createElement('div');
    this.dialogNav.className = 'inputapi-nav titleBarBackgroundTheme';
    wrapper.appendChild(this.dialogNav);

    this.dialogNavFlex = document.createElement('div');
    this.dialogNavFlex.className = 'inputapi-nav-flex';
    this.dialogNav.appendChild(this.dialogNavFlex);

    this.dialogNavSecondary = document.createElement('div');
    this.dialogNavSecondary.className = 'inputapi-nav secondary titleBarBackgroundTheme';
    wrapper.appendChild(this.dialogNavSecondary);

    this.dialogNavFlexSecondary = document.createElement('div');
    this.dialogNavFlexSecondary.className = 'inputapi-nav-flex secondary';
    this.dialogNavSecondary.appendChild(this.dialogNavFlexSecondary);

    this.currentUserContainer = document.createElement('div');
    this.currentUserContainer.className = 'inputapi-user-container';
    wrapper.appendChild(this.currentUserContainer);

    this.textarea = document.createElement('textarea');
    this.textarea.className = 'inputapi-textarea needsfocus';
    this.textarea.addEventListener('touchend', function (e) {
      e.target.click();
    });
    this.textarea.addEventListener('focus', function (_ref) {
      var target = _ref.target;

      target.style.webkitTransform = 'translate3d(0px,-10000px,0)';
      requestAnimationFrame(function () {
        return target.style.webkitTransform = '';
      });
    });
    this.textarea.addEventListener('input', function (e) {
      _this.currentStepData.textValue = e.target.value;
      if (_this.currentStepData.textValue.length > _this.currentStepOptions.maxLength) {
        _this.currentStepData.textValue = _this.currentStepData.textValue.substring(0, _this.currentStepOptions.maxLength);
        e.target.value = _this.currentStepData.textValue;
      }

      _this.doneButton.disabled = !_this.validate();
    });
    wrapper.appendChild(this.textarea);

    //------------------------// IMAGE GALLERY AND GEO //-----------------------//
    this.imageGallery = document.createElement('div');
    this.imageGallery.id = 'imageGallery';

    this.geoContainer = document.createElement('div');
    this.geoContainer.id = 'geo-container';
    this.geoContainer.classList = 'img-gallery-container';
    this.geoContainer.style.display = 'none';

    this.geoImage = document.createElement('img');
    this.geoImage.id = 'geo-img';
    this.geoContainer.appendChild(this.geoImage);

    this.geoDeleteBtn = document.createElement('span');
    this.geoDeleteBtn.className = 'galery-delete glyphicon glyphicon-minus-sign';
    this.geoDeleteBtn.onclick = function () {
      return _this.setLocation();
    };

    this.geoContainer.appendChild(this.geoDeleteBtn);
    this.imageGallery.appendChild(this.geoContainer);
    wrapper.appendChild(this.imageGallery);

    //------------------------// NAV BUTTONS AND TITLE //------------------------//
    this.cancelButton = document.createElement('button');
    this.cancelButton.className = 'inputapi-cancel titleBarTextAndIcons';
    this.dialogNavFlex.appendChild(this.cancelButton);

    this.title = document.createElement('h1');
    this.title.className = 'inputapi-nav-title primary titleBarTextAndIcons ellipsis';
    this.title.style.whiteSpace = 'nowrap';
    this.dialogNavFlex.appendChild(this.title);

    this.titleSecondary = document.createElement('h1');
    this.titleSecondary.className = 'inputapi-nav-title secondary titleBarTextAndIcons ellipsis';
    this.titleSecondary.style.whiteSpace = 'nowrap';
    this.dialogNavFlexSecondary.appendChild(this.titleSecondary);

    this.doneButton = document.createElement('button');
    this.doneButton.className = 'inputapi-done titleBarTextAndIcons';
    this.dialogNavFlex.appendChild(this.doneButton);

    //--------------------------------// FOOTER //-------------------------------//
    this.actionFooter = document.createElement('div');
    this.actionFooter.className = 'inputapi-footer';
    wrapper.appendChild(this.actionFooter);

    //--------------------------------// CAMERA //-------------------------------//
    this.cameraBtn = document.createElement('span');
    this.cameraBtn.className = 'icon icon-camera2 needsclick';
    this.cameraBtn.onclick = function (e) {
      return _this.showFileDialog();
    };
    this.actionFooter.appendChild(this.cameraBtn);

    //-------------------------------// GEO PIN //-------------------------------//
    this.geoPin = document.createElement('span');
    this.geoPin.id = 'goc-pin';
    this.geoPin.className = 'icon icon-map-marker';
    this.geoPin.onclick = function (e) {
      return _this.showLocationModal();
    };
    this.actionFooter.appendChild(this.geoPin);

    //-------------------------------// GIF ICON //-------------------------------//
    this.gifBtn = document.createElement('span');
    this.gifBtn.className = 'icon icon-gif';
    this.gifBtn.id = 'gif-btn';
    this.gifBtn.onclick = function (e) {
      return _this.showGifDialog();
    };
    this.actionFooter.appendChild(this.gifBtn);

    //------------------------------// LIST DIALOG //-----------------------------//

    this.listDialog.id = 'listDialog';

    var listDialogBody = document.createElement('div');
    listDialogBody.className = 'body';
    this.listDialog.appendChild(listDialogBody);

    this.listDialogHeader = document.createElement('h1');
    this.listDialogHeader.className = 'list-header';
    listDialogBody.appendChild(this.listDialogHeader);

    this.listDialogItems = document.createElement('form');
    this.listDialogItems.className = 'input-list';
    listDialogBody.appendChild(this.listDialogItems);

    var listDialogBtnRow = document.createElement('div');
    listDialogBtnRow.className = 'button-container';
    listDialogBody.appendChild(listDialogBtnRow);

    this.listDialogCancelBtn = document.createElement('button');
    this.listDialogCancelBtn.className = 'cancel primaryTheme';
    listDialogBtnRow.appendChild(this.listDialogCancelBtn);

    this.listDialogConfirmBtn = document.createElement('button');
    this.listDialogConfirmBtn.className = 'confirm primaryTheme';
    listDialogBtnRow.appendChild(this.listDialogConfirmBtn);

    if (window.location.pathname.indexOf('pluginTester') >= 0) {
      document.getElementById('app').appendChild(this.inputDialog);
      document.getElementById('app').appendChild(this.listDialog);
      document.getElementById('app').appendChild(this.backdrop);
    } else {
      document.body.appendChild(this.inputDialog);
      document.body.appendChild(this.listDialog);
      document.body.appendChild(this.backdrop);
    }

    this.initialized = true;
  },

  /**
   * @method showLocationModal
   * calls @method getLocation and
   * constructs mapUrl and displays
   * a modal. Modal confirm calls
   * @method setLocation to save location
   */
  showLocationModal: function showLocationModal() {
    var _this2 = this;

    window.spinner && window.spinner.show();
    this.getLocation(function (err, result) {
      try {
        if (err) throw err;
        var _result$coords = result.coords,
            latitude = _result$coords.latitude,
            longitude = _result$coords.longitude;

        var _getMapUrl = _this2.getMapUrl(result),
            mapUrl = _getMapUrl.mapUrl,
            thumbnail = _getMapUrl.thumbnail;

        if (_this2.currentStepOptions.attachments.location.required) {
          window.spinner && window.spinner.hide();
          _this2.geoDeleteBtn.style.display = 'none';
          return _this2.setLocation({ latitude: latitude, longitude: longitude }, thumbnail);
        }

        var title = 'Send My Current Location';
        var richContent = '\n          <img style="height: 90vw !important; width: 90vw !important" src="' + mapUrl + '" />\n        ';
        var action = {
          title: 'Confirm',
          handler: function handler() {
            return _this2.setLocation({ latitude: latitude, longitude: longitude }, thumbnail);
          }
        };

        var modalOptions = { title: title, richContent: richContent, action: action };

        window.spinner && window.spinner.hide();
        richModal.display(modalOptions);
      } catch (error) {
        console.error('inputAPI location error', error);

        var _title = 'Could not determine location';
        var _richContent = 'Failed to determine location. Please try again later.';

        if (error.code) {
          switch (error.code) {
            case 1:
              {
                _richContent = 'App does not have location access.';
                break;
              }
            case 2:
              {
                _richContent = 'Location information is not availible to this device.';
                break;
              }
            case 3:
              {
                _richContent = 'Location request timed out. Try again.';
                break;
              }
            case 4:
              {
                _richContent = 'Failed to determine location. Please try again later (code 4)';
                break;
              }
            case 5:
              {
                _richContent = 'This app does not have access to this feature.';
                break;
              }
            default:
              {
                break;
              }
          }
        }

        var _modalOptions = { title: _title, richContent: _richContent };
        richModal.display(_modalOptions);
        window.spinner && window.spinner.hide();
      }
    });
  },

  /**
   * @method getLocation
   * calls geoAPI to get location
   * @param {Function} callback (err, result)
   * @throws {Error} if geoAPI is not defined
   */
  getLocation: function getLocation(callback) {
    var error = null;
    var googleMapKey = null;

    appApiKeys.get(function (err, keys) {
      googleMapKey = keys.googleMapKey;

      if (!googleMapKey) {
        error = new Error('no google API key');
        error.code = 5;
      }
      if (!error && (typeof geoAPI === 'undefined' ? 'undefined' : _typeof(geoAPI)) != 'object') {
        error = new Error('geoAPI not defined');
        error.code = 4;
      }
      if (error) {
        callback(error, null);
      } else {
        var options = { timeout: 10000 };
        geoAPI.getCurrentPosition(options, function (err, result) {
          if (result) result.googleMapKey = googleMapKey;
          callback(err, result);
        });
      }
    });
  },

  /**
  * @method setLocation
  * Sets or resets the location.
  * If either parameter is omitted
  * resets the location.
  * @param {object} loc geo response
  * @param {string} thumbnail map thumbnail url
  */
  setLocation: function setLocation(loc, thumbnail) {
    if (loc && thumbnail) {
      this.currentStepData.location = loc;
      this.geoContainer.style.display = 'block';
      this.geoImage.src = thumbnail;
    } else {
      this.currentStepData.location = {};
      this.geoContainer.style.display = 'none';
      this.geoImage.removeAttribute('src');
    }
    this.doneButton.disabled = !this.validate();
  },

  getMapUrl: function getMapUrl(data) {
    var _data$coords = data.coords,
        latitude = _data$coords.latitude,
        longitude = _data$coords.longitude;
    var googleMapKey = data.googleMapKey;


    var baseUrl = 'https://maps.googleapis.com/maps/api/staticmap';
    var size = 'size=' + window.innerWidth + 'x' + window.innerWidth;
    var mapOptions = 'zoom=15&' + size + '&maptype=roadmap&key=' + googleMapKey;
    var center = 'center=' + latitude + ',' + longitude;
    var marker = 'markers=color:blue|size:large|' + latitude + ',' + longitude;

    var mapUrl = baseUrl + '?' + center + '&' + marker + '&' + mapOptions;

    var thumbnail = mapUrl.replace(/size:large/g, 'size:mid').replace(/size=\d{1,4}x\d{1,4}/g, 'size=100x100').replace(/zoom=15/g, 'zoom=12');

    return { mapUrl: mapUrl, thumbnail: thumbnail };
  },

  /**
   * @method showGifDialog
   * opens the gif dialog and
   * returns the results
   */
  showGifDialog: function showGifDialog() {
    var _this3 = this;

    if ((typeof gifAPI === 'undefined' ? 'undefined' : _typeof(gifAPI)) != 'object') return;
    var _currentStepOptions$a = this.currentStepOptions.attachments.gifs,
        multiple = _currentStepOptions$a.multiple,
        rating = _currentStepOptions$a.rating;


    var _add = function _add(gif) {
      var imagesLength = _this3.currentStepData.images.length;
      var gifsLength = _this3.currentStepData.gifs.length;

      if (imagesLength + gifsLength >= 6) return;

      _this3.currentStepData.gifs.push(gif);

      var image = '';

      if (!bfUtils.isIOS) {
        image = gif.images.downsized_medium.url || gif.images.original.url;
      } else {
        image = gif.images.preview.mp4 || gif.images.gif.downsized_small.mp4;
      }
      _this3.addToGallery(image, 'gifs');
    };

    var handleGifResponse = function handleGifResponse(error, response) {
      if (error || !response) return;
      var cancelled = response.cancelled,
          results = response.results;


      if (cancelled || !results || !results.length) return;

      if (multiple) {
        response.results.forEach(function (gif) {
          return _add(gif);
        });
      } else {
        _this3.currentStepData.gifs = [];

        var element = document.getElementById('gifs_0');
        if (element) {
          _this3.imageGallery.removeChild(element);
        }

        var gif = response.results[0];
        _add(gif);
      }
    };

    gifAPI.showGifDialog({ multiple: multiple, rating: rating }, handleGifResponse);
  },

  showFileDialog: function showFileDialog() {
    var _this4 = this;

    var fileApi = new PublicFilesAPI(window.appContext.currentApp);

    // Monkeypatch fileApi instance
    fileApi._onComplete = function (resultFile) {
      if (resultFile.status === 'success') {
        var _currentStepData = _this4.currentStepData,
            images = _currentStepData.images,
            gifs = _currentStepData.gifs;


        var imagesLength = images ? images.length : 0;
        var gifsLength = gifs ? gifs.length : 0;

        if (gifsLength + imagesLength >= 6) return;

        _this4.currentStepData.images.push(resultFile.url);
        _this4.addToGallery(resultFile.url, 'images');
      } else {
        console.error('Image upload failed - inputAPI', resultFile);
      }
    };

    fileApi._onProgress = function () {
      if (window.spinner) window.spinner.show();
      _this4.doneButton.disabled = true;
    };

    var multiple = this.currentStepOptions.attachments.images.multiple;

    var allowMultipleFilesUpload = multiple || false;

    fileApi.showDialog({ allowMultipleFilesUpload: allowMultipleFilesUpload }, function () {
      if (window.spinner) setTimeout(window.spinner.hide.bind(null, true), 300);

      _this4.doneButton.disabled = _this4.currentStepOptions.required && _this4.currentStepData.textValue && !_this4.currentStepData.textValue.length ? true : false;
    });
  },
  addToGallery: function addToGallery(url, type) {
    var _this5 = this;

    var index = this.currentStepData[type].length - 1;

    var itemContainer = document.createElement('div');
    itemContainer.className = 'img-gallery-container animated fadeInUp ' + type;
    itemContainer.id = type + '_' + index;

    var deleteBtn = document.createElement('span');
    deleteBtn.className = 'galery-delete glyphicon glyphicon-minus-sign';
    deleteBtn.onclick = function () {
      _this5.removeFromGallery(index, type);
    };
    itemContainer.appendChild(deleteBtn);

    if (type === 'images' && typeof imageTools != 'undefined') {
      var options = {
        size: 's',
        aspect: '1:1',
        compression: 50
      };
      url = imageTools.cropImage(url, options);
    }

    var item = document.createElement('img');
    item.setAttribute('src', url);

    item.className = 'img-gallery-item ' + type;
    itemContainer.appendChild(item);
    this.imageGallery.appendChild(itemContainer);

    var _currentStepData2 = this.currentStepData,
        images = _currentStepData2.images,
        gifs = _currentStepData2.gifs;

    var imagesLength = images ? images.length : 0;
    var gifsLength = gifs ? gifs.length : 0;

    if (gifsLength + imagesLength > 5) {
      this.cameraBtn.classList.add('disabled');
      this.gifBtn.classList.add('disabled');
    };
  },
  removeFromGallery: function removeFromGallery(index, type) {
    this.currentStepData[type].splice(index, 1);

    var element = document.getElementById(type + '_' + index);
    if (element) {
      this.imageGallery.removeChild(element);
    }

    var _currentStepData3 = this.currentStepData,
        images = _currentStepData3.images,
        gifs = _currentStepData3.gifs;

    var imagesLength = images ? images.length : 0;
    var gifsLength = gifs ? gifs.length : 0;

    if (gifsLength + imagesLength < 6) {
      this.cameraBtn.classList.remove('disabled');
      this.gifBtn.classList.remove('disabled');
    };
  },
  renderStep: function renderStep(stepOptions, handleCancel, handleNext) {
    var _this6 = this;

    //------------------ reset step data ------------------//
    this.currentStepData = {
      textValue: stepOptions.defaultValue || '',
      images: [],
      location: {},
      gifs: []
    };
    stepOptions.maxLength = stepOptions.maxLength || 2000;
    this.currentStepOptions = stepOptions;

    //-------------------  reset nav bar -------------------//
    this.title.innerHTML = stepOptions.title || '';
    this.titleSecondary.innerHTML = stepOptions.title || '';

    //-------------- reset attachment buttons ---------------//
    var _currentStepOptions$a2 = this.currentStepOptions.attachments,
        location = _currentStepOptions$a2.location,
        images = _currentStepOptions$a2.images,
        gifs = _currentStepOptions$a2.gifs;


    var hasAttachments = false;

    ['images', 'gifs', 'location'].forEach(function (key) {
      if (stepOptions.attachments[key] && stepOptions.attachments[key].enable) {
        if (!stepOptions.attachments[key].required) hasAttachments = true;
      }
    });

    this.actionFooter.style.display = hasAttachments ? 'flex' : 'none';

    this.cameraBtn.style.display = images.enable && this.currentStepData.images.length < 6 ? 'block' : 'none';

    this.geoPin.style.display = location.enable && !location.required ? 'block' : 'none';

    this.gifBtn.style.display = gifs.enable ? 'block' : 'none';

    //----------------- reset user container -----------------//
    this.currentUserContainer.innerHTML = '';
    var user = authAPI.getCurrentUser();
    console.log('Renering inputAPI for user', user);
    this.userImage = document.createElement('img');
    if (user && user.imageUrl) {
      if (typeof imageTools != 'undefined') {
        var options = {
          size: 'xs',
          aspect: '1:1',
          compression: 70
        };
        this.userImage.src = imageTools.cropImage(user.imageUrl, options);
      } else {
        this.userImage.src = user.imageUrl;
      }
    } else {
      this.userImage.src = 'https://pluginserver.buildfire.com/styles/media/avatar-placeholder.png';
    }
    this.userImage.className = 'inputapi-user-image';
    this.currentUserContainer.appendChild(this.userImage);
    this.userTitle = document.createElement('h1');
    this.userTitle.className = 'inputapi-user-title';
    if (user && user.displayName) {
      this.userTitle.innerHTML = user.displayName;
    }
    this.currentUserContainer.appendChild(this.userTitle);

    //------------------- reset text area -------------------//
    this.textarea.placeholder = stepOptions.placeholder || 'Type something...';
    this.textarea.maxLength = stepOptions.maxLength || 2000;
    this.textarea.value = stepOptions.defaultValue ? stepOptions.defaultValue.substring(0, this.textarea.maxLength) : '';

    //---------- build button texts for app to web ----------//
    var doneButtonText = document.createElement('div');
    doneButtonText.className = "btn-txt primary";
    doneButtonText.innerHTML = stepOptions.saveText ? stepOptions.saveText : stepOptions._buffer.length ? 'Next' : 'Done';

    var doneButtonTextSecondary = document.createElement('div');
    doneButtonTextSecondary.className = "btn-txt secondary iconsTheme";
    doneButtonTextSecondary.innerHTML = stepOptions.saveText ? stepOptions.saveText : stepOptions._buffer.length ? 'Next' : 'Done';

    var cancelButtonText = document.createElement('div');
    cancelButtonText.className = "btn-txt primary";
    cancelButtonText.innerHTML = stepOptions.cancelText || 'Cancel';

    var cancelButtonTextSecondary = document.createElement('div');
    cancelButtonTextSecondary.className = "btn-txt secondary iconsTheme";
    cancelButtonTextSecondary.innerHTML = stepOptions.cancelText || 'Cancel';

    this.doneButton.innerHTML = '';
    this.cancelButton.innerHTML = '';

    this.doneButton.appendChild(doneButtonText);
    this.doneButton.appendChild(doneButtonTextSecondary);

    this.cancelButton.appendChild(cancelButtonText);
    this.cancelButton.appendChild(cancelButtonTextSecondary);

    this.doneButton.onclick = function (e) {
      return handleNext(_this6.currentStepData);
    };
    this.cancelButton.onclick = function (e) {
      return handleCancel();
    };
    this.backdrop.onclick = function (e) {
      return handleCancel();
    };
    if (stepOptions.prefill) this.textarea.value = stepOptions.prefill;

    this.doneButton.disabled = !this.validate();

    //------------------ reset attachments ------------------//

    while (this.imageGallery.childNodes[1]) {
      this.imageGallery.removeChild(this.imageGallery.childNodes[1]);
    }
    if (location.required) {
      this.showLocationModal();
    } else {
      this.setLocation();
    }
  },


  /**
   * Show the input box
   * @param  {[Object]}   options  Array of settings for each input step
   * @param  {Function} callback Results callback
   */
  showTextDialog: function showTextDialog(options, callback) {
    var _this7 = this;

    if (!options || !callback) return;

    if (this.currentStepOptions && this.currentStepOptions._buffer) {
      return callback({ message: 'inputDialog is already active' });
    }

    if (!this.initialized) this.init();

    // options should always be an array
    var steps = Array.isArray(options) ? options : [options];
    var results = [];

    // Validate lengths
    var saveTooLong = false;
    var cancelTooLong = false;
    steps.forEach(function (step) {
      if (step.cancelText && step.cancelText.length > 9) cancelTooLong = true;
      if (step.saveText && step.saveText.length > 9) saveTooLong = true;
      if (!step.attachments) step.attachments = {};
      if (!step.attachments.images) step.attachments.images = {};
      if (!step.attachments.location) step.attachments.location = {};
      if (step.attachments.location.required) step.attachments.location.enable = true;
      if (!step.attachments.gifs) step.attachments.gifs = {};
    });

    if (saveTooLong) return callback(new Error('saveText too long, max 9 chars'));
    if (cancelTooLong) return callback(new Error('cancelText too long, max 9 chars'));
    if (options.hideUserData || !authAPI.getCurrentUser()) this.currentUserContainer.style.display = 'none';
    if (options.prefill) this.textarea.value = options.prefill;

    var handleClose = function handleClose(cancelled) {
      /**
       * Reset step data and options
       * Wait 150ms before closing the dialog
       * if textDialog is not called first,
       * hide and reset
       */
      callback(null, { cancelled: cancelled, results: results });
      _this7.currentStepOptions = null;
      _this7.currentStepData = null;
      _this7.timer = setTimeout(function () {
        _this7.inputDialog.classList.remove('active');
        _this7.backdrop.classList.remove('active');
        setTimeout(function () {
          // return if showTextDialog was called after timeout executed
          if (_this7.inputDialog.classList.contains('active')) return;
          _this7.inputDialog.style.display = 'none';
          _this7.init();
        }, 500);
      }, 150);
    };

    var handleCancel = function handleCancel() {
      handleClose(true);
    };

    var handleNext = function handleNext(currentStepResults) {
      results.push(currentStepResults);

      var nextStep = steps.shift();
      if (nextStep) {
        nextStep._buffer = steps;
        _this7.renderStep(nextStep, handleCancel, handleNext);
      } else {
        handleClose(false);
      }
    };

    var currentStep = steps.shift();
    currentStep._buffer = steps;
    this.renderStep(currentStep, handleCancel, handleNext);

    // if textDialog just executed its callback, clear the timer
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }

    this.inputDialog.style.display = 'flex';
    // set timeout to prevent animation while display is none
    setTimeout(function () {
      _this7.inputDialog.classList.add('active');
      _this7.backdrop.classList.add('active');
    }, 100);
  },

  showListDialog: function showListDialog(options, callback) {
    var _this8 = this;

    if (!options || !callback) return;

    if (!options.listItems || !options.listItems.length) {
      return callback(new Error('No listItems provided to showListDialog'), null);
    }
    if (options.listItems.some(function (item) {
      return !item.text || !item.value;
    })) {
      return callback(new Error('All listItems must contain text and value'), null);
    }
    if (!options.cancelButton) {
      options.cancelButton = {
        text: 'Cancel',
        value: 'cancel'
      };
    }
    if (!options.confirmButton) {
      options.confirmButton = {
        text: 'Ok',
        value: 'ok'
      };
    }

    if (!this.initialized) this.init();

    this.listDialogItems.innerHTML = '';

    this.listDialogHeader.innerText = options.title || '';

    options.listItems.forEach(function (item) {

      var listItem = document.createElement('div');
      listItem.className = 'input-list-item';

      var itemSelect = document.createElement('input');
      itemSelect.value = item.value;
      itemSelect.setAttribute('type', options.multiSelect ? 'checkbox' : 'radio');
      itemSelect.setAttribute('name', 'listDialogItem');
      itemSelect.setAttribute('id', item.value);
      listItem.appendChild(itemSelect);

      var itemLabel = document.createElement('label');
      itemLabel.setAttribute('for', item.value);

      var selector = document.createElement('span');
      selector.className = 'selector primaryBackgroundTheme';
      var itemText = document.createElement('div');
      itemText.innerText = item.text;

      itemLabel.appendChild(selector);
      itemLabel.appendChild(itemText);
      listItem.appendChild(itemLabel);

      _this8.listDialogItems.appendChild(listItem);
    });

    var selected = [];

    this.listDialogItems.addEventListener('change', function (e) {
      var _e$target = e.target,
          value = _e$target.value,
          type = _e$target.type;


      switch (type) {
        case 'checkbox':
          {

            if (e.target.checked) {
              selected.push({ value: value });
            } else {
              selected = selected.filter(function (item) {
                return item.value !== value;
              });
            }

            break;
          }
        case 'radio':
          {

            selected = [{ value: value }];
            _this8.listDialogConfirmBtn.disabled = false;

            break;
          }
        default:
          break;
      }
    });

    this.listDialogCancelBtn.innerHTML = options.cancelButton.text;
    this.listDialogCancelBtn.value = options.cancelButton.value;

    this.listDialogConfirmBtn.innerHTML = options.confirmButton.text;
    this.listDialogConfirmBtn.value = options.confirmButton.value;

    if (!options.multiSelect) {
      this.listDialogConfirmBtn.disabled = true;
    }

    var closeDialog = function closeDialog() {
      _this8.listDialog.classList.remove('active');
      _this8.backdrop.classList.remove('active');
      _this8.backdrop.classList.remove('isDialog');

      _this8.listDialogItems.innerHTML = '';
      _this8.listDialogHeader.innerHTML = '';
    };

    this.backdrop.onclick = function () {
      closeDialog();
      return callback(null, { cancelled: true, selected: selected });
    };

    this.listDialogCancelBtn.onclick = function () {
      closeDialog();
      return callback(null, { cancelled: true, selected: selected });
    };

    this.listDialogConfirmBtn.onclick = function () {
      closeDialog();
      return callback(null, { cancelled: false, selected: selected });
    };

    this.listDialog.classList.add('active');
    this.backdrop.classList.add('active');
    this.backdrop.classList.add('isDialog');
  },

  validate: function validate() {
    var isTextValid = false;
    var isLocationValid = false;

    var _currentStepOptions = this.currentStepOptions,
        required = _currentStepOptions.required,
        attachments = _currentStepOptions.attachments;


    if (!required || this.textarea.value && this.textarea.value.length > 0) {
      isTextValid = true;
    }

    if (!attachments.location.required || this.currentStepData.location.latitude) {
      isLocationValid = true;
    }

    return isTextValid && isLocationValid;
  }
};

setTimeout(function () {
  if (!inputAPI.initialized) inputAPI.init();
}, 5000);
'use strict';

/**
 * @constant gifAPI
 * @summary gif dialog and api
 * @description Opens a dialog allowing users to search
 * and select gifs via an API such as Giphy.
 * Exposes a search method that can be
 * called without using any UI.
 * This API can be opened and operated
 * independently of other APIs.
 * @since v3.28.6 08/14/2019
 * @author Christopher Berger
 * @link documentation: https://github.com/BuildFire/app/wiki/gifAPI
 */

var gifAPI = {

	/**
  * @property {Boolean} initialized
  * determines if the dialog has been initialized
  * used to avoid reinitialization of UI
  */
	initialized: false,
	/**
  * @property {String} apiKey
  * key for target gif API.
  */
	apiKey: '5yISc07frWLGwJJgXt7PKnsDMQP1or1H',
	/**
  * @property {Array} results
  * holds the selected gifs to return
  */
	results: [],
	/**
  * @property {Object} pages
  * pages of gif results to be loaded later
  */
	pages: [],
	/**
  * @property {Object} options
  * options passed to showGifDialog
  */
	options: {},
	handleClose: null,
	/**
  * @method init
  * @summary initializes the gifDialog UI
  * @description generates the gif dialog UI.
  * If called after initialized,
  * rebuilds the dialog.
  * Called 5 seconds after the app loads,
  * unless showGifDialog was called first
  * @see showGifDialog
  */
	init: function init() {
		var _this = this;

		if (this.gifDialog) {
			this.gifDialog.innerHTML = '';
		} else {
			this.gifDialog = document.createElement('div');
			this.gifDialog.style.display = 'none';
		}

		if (this.backdrop) {
			this.backdrop.className = '';
		} else {
			this.backdrop = document.createElement('div');
			this.backdrop.id = 'gif-backdrop';
		}

		this.gifDialog.id = 'gifDialog';
		this.gifDialog.className = 'backgroundColorTheme';

		var gifDialogContainer = document.createElement('div');
		gifDialogContainer.className = 'gifDialog-container backgroundColorTheme';
		this.gifDialog.appendChild(gifDialogContainer);

		var gifToolBar = document.createElement('div');
		gifToolBar.className = 'gifapi-nav backgroundColorTheme';
		gifDialogContainer.appendChild(gifToolBar);

		var gifSearchBar = document.createElement('div');
		gifSearchBar.className = 'gifapi-nav-flex gifapi-search-bar';
		gifToolBar.appendChild(gifSearchBar);

		this.cancelButton = document.createElement('span');
		this.cancelButton.className = 'icon icon-cross2 gifapi-cancel bodyTextTheme';
		this.cancelButton.style.width = 'unset';

		gifSearchBar.appendChild(this.cancelButton);

		var formWrapper = document.createElement('form');
		formWrapper.action = '.';
		gifSearchBar.appendChild(formWrapper);

		this.gifSearchInput = document.createElement('input');
		this.gifSearchInput.className = 'gif-search-input form-control';
		this.gifSearchInput.placeholder = 'search GIPHY';
		this.gifSearchInput.type = 'search';
		this.gifSearchInput.onkeydown = function (_ref) {
			var key = _ref.key,
			    target = _ref.target;

			if (key === 'Enter') {
				_this.search();
				target.blur();
			}
		};
		this.gifSearchInput.oninput = function (_ref2) {
			var target = _ref2.target;

			_this.clearSearch.style.display = target.value ? 'block' : 'none';
		};

		this.setSearchBarStyle();
		formWrapper.appendChild(this.gifSearchInput);

		var searchIcon = document.createElement('i');
		searchIcon.className = 'glyphicon glyphicon-search search-icon';
		formWrapper.appendChild(searchIcon);

		this.clearSearch = document.createElement('button');
		this.clearSearch.className = 'search-clear';
		this.clearSearch.style.display = 'none';
		this.clearSearch.onclick = function (_ref3) {
			var target = _ref3.target;

			_this.gifSearchInput.value = '';
			target.style.display = 'none';
		};
		formWrapper.appendChild(this.clearSearch);

		var clearSearchIcon = document.createElement('i');
		clearSearchIcon.className = 'glyphicon glyphicon-minus-sign';
		this.clearSearch.appendChild(clearSearchIcon);

		this.gifResults = document.createElement('div');
		this.gifResults.className = 'gif-results';

		this.gifResults.addEventListener('scroll', function () {
			_this.lazyLoad.processLazyImages();
			_this.loadPage();
		}, false);
		gifDialogContainer.appendChild(this.gifResults);

		var poweredBy = document.createElement('div');
		poweredBy.className = 'powered-by';
		gifDialogContainer.appendChild(poweredBy);

		var poweredByLogo = document.createElement('img');
		poweredByLogo.src = window._appRoot + 'media/PoweredByGiphy.png';;
		poweredBy.appendChild(poweredByLogo);

		if (window.location.pathname.indexOf('pluginTester') >= 0) {
			this.gifDialog.style.height = document.getElementById('app').offsetHeight + 'px';
			this.gifDialog.style.position = 'absolute';
			document.getElementById('app').appendChild(this.gifDialog);
			document.getElementById('app').appendChild(this.backdrop);
		} else {
			this.gifDialog.style.height = '100vh';
			this.gifDialog.style.maxHeight = '100vh';
			document.body.appendChild(this.gifDialog);
			document.body.appendChild(this.backdrop);
		}

		this.initialized = true;
	},
	setSearchBarStyle: function setSearchBarStyle() {
		var _this2 = this;

		var callback = function callback(err, result) {
			if (err || !result || !result.data || !result.data.colors) return;

			var _result$data$colors = result.data.colors,
			    backgroundColor = _result$data$colors.backgroundColor,
			    bodyText = _result$data$colors.bodyText;


			var colorMethod = tinycolor(backgroundColor).isDark() ? 'lighten' : 'darken';

			var searchBarBackground = tinycolor(backgroundColor)[colorMethod](10).toString();
			var searchBarColor = tinycolor(bodyText)[colorMethod](10).toString();

			// cannot set psudo element styles via JS
			var searchBarStyle = document.createElement('style');
			searchBarStyle.innerHTML = '\n\t\t\t\t.gif-search-input::placeholder,\n\t\t\t\t.search-icon {\n\t\t\t\t\tcolor: ' + searchBarColor + ' !important;\n\t\t\t\t}\n\t\t\t\t.gif-search-input {\n\t\t\t\t\tcolor: ' + searchBarColor + ';\n\t\t\t\t\tbackground: ' + searchBarBackground + '\n\t\t\t\t}\n\t\t\t';
			_this2.gifDialog.appendChild(searchBarStyle);
		};

		if (PluginAPI.appTheme) return callback(null, { data: PluginAPI.appTheme });

		var datastoreAPI = new DatastoreAPI(window.appContext.currentApp.appId, 'appearance', 'appearance', window.appContext.liveMode);
		datastoreAPI.get({ tag: 'appearance', withDynamicData: false }, callback);
	},

	/**
  * @method showGifDialog
  * @summary opens the gif dialog
  * @description accepts options and a callback.
  * opens the gif dialog and passes
  * the callback to be handled via renderDialog.
  * this method can be exposed via sdk
  * to operate independantly of other APIs.
  * Resets dialog and data, handles
  * dialog close and submit, and
  * loads trending gifs
  * @param {Object} options
  * options object (optional)
  * @param {String} options.rating
  * limits results to a given rating (optional)
  * @param {Boolean} options.multiple
  * determines if the user can select
  * multiple gifs (optional)
  * @param {Function} callback (required)
  * @example
  * gifAPI.showGifDialog({ rating: 'g', multiple: false }, (error, response) => {
  * 	// consume gifs
  * }));
  */
	showGifDialog: function showGifDialog(options, callback) {
		var _this3 = this;

		if (!options) options = { multiple: false, rating: 'g' };
		this.options = options;

		if (!this.initialized) this.init();

		this.gifResults.innerHTML = '';
		this.gifSearchInput.value = '';

		var handleClose = function handleClose(cancelled) {
			callback(null, { cancelled: cancelled, results: _this3.results });

			_this3.handleClose = null;
			_this3.pages = [];
			_this3.results = [];
			_this3.options = {};

			_this3.timer = setTimeout(function () {
				_this3.gifDialog.classList.remove('active');
				_this3.backdrop.classList.remove('active');

				// hide and reset, unless dialog was called first
				setTimeout(function () {
					if (_this3.gifDialog.classList.contains('active')) return;
					_this3.gifResults.innerHTML = '';
					_this3.gifSearchInput.value = '';
					_this3.gifDialog.style.display = 'none';
					_this3.init();
				}, 500);
			}, 150);
		};

		this.results = [];

		this.handleClose = handleClose;
		this.cancelButton.onclick = function () {
			return _this3.handleClose(true);
		};
		this.backdrop.onclick = function () {
			return _this3.handleClose(true);
		};

		if (this.timer) {
			clearTimeout(this.timer);
			this.timer = null;
		}
		this.gifDialog.style.display = 'flex';
		// request animation frame to prevent animation while display is none
		setTimeout(function () {
			_this3.gifDialog.classList.add('active');
			_this3.backdrop.classList.add('active');
		}, 100);

		// loading before the transition ends causes issues with lazy load
		this.gifDialog.addEventListener('transitionend', function () {
			return _this3.getTrending();
		}, { once: true });
	},

	/**
  * @method createRequestUrl
  * @description takes an object of options and
  * builds a request url
  * @param {Object} options
  * options object with the following properties
  * @param {String} options.key
  * API key
  * @param {String} options.endpoint
  * API endpoint
  * @param {String} options.query
  * search query
  * @param {String} options.rating
  * limits results to a given
  * @param {Number} options.limit
  * limits number of results
  * @param {Number} options.offset
  * skips results
  * @returns {String}
  */
	createRequestUrl: function createRequestUrl(options) {
		if (!options) return;

		var key = options.key,
		    endpoint = options.endpoint,
		    query = options.query,
		    limit = options.limit,
		    offset = options.offset,
		    rating = options.rating;


		var baseUrl = 'https://api.giphy.com/v1/gifs/' + endpoint + '?api_key=' + key;
		limit = '&limit=' + (limit || 120);
		offset = '&offset=' + (offset || 0);
		rating = '&rating=' + (rating || 'g');
		query = query && endpoint === 'search' ? '&q=' + query : '';

		return '' + baseUrl + limit + offset + rating + query;
	},

	/**
  * @method createProxyUrl
  * @summary builds proxy url
  * @description passes the request url to build
  * a proxy url
  * @returns {String}
  * @see createRequestUrl
  */
	createProxyUrl: function createProxyUrl(url) {
		return 'https://proxy.buildfire.com/hop?url=' + encodeURIComponent(url);
	},
	/**
  * @method get
  * @summary Queries the gif API.
  * @description Can be used to query the
  * gif API independently of the gif dialog.
  * Valid enpoints are defined here
  *
  * @param {String} endpoint
  * gif API endpoint to query. Valid endpoints
  * are defined in createRequestUrl,
  * and must be updated if additional
  * endpoints are added.
  *
  * @param {Object} options
  * if callback is passed here,
  * options are set to default.
  * the following options are availible
  * to this method:
  * @param {String} options.query
  * search query
  * @param {String} options.rating
  * limits results to a given rating
  * @param {Number} options.limit
  * limits number if results
  * @param {Number} options.offset
  * skips results
  * @param {Function} callback
  * can be passed as options parameter
  */
	get: function get(endpoint, options, callback) {
		var _this4 = this;

		var validEndpoints = ['trending', 'search', 'random'];

		if (!endpoint || !validEndpoints.includes(endpoint)) {
			return callback(new Error('invalid endpoint'), null);
		}
		if (typeof options == 'function') {
			if (!callback) callback = options;
			options = {};
		}

		var _ref4 = options || {},
		    limit = _ref4.limit,
		    offset = _ref4.offset,
		    rating = _ref4.rating,
		    query = _ref4.query;

		var requestOptions = {
			key: this.apiKey,
			endpoint: endpoint,
			limit: limit,
			offset: offset,
			rating: rating,
			query: query
		};

		var url = this.createRequestUrl(requestOptions);
		url = this.createProxyUrl(url);

		fetch(url).then(function (response) {
			return response.json();
		})
		// standardize and return results
		.then(function (gifs) {
			return _this4.digest(gifs, callback);
		})
		// catch errors
		.catch(function (error) {
			if (callback) callback(error, null);else console.error(error);
		});
	},

	/**
  * @method digest
  * @summary handles API response.
  * @description standardizes and consumes the
  * api response. If used internally, sorts gif responses
  * into pages to be loaded later and loads the
  * first page
  * @param {Object} response
  * raw response from the api
  * @param {Function} callback
  * if callback is passed, call
  * with standardized results
  * and return
  */
	digest: function digest(response, callback) {
		var gifs = this.convertGifs(response.data);

		if (callback) {
			return callback(null, gifs);
		}

		this.gifResults.innerHTML = '';
		this.pages = [];

		var pages = [];

		while (gifs.length) {
			var page = [];

			if (gifs.length > 24) {
				page = gifs.splice(0, 24);
			} else {
				page = gifs.splice(0, gifs.length);
			}

			pages.push(page);
		}

		this.pages = pages;
		this.loadPage();
	},

	/**
  * @method convertGifs
  * @summary formats gif responses.
  * @description takes an array of gifs and converts it
  * to a common format. If provider(s) are
  * added or changed, this method should
  * be altered to conform to the standard.
  * @param {Array} gifs
  * array of gifs
  * @returns {Array} of standardized gifs
  */
	convertGifs: function convertGifs(gifs) {
		if (!gifs) return [];
		if (gifs.id) gifs = [gifs];
		return gifs.map(function (gif) {
			var id = gif.id,
			    title = gif.title,
			    rating = gif.rating,
			    user = gif.user;
			var _gif$images = gif.images,
			    preview = _gif$images.preview,
			    preview_gif = _gif$images.preview_gif,
			    original = _gif$images.original,
			    downsized_large = _gif$images.downsized_large,
			    downsized_medium = _gif$images.downsized_medium,
			    downsized_small = _gif$images.downsized_small,
			    downsized_still = _gif$images.downsized_still,
			    original_still = _gif$images.original_still,
			    fixed_height = _gif$images.fixed_height;


			return {
				id: id,
				title: title,
				rating: rating,
				user: user,
				images: {
					preview: preview,
					preview_gif: preview_gif,
					original: original,
					downsized_large: downsized_large,
					downsized_medium: downsized_medium,
					downsized_small: downsized_small,
					downsized_still: downsized_still,
					original_still: original_still,
					fixed_height: fixed_height
				}
			};
		});
	},

	/**
  * @method loadPage
  * @summary renders pages of gifs.
  * @description checks if the next page should
  * load. If so, consumes the next
  * page and renders it
  */
	loadPage: function loadPage() {
		if (this.pages.length < 1) return;

		var _gifResults = this.gifResults,
		    scrollHeight = _gifResults.scrollHeight,
		    scrollTop = _gifResults.scrollTop,
		    clientHeight = _gifResults.clientHeight;


		if (scrollHeight - scrollTop <= clientHeight * 1.75) {
			var page = this.pages.splice(0, 1)[0];

			this.renderPage(page);
		}
	},

	/**
  * @method renderPage
  * @summary renders the next page
  * @description takes an array of gifs and renders
  * them in the results
  * @param {Array} gifs
  */
	renderPage: function renderPage(gifs) {
		var _this5 = this;

		if (!gifs || !gifs.length) return;

		var isIOS = bfUtils.isIOS;

		var getMP4 = function getMP4(gif) {
			if (!isIOS) {
				if (gif.images.downsized_medium && gif.images.downsized_medium.url) {
					return gif.images.downsized_medium.url;
				}
				if (gif.images.original && gif.images.original.url) {
					return gif.images.original.url;
				}
				return null;
			}

			if (gif.images.preview && gif.images.preview.mp4) {
				return gif.images.preview.mp4;
			}
			if (gif.images.downsized_small && gif.images.downsized_small.mp4) {
				return gif.images.downsized_small.mp4;
			}
			if (gif.images.original && gif.images.original.mp4) {
				return gif.images.original.mp4;
			}
			return null;
		};

		gifs.forEach(function (gif) {
			var mp4 = getMP4(gif);
			if (!mp4) return;

			var container = document.createElement('div');
			container.className = 'gif-container lazy-img';
			container.id = 'gif_' + gif.id;
			container.setAttribute('data-src', mp4);
			container.onclick = function (e) {
				return _this5.selectGif(e, gif);
			};

			var check = document.createElement('span');
			container.appendChild(check);

			var thumbnail = document.createElement('div');
			thumbnail.className = 'gif-thumbnail';
			container.appendChild(thumbnail);

			_this5.gifResults.appendChild(container);
		});

		this.lazyLoad.processLazyImages();
	},

	/**
  * @method selectGif
  * @summary selects a GIF
  * @description selects or deselects a gif.
  * Unless multiple gifs are
  * allowed, deslects other gifs
  * @param {Event} e click event
  * @param {Object} gif gif object
  */
	selectGif: function selectGif(e, gif) {
		e.target.classList.add('selected');

		this.results = [gif];
		if (this.handleClose) this.handleClose(false);
	},

	/**
  * @method getTrending
  * @summary loads trending gifs
  * @description calls get on the trending
  * endpoint and renders the results
  * @see get
  */
	getTrending: function getTrending() {
		this.get('trending', this.options);
	},

	/**
  * @method search
  * @summary handles search submits
  * @description sets options.query and
  * calls get on the search endpoint
  * and renders the results. If there is no
  * query, gets trending gifs.
  * @see get
  */
	search: function search() {
		gifAPI.options.query = gifAPI.gifSearchInput.value || '';

		if (gifAPI.options.query) {
			gifAPI.get('search', gifAPI.options);
		} else {
			gifAPI.get('trending', gifAPI.options);
		}
	},

	lazyLoad: {
		process: function process(element) {
			if (!element.hasAttribute('data-src')) return;

			var image = element.querySelectorAll('.gif-thumbnail')[0];
			if (!image) return;

			image.style.backgroundImage = this.isInViewport(element) ? 'url(' + element.getAttribute('data-src') + ')' : 'unset';
		},
		isInViewport: function isInViewport(element) {
			var _window = window,
			    innerHeight = _window.innerHeight;

			var _element$getBoundingC = element.getBoundingClientRect(),
			    top = _element$getBoundingC.top;

			var ratio = 1.25;

			return top > innerHeight * -Math.abs(ratio) && innerHeight * ratio > top;
		},

		/**
   * @property {Function} lazyLoad.processLazyImages
   * @summary lazyloads images
   * @description queries the document for lazy images
   * that haven't been loaded yet. Loops through results
   * and inserts the image
   */
		processLazyImages: function processLazyImages() {
			var _this6 = this;

			document.querySelectorAll('.lazy-img').forEach(function (img) {
				return _this6.process(img);
			});
		}
	}
};

setTimeout(function () {
	if (!gifAPI.initialized) gifAPI.init();
}, 5000);
'use strict';

var bookmarkAPI = {

  /**
   * Add a bookmark
   * @param {Object}   options  Bookmark options
   * @param {Function} callback Results callback
   */
  add: function add(options, callback) {
    var pluginInstanceId = window.appContext && window.appContext.currentPlugin ? window.appContext.currentPlugin.instanceId : window.postMaster.launcherPluginAPI.context.instanceId;
    var getCurrentUser = authAPI.getCurrentUser();
    var userId = getCurrentUser ? getCurrentUser._id : 'guest';

    var key = userId + '.bookmarks';
    var bookmarks = localStorage.getItem(key) ? JSON.parse(localStorage.getItem(key)) : [];

    // set bookmark meta data
    options.id = options.id || options.title;
    options.pluginInstanceId = pluginInstanceId;

    // check if we already have an exisin item with that id
    var index = bookmarks.findIndex(function (n) {
      var sameId = n.id === options.id;
      var sameInstance = n.pluginInstanceId === options.pluginInstanceId;
      return sameId && sameInstance;
    });

    // Update or insert
    if (index >= 0) {
      bookmarks[index] = options;
    } else {
      bookmarks.push(options);
    }

    // Save the plugin list
    localStorage.setItem(key, JSON.stringify(bookmarks));
    callback(null, options);
  },


  /**
   * Delete a bookmark matching the id
   * @param  {Mixed}   key      The key to find in title or id
   * @param  {Function} callback Results callback
   */
  delete: function _delete(id, callback) {
    var getCurrentUser = authAPI.getCurrentUser();
    var userId = getCurrentUser ? getCurrentUser._id : 'guest';

    var key = userId + '.bookmarks';
    var bookmarks = localStorage.getItem(key) ? JSON.parse(localStorage.getItem(key)) : [];

    // Get index and splice if exists
    var index = bookmarks.findIndex(function (item) {
      return item.id === id;
    });
    if (index >= 0) bookmarks.splice(index, 1);

    localStorage.setItem(key, JSON.stringify(bookmarks));

    if (callback) callback(null, bookmarks);
  },


  /**
   * Delete a bookmark matching the key and plugin contex
   * @param  {[type]}   key      [description]
   * @param  {Function} callback [description]
   * @return {[type]}            [description]
   */
  deleteFromPlugin: function deleteFromPlugin(id, callback) {
    var getCurrentUser = authAPI.getCurrentUser();
    var userId = getCurrentUser ? getCurrentUser._id : 'guest';

    var key = userId + '.bookmarks';
    var bookmarks = localStorage.getItem(key) ? JSON.parse(localStorage.getItem(key)) : [];

    var index = bookmarks.findIndex(function (item) {
      return item.id === id;
    });
    // Get index and splice if exists
    if (index >= 0) bookmarks.splice(index, 1);

    localStorage.setItem(key, JSON.stringify(bookmarks));

    callback(null, null);
  },


  /**
   * Get the list of all bookmarks matching the user contet
   * @param  {Function} callback Results callback
   */
  getAll: function getAll(callback) {
    var getCurrentUser = authAPI.getCurrentUser();
    var userId = getCurrentUser ? getCurrentUser._id : 'guest';

    var key = userId + '.bookmarks';
    var bookmarks = localStorage.getItem(key) ? JSON.parse(localStorage.getItem(key)) : [];

    callback(null, bookmarks);
  },


  /**
   * Get the list of all bookmarks matching the user and plugin context
   * @param  {Function} callback Results callback
   */
  getAllFromPlugin: function getAllFromPlugin(options, callback) {
    var getCurrentUser = authAPI.getCurrentUser();
    var userId = getCurrentUser ? getCurrentUser._id : 'guest';
    var pluginInstanceId = window.appContext && window.appContext.currentPlugin ? window.appContext.currentPlugin.instanceId : window.postMaster.launcherPluginAPI.context.instanceId;

    var key = userId + '.bookmarks';
    var bookmarks = localStorage.getItem(key) ? JSON.parse(localStorage.getItem(key)) : [];

    // Filter out only the ones that belong to the plugin
    var pluginBookmarks = bookmarks.filter(function (item) {
      return item.pluginInstanceId === pluginInstanceId;
    });

    callback(null, pluginBookmarks);
  }
};
'use strict';

$app.controller('authCtrl', ['$rootScope', '$scope', 'Upload', '$sce', function ($rootScope, $scope, Upload, $sce) {

    $scope._appRoot = window._appRoot;

    $scope.registerClick = false;

    var userLoginDomainSettingsAccess = undefined;
    if (window.appContext.currentApp && window.appContext.currentApp.config) {
        if (typeof window.appContext.currentApp.config.userLoginDomainSettings == 'undefined') {
            if (window.appContext.currentApp.config.type == "enterprise") {
                userLoginDomainSettingsAccess = 'enabled';
            }
        } else {
            userLoginDomainSettingsAccess = window.appContext.currentApp.config.userLoginDomainSettings;
        }
    }

    var domainSuffix;

    var passwordAtLeast8ComplexChars = 'Password must be at least 8 characters long, contains an upper case letter, a lower case letter, a number and a symbol.';
    $scope.loginTranslation = 'Log In';
    $scope.registerTranslation = 'Register';
    $scope.emailDoesNotExistTxt = "Email does not exist in system.";

    $scope.updateLoginTranslations = function (data) {
        if (data['passwordAtLeast8ComplexChars']) passwordAtLeast8ComplexChars = data['passwordAtLeast8ComplexChars'];

        if (data['loginTranslation']) $scope.loginTranslation = data['loginTranslation'];

        if (data['registerTranslation']) $scope.registerTranslation = data['registerTranslation'];

        if (data['emailDoesNotExist']) $scope.emailDoesNotExistTxt = data['emailDoesNotExist'];
    };

    var getCustomRegistrationSettings = function getCustomRegistrationSettings() {
        var tagName = 'appearance',
            context = {
            appId: window.appContext.currentApp.appId,
            pluginId: tagName,
            instanceId: tagName
        };

        var dsAppearance = new window.DatastoreAPI(context);

        dsAppearance.get({ tag: tagName, withDynamicData: true }, function (err, result) {
            if (err) {
                console.error(err);
                callback(err);
                return;
            }
            if (result && result.data && result.data.customRegistration) {
                buildCustomRegistration(result.data.customRegistration);
            }

            if (result && result.data && result.data) {
                $scope.setThemeType(result.data);
            }
        });
    };

    getCustomRegistrationSettings();

    var buildCustomRegistration = function buildCustomRegistration(customRegistrationSettings, callback) {
        if (customRegistrationSettings && customRegistrationSettings.active && window.appContext.currentApp.config.type === "enterprise") {
            customRegistration.getFields({
                customRegistrationSettings: customRegistrationSettings,
                refreshUI: function refreshUI() {
                    if (!$scope.$$phase) $scope.$apply();
                },
                openGDPRContent: function openGDPRContent(options) {
                    $scope.loadGDPR(options.key, options.defaultContentKey, options.defaultContentLabel);
                }
            }, function (err, result) {
                if (result) {
                    $scope.showCustomRegistration = true;
                    $scope.showDefaultTermsAndConditions = true;
                    $scope.showDefaultPrivacyPolicy = true;
                    var customTermsAndConditionsKey = null;
                    var customPrivacyPolicyKey = null;
                    if (result.gdprLinks) {
                        result.gdprLinks.forEach(function (link) {
                            if (link.name === "termsAndConditions") {
                                $scope.showDefaultTermsAndConditions = false;
                                customTermsAndConditionsKey = link.key;
                            } else if (link.name === "privacyPolicy") {
                                $scope.showDefaultPrivacyPolicy = false;
                                customPrivacyPolicyKey = link.key;
                            }
                        });
                    }
                    $scope.customRegistrationSubmit = function () {
                        result.fetch({
                            validateFields: true,
                            validateLinks: true
                        }, function (err, registration) {
                            if (!err) {
                                registration.customTermsAndConditionsKey = customTermsAndConditionsKey;
                                registration.customPrivacyPolicyKey = customPrivacyPolicyKey;
                                $scope.register(registration);
                            }
                        });
                    };
                    $scope.customRegistrationFields = result.fields;
                    $scope.customRegistrationRules = result.rules;
                    $scope.customRegistrationGdprLinks = result.gdprLinks;
                    $scope.initCustomRegistration = function () {
                        result.initializers.forEach(function (initializer) {
                            initializer();
                        });
                    };
                    if (callback) callback(null, null);
                    if (!$scope.$$phase) $scope.$apply();
                }
            });
        } else {
            $scope.showCustomRegistration = false;
            if (!$scope.$$phase) $scope.$apply();
        }
    };

    var showMenu = true;

    function shouldShowAppTerms() {
        if (appContext.currentApp && appContext.currentApp.config && appContext.currentApp.config.TermsOfUse) {
            return appContext.currentApp.config.TermsOfUse.indexOf('appdocumentation.com') < 0 && appContext.currentApp.config.TermsOfUse.indexOf('buildfire.com') < 0;
        } else {
            return false;
        }
    }

    //set authAPI the Ctrl
    window.authAPI.authCtrlScope = $scope;
    $rootScope.allowCancel = typeof $rootScope.allowCancel == 'undefined' ? true : $rootScope.allowCancel;
    $rootScope.authShown = false;

    $scope.secretCodeProvider = null;
    $scope.refWindow = null;
    $scope.errors = {};
    $scope.invalidCredentials = false;
    $scope.invalidReset = false;
    $scope.invalidRegister = false;
    $scope.msgError = null;
    $scope.msgSuccess = null;
    $scope.enableFacebook = true;
    $scope.enableTwitter = true;
    $scope.enableGoogle = true;
    $scope.enableApple = true;

    //$scope.email = '';
    $scope.password = '';
    $scope.userObj = { username: "",
        email: "" };

    $scope.loginCallback = null;
    var accessTokenAPI = "";
    var loginAPI = "";
    var resetPasswordAPI = "";
    var resetPasswordMessage = "";
    var registerUrl = "";
    var signOnStrategy = "";
    var clientId = "";
    var clientSecret = "";
    var contentType = "";
    var appId = window.appContext.currentApp.appId;
    var datastoreKey = window.appContext.currentApp.keys.datastoreKey;

    var context = {
        appId: appId,
        pluginId: 'authSettings',
        instanceId: 'authSettings',
        liveMode: window.appContext.liveMode,
        writeKey: datastoreKey
    };

    $scope.updateLoginCss = function () {
        updateLoginCss();
    };

    function updateLoginCss(customUISettings) {
        if (customUISettings) {
            customUISettings = window.loginUI.convertToCss(customUISettings) || '*{}';
            localStorage.loginUI = customUISettings;
        }

        var loginUI = customUISettings || localStorage.getItem('loginUI_' + appId);

        // Add custom css
        var styleTag = document.getElementById('custom-login-ui');

        // Create a new style tag if we don't  have it yet
        if (!styleTag) {
            var loginHolder = document.getElementsByClassName('login-holder')[0];
            styleTag = document.createElement('style');
            styleTag.id = 'custom-login-ui';
            loginHolder.appendChild(styleTag);
        }

        styleTag.innerHTML = loginUI;
    }

    $scope.updateSSORegistrationFormStatus = function (status) {
        if (!/htt(p|ps):\/\//g.test(frmExternalRegistrationForm.src)) return;
        if (window.spinner) {
            window.spinner.hide();
        }
        $scope.ssoRegistrationFormStatus = status;
        if (!$scope.$$phase) $scope.$apply();
    };

    updateLoginCss();

    var ds = new DatastoreAPI(context);

    function checkBoolDefaultTrue(value) {
        var result = typeof value === 'boolean' ? value : true;

        return result;
    }

    $scope.SSOLogin = false;
    ds.get({ tag: 'authSettings' }, handleAuthSettings);
    function handleAuthSettings(err, result) {
        if (err) {
            console.error(err);
        } else {
            if (result && result.data) {
                if (result.data.signOnStrategy == "SSOLogin") {
                    $scope.SSOLogin = true;
                    contentType = result.data.contentType;
                    if (contentType == "application/x-www-form-urlencoded" || contentType == "multipart/form-data") {
                        //put the hop in front to work around CORS
                        accessTokenAPI = window.siteConfig.endPoints.hopHost + result.data.accessTokenAPI;
                        loginAPI = window.siteConfig.endPoints.hopHost + result.data.loginAPI;
                    } else {
                        //backwards compatible
                        accessTokenAPI = result.data.accessTokenAPI;
                        loginAPI = result.data.loginAPI;
                    }

                    //able to disable FB and twitter even if they don't have SSO enabled.
                    $scope.enableFacebook = result.data.enableFacebook;
                    $scope.enableTwitter = result.data.enableTwitter;
                    $scope.enableGoogle = result.data.enableGoogle;
                    //if the app owner disabled twitter and facebook, and did nothing for apple then we will assume that app owner don't apple as well.
                    if (!$scope.enableFacebook && !$scope.enableTwitter && typeof result.data.enableApple == "undefined") {
                        $scope.enableApple = false;
                    } else {
                        $scope.enableApple = result.data.enableApple;
                    }

                    $scope.signOnStrategy = signOnStrategy = result.data.signOnStrategy;
                    resetPasswordAPI = result.data.resetPasswordAPI;
                    resetPasswordMessage = result.data.resetPasswordMessage;
                    $scope.registerUrl = registerUrl = result.data.registerUrl;
                    clientId = result.data.clientId;
                    clientSecret = result.data.clientSecret;

                    setInterval(checkToken, 1000 * 60 * 15); //check SSO 15 minutes - to make sure user token isn't expired or revoked.
                }
                //able to disable FB and twitter even if they don't have SSO enabled.
                $scope.enableFacebook = checkBoolDefaultTrue(result.data.enableFacebook);
                $scope.enableTwitter = checkBoolDefaultTrue(result.data.enableTwitter);
                $scope.enableGoogle = checkBoolDefaultTrue(result.data.enableGoogle);
                //if the app owner disabled twitter and facebook, and did nothing for apple then we will assume that app owner don't apple as well.
                if (!$scope.enableFacebook && !$scope.enableTwitter && typeof result.data.enableApple == "undefined") {
                    $scope.enableApple = false;
                } else {
                    $scope.enableApple = checkBoolDefaultTrue(result.data.enableApple);
                }
                signOnStrategy = result.data.signOnStrategy;

                if (userLoginDomainSettingsAccess == 'enabled') {
                    domainSuffix = result.data.domain;
                }
                $scope.emailInputType = domainSuffix ? 'text' : 'email';
            } else {
                $scope.enableFacebook = true;
                $scope.enableTwitter = true;
                $scope.enableGoogle = true;
                $scope.enableApple = true;
            }
        }
    }

    function checkToken() {
        var ssoUserObj = JSON.parse(window.localStorage.getItem("SSO_USER"));
        if (ssoUserObj) {
            var dateNow = new Date().getTime() / 1000;
            if (dateNow > ssoUserObj.ssoExpiresAt) {
                // is the token expired?
                $scope.invalidCredentials = true;

                $rootScope.allowCancel = false;
                $rootScope.showMenu = false;
                //authAPI.login({}, null);
                $scope.showLogin(function (err, result) {
                    authAPI._setCurrentUser(result);

                    authAPI.triggerOnLogin(result);

                    $rootScope.allowCancel = true;
                    $rootScope.showMenu = true;
                    $scope.hideLogin();
                    if (!$scope.$$phase) $scope.$apply();
                });
            }
            var testAPI = accessTokenAPI;
            if (contentType == "multipart/form-data" || contentType == "application/x-www-form-urlencoded") {
                var headerObj = {
                    headers: {
                        'Authorization': "Bearer " + ssoUserObj.ssoUserToken,
                        'Content-Type': 'application/json'
                    }
                };
            } else {
                var headerObj = { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } };
                testAPI = accessTokenAPI + "?access_token=" + ssoUserObj.ssoUserToken;
            }
            window.bfUtils.http.get(testAPI, headerObj) //go to the profile to see if the token is still good.
            .success(function (result) {
                console.log(result);
            }).error(function (data, status, headers, config) {
                $scope.invalidCredentials = true;

                $rootScope.allowCancel = false;
                $rootScope.showMenu = false;
                $scope.showLogin(function (err, result) {
                    authAPI._setCurrentUser(result);
                    authAPI.triggerOnLogin(result);
                    $rootScope.allowCancel = true;
                    $rootScope.showMenu = true;
                    $scope.hideLogin();
                    if (!$scope.$$phase) $scope.$apply();
                });
            });
        }
    }

    $scope.closeLogin = function () {
        if ($scope.loginCallback) $scope.loginCallback();
        if ($rootScope.allowCancel) $scope.hideLogin();else resetLogin();
    };

    $scope.reset = function () {
        $scope.errors = {};
        $scope.showProgressMessage = false;
        $scope.invalidCredentials = false;
        $scope.invalidReset = false;
        $scope.invalidRegister = false;
        $scope.allowToRegister = false;
        $scope.uploadFile = null;

        $scope.userObj.email = null;
        $scope.userObj.username = null;
        $scope.password = null;
        $scope.secretCode = null;
        $scope.newPassword = null;
        $scope.confirmPassword = null;
        $scope.msgError = null;
        $scope.msgSuccess = null;
        $scope.uploadFile = null;
        $scope.firstName = null;
        $scope.lastName = null;

        $scope.secretCodeProvider = null;
        $scope.refWindow = null;

        $scope.acceptTOS = null;
        $scope.acceptPP = null;
        $scope.acceptedAppTerms = null;

        if ($scope.customRegistrationGdprLinks) {
            $scope.customRegistrationGdprLinks.forEach(function (link) {
                link.value = undefined;
                link.error = undefined;
            });
        }
        if ($scope.customRegistrationFields) {
            $scope.customRegistrationFields.forEach(function (field) {
                field.value = undefined;
                field.error = undefined;
            });
        }
    };

    var hideForms = function hideForms() {
        $scope.successShown = false;
        $scope.registrationShown = false;
        $scope.loginShown = false;
        $scope.forgetPasswordShown = false;
        $scope.resetPasswordShown = false;

        resetExternalRegisterForm();
    };
    hideForms();

    $scope.openTermsAndConditions = function () {
        window.open('https://support.appdocumentation.com/terms/', '_system');
        return false;
    };

    $scope.registerUser = function () {
        $scope.registerClick = true;

        if ($scope.frmAuthRegister.$invalid) {
            return;
        }

        //Add logic here
        var isPasswordValid = window.validator.validatePassword($scope.password);

        if (!isPasswordValid) {
            var options = {
                data: {
                    title: ' ',
                    body: passwordAtLeast8ComplexChars,
                    disableCancel: true
                }
            };

            window.openDialog(options, function () {});

            return;
        }

        $scope.register();
        $scope.registerClick = false;
    };

    $scope.hideLogin = function () {
        $scope.reset();

        hideForms();
        $rootScope.authShown = false;
        $scope.loginCallback = null;
    };
    var frmExternalRegistrationForm = document.getElementById('frmExternalRegistrationForm');
    function resetExternalRegisterForm() {
        frmExternalRegistrationForm = frmExternalRegistrationForm || document.getElementById('frmExternalRegistrationForm');
        frmExternalRegistrationForm.src = '';
        $scope.externalRegister = false;
        $scope.ssoRegistrationFormStatus = null;
    }

    $scope.showRegistration = function (obj, callback) {
        $scope.scrolling = bfUtils.isIOS ? 'no' : 'auto';
        if (signOnStrategy == "SSOLogin" && registerUrl) {
            var receiveMessage = function receiveMessage(event) {
                if (event && registerUrl.indexOf(event.origin) > -1) {
                    if (event.data) {
                        var response = null;
                        try {
                            response = JSON.parse(event.data);
                        } catch (e) {}
                        if (response) {
                            if (response.status === 'success') {
                                if (response.user && response.user.username) {
                                    $scope.userObj.username = response.user.username;
                                }
                                if (window.spinner && window.spinner.show) {
                                    window.spinner.show(true);
                                }
                                authSSOLogin(response.user, function (err, result) {
                                    if (err) {
                                        console.error(err);

                                        var options = {
                                            data: {
                                                title: ' ',
                                                body: 'Invalid Login',
                                                disableCancel: true
                                            }
                                        };

                                        window.openDialog(options, function () {});

                                        if (callback) callback(err, null);
                                    } else {
                                        if (!callback) callback = $scope.loginCallback;
                                        if (callback) callback(null, result);
                                    }
                                    if (window.spinner && window.spinner.hide) {
                                        window.spinner.hide(true);
                                    }
                                });
                            }
                            window.removeEventListener("message", receiveMessage, false);
                            frmExternalRegistrationForm.src = '';
                            $scope.externalRegister = false;
                            $scope.ssoRegistrationFormStatus = null;
                            if (!$scope.$$phase) $scope.$apply();
                        }
                    }
                }
            };

            window.spinner.show();
            $scope.externalRegister = true;
            $scope.ssoRegistrationFormStatus = 'loading';
            frmExternalRegistrationForm = frmExternalRegistrationForm || document.getElementById('frmExternalRegistrationForm');
            frmExternalRegistrationForm.src = registerUrl;

            window.addEventListener("message", receiveMessage, false);
        } else {
            $scope.reset();

            hideForms();
            $scope.registrationShown = true;
            $rootScope.authShown = true;
        }
    };

    $scope.showForgetPassword = function () {
        $scope.reset();

        hideForms();
        $scope.forgetPasswordShown = true;
        $rootScope.authShown = true;
    };

    $scope.showSuccess = function (msg) {
        hideForms();
        $scope.msgSuccess = msg;
        $scope.successShown = true;
    };

    $scope.showResetPassword = function (callback) {
        $scope.reset();

        hideForms();
        $scope.resetPasswordShown = true;
        $rootScope.authShown = true;
        $scope.loginCallback = callback;
    };

    function resetLogin() {
        $scope.reset();

        hideForms();
        $rootScope.allowCancel = !$scope.loginOptions || $scope.loginOptions.allowCancel !== false;
        $rootScope.showMenuOnAuth = !$scope.loginOptions || $scope.loginOptions.showMenu !== false;
        $scope.loginShown = true;
        $rootScope.authShown = true;
        if (!$scope.$$phase) $scope.$apply();
    }

    $scope.updateLogin = function (loginUISettings) {

        if (loginUISettings && loginUISettings != "SSOForgetPassword") {
            updateLoginCss(loginUISettings);
        }

        $scope.loginCallback = function (err, result) {
            if (result) {
                window.authAPI._setCurrentUser(result);
                window.authAPI.triggerOnLogin(result);
            } else {
                console.error('authCtrl loginCallback error', err);
            }

            $rootScope.allowCancel = true;
            $rootScope.showMenu = true;
            $scope.hideLogin();
            if (!$scope.$$phase) $scope.$apply();
        };
        resetLogin();

        if (loginUISettings && loginUISettings == "SSOForgetPassword") {
            $scope.showForgetPassword();
            $scope.$apply();
        }

        //check if there is any changes on the appearance
        getCustomRegistrationSettings();
    };

    $scope.updateRegistration = function (customRegistrationSettings) {
        $scope.reset();
        hideForms();
        $scope.registrationShown = true;
        $rootScope.authShown = true;
        if (customRegistrationSettings) {
            buildCustomRegistration(customRegistrationSettings, function () {
                $scope.initCustomRegistration();
            });
        }
        if (!$scope.$$phase) $scope.$apply();
    };

    $scope.updateLoginAuth = function (options) {
        $scope.enableFacebook = checkBoolDefaultTrue(options.enableFacebook);
        $scope.enableTwitter = checkBoolDefaultTrue(options.enableTwitter);
        $scope.enableGoogle = checkBoolDefaultTrue(options.enableGoogle);
        $scope.enableApple = checkBoolDefaultTrue(options.enableApple);

        if (options.domain && userLoginDomainSettingsAccess == 'enabled') {
            domainSuffix = options.domain;
        }

        if (!$scope.$$phase) $scope.$apply();
    };

    $scope.returnToLogin = function () {
        $scope.showLogin($scope.loginCallback);
    };

    $scope.showLogin = function (callback) {
        $scope.loginCallback = callback;
        resetLogin();
    };

    $scope.resetPassword = function () {
        $scope.invalidReset = false;
        $scope.msgError = null;

        if ($scope.newPassword != $scope.confirmPassword) {
            $scope.invalidReset = false;
            $scope.msgError = 'Make sure new password and confirm password are equal';
            return;
        }

        var resetData = {
            email: $scope.email,
            "secretCode": $scope.secretCode,
            password: $scope.newPassword,
            passwordStrength: $scope.customRegistrationRules ? $scope.customRegistrationRules.passwordStrength : null,
            externalAppId: window.currentAppId

        };

        var data = {
            "id": 1, "method": "users/changePassword",
            "params": resetData
        };

        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
            if (result && result.result) {
                $scope.showSuccess('Password reset successfully');
                var options = {
                    data: {
                        title: ' ',
                        body: 'Password reset successfully',
                        disableCancel: true
                    }
                };

                window.openDialog(options, function () {});
            } else {
                if (result && result.error) {
                    var options = {
                        data: {
                            title: ' ',
                            body: result.error.message,
                            disableCancel: true
                        }
                    };

                    window.openDialog(options, function () {});
                    console.error(result.error);
                }
            }
        }).error(function (data, status, headers, config) {
            $scope.invalidCredentials = true;

            console.error(data);
            if (callback) callback(data, null);
        });
    };

    $scope.forgotPassword = function (obj) {
        if (signOnStrategy != "SSOLogin") {
            $scope.invalidCredentials = false;

            var resetData = {
                email: $scope.email, "sendSecretCode": true, externalAppId: window.currentAppId
            };
            if (obj) {
                resetData.email = obj.email;
            }

            var data = {
                "id": 1, "method": "users/forgotPassword",
                "params": resetData
            };

            var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

            window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
                if (result && result.result) {
                    $scope.showResetPassword();
                } else {
                    var options = {
                        data: {
                            title: ' ',
                            body: $scope.emailDoesNotExistTxt,
                            disableCancel: true
                        }
                    };

                    window.openDialog(options, function () {});

                    if (result) console.warn(result);
                }
            }).error(function (data, status, headers, config) {
                $scope.invalidCredentials = true;

                console.error(data);
            });
        } else {
            //this is SSO forgot password

            var queryStringChar = resetPasswordAPI.indexOf('?') === -1 ? "?" : "&",
                myResetPasswordAPI = resetPasswordAPI + queryStringChar + "email=" + $scope.email;

            window.bfUtils.http.get(myResetPasswordAPI, {
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
            }).success(function () {

                var options = {
                    data: {
                        title: ' ',
                        body: resetPasswordMessage || 'An email has been sent, please check your email.',
                        disableCancel: true
                    }
                };

                window.openDialog(options, function () {
                    $scope.showLogin(function (err, result) {
                        authAPI._setCurrentUser(result);

                        authAPI.triggerOnLogin(result);

                        $rootScope.allowCancel = true;
                        $rootScope.showMenu = true;
                        $scope.hideLogin();
                        if (!$scope.$$phase) $scope.$apply();
                    });
                });

                cpSync.SSO.log("Succeed...");
            }).error(function (data, status, headers, config) {
                if (data) console.error(data);
                if (bfUtils.isEmulatorCP) {
                    if (!data && status == "0") cpSync.SSO.log('Error while testing SSO Login , CORS policy ..');else {
                        if (status) cpSync.SSO.log('Error status:' + status);
                        if (data) cpSync.SSO.log('Error details:' + JSON.stringify(data));
                    }
                }
            });
        }
    };

    function buildfireLogin(obj, callback) {

        if (!window.appContext || !window.appContext.currentApp) {
            console.error('invalid appContext');
            return;
        }

        $scope.invalidCredentials = false;

        if (!callback) callback = $scope.loginCallback;

        var pushSDK = null;
        if (typeof push == 'undefined') pushSDK = {};else pushSDK = push;

        var email = $scope.userObj.email;
        if (!email) {
            email = obj.email;
        }
        if (!$scope.password) {
            $scope.password = obj.password;
        }

        if (userLoginDomainSettingsAccess == 'enabled' && domainSuffix && !email.includes("@")) {
            email = email + domainSuffix;
        }

        console.warn('email', email);

        var loginData = {
            email: email,
            password: $scope.password,
            deviceId: pushSDK.deviceId,
            osType: pushSDK.platform ? pushSDK.platform.toLowerCase() : 'web',
            externalAppId: window.appContext.currentApp.appId
        };
        if (obj) {
            loginData.email = obj.email;
            loginData.password = obj.password;
        }

        var data = {
            "id": 1, "method": "users/login",
            "params": loginData
        };

        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
            if (result && result.result && result.result.userToken) {

                authAPI._setCurrentUser(result.result);
                $rootScope.$broadcast('loginSuccessfully', result.result);
                if (callback) callback(null, result.result);
            } else {
                $scope.invalidCredentials = true;

                var error = null;
                if (result && result.error) {
                    console.warn('login error: ', result.error);
                    error = result.error;
                }
                if (error && error.message) $scope.msgError = error.message;else $scope.msgError = 'Invalid Email or Password';
                if (callback) callback(error, null);
            }
        }).error(function (data, status, headers, config) {
            $scope.invalidCredentials = true;

            console.error(data);
            if (callback) callback(data, null);
        });
    }

    function authSSOLogin(result, callback) {
        var ssoUserObj = JSON.parse(window.localStorage.getItem("SSO_USER"));
        if (!ssoUserObj) ssoUserObj = {};
        if (typeof result == "string") {
            try {
                result = JSON.parse(result);
            } catch (e) {
                console.warn('Unexpected parsing issue', e);
            }
        }
        if (result && result.access_token) {
            ssoUserObj.ssoUserToken = result.access_token; //save SSO token
        } else {
            ssoUserObj.ssoUserToken = result.replace(/["]+/g, '');
        }
        if (result && result.expires_in && result.issued_at) {
            ssoUserObj.ssoExpiresAt = result.issued_at + result.expires_in;
        } else {
            ssoUserObj.ssoExpiresAt = 1902608081000; //if they do not send expiration info, set 10 years in future.
        }

        window.localStorage.setItem("SSO_USER", JSON.stringify(ssoUserObj));

        var pushSDK = null;
        if (typeof push == 'undefined') pushSDK = {};else pushSDK = push;

        //strip out the hop if it is there
        var passedAccessTokenAPI = accessTokenAPI.replace(window.siteConfig.endPoints.hopHost, "");

        var loginData = {
            accessToken: ssoUserObj.ssoUserToken,
            accessTokenAPI: passedAccessTokenAPI,
            deviceId: pushSDK.deviceId,
            osType: pushSDK.platform ? pushSDK.platform.toLowerCase() : 'web',
            externalAppId: window.appContext.currentApp.appId,
            loginProviderType: 'SSO',
            email: $scope.userObj.username,
            contentType: contentType
        };
        var data = {
            "id": 1, "method": "users/loginSSO",
            "params": loginData
        };

        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
            if (result && result.result) {
                authAPI._setCurrentUser(result.result);
                $rootScope.$broadcast('loginSuccessfully', result.result);
                callback(null, result.result);

                if (bfUtils.isEmulatorCP) cpSync.SSO.log("Succeed...");
            } else {
                $scope.invalidRegister = true;

                var error = null;
                if (result && result.error) {
                    $scope.msgError = result.error.message;
                    $scope.invalidCredentials = true;
                    console.error(result.error);

                    if (bfUtils.isEmulatorCP) cpSync.SSO.log(result.error);
                } else {
                    if (result = "Could not retrieve profile info.") {
                        $scope.msgError = result;
                        $scope.invalidCredentials = true;
                        console.error(result);

                        if (bfUtils.isEmulatorCP) cpSync.SSO.log(result);
                    }
                }
            }
        }).error(function (data, status, headers, config) {
            console.error(data);
            if (callback) callback(data, null);

            if (bfUtils.isEmulatorCP) cpSync.SSO.log('Error while testing SSO Login..');
        });
    }

    function SSOLogin(obj, callback) {
        var options = { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } };
        var email = $scope.userObj.username;

        if (userLoginDomainSettingsAccess == 'enabled' && domainSuffix && !email.includes("@")) {
            email = email + domainSuffix;
        }

        if (contentType == "application/x-www-form-urlencoded") {
            var loginObj = encodeURIComponent("grant_type") + "=" + encodeURIComponent("password") + "&" + encodeURIComponent("username") + "=" + encodeURIComponent(email) + "&" + encodeURIComponent("password") + "=" + encodeURIComponent($scope.password) + "&" + encodeURIComponent("client_id") + "=" + encodeURIComponent(clientId) + "&" + encodeURIComponent("client_secret") + "=" + encodeURIComponent(clientSecret);
        } else if (contentType == "multipart/form-data") {
            options = { transformRequest: angular.identity, headers: { 'Content-Type': undefined } };
            var loginObj = new FormData();
            loginObj.append('username', email);
            loginObj.append('password', $scope.password);
        } else {
            var loginObj = {
                grant_type: "password",
                username: email,
                password: $scope.password,
                client_id: clientId
            };
        }
        window.bfUtils.http.post(loginAPI, loginObj, options).success(function (result) {
            authSSOLogin(result, callback);
        }).error(function (data, status, headers, config) {
            $scope.invalidCredentials = true;

            if (data && data.error_description) {
                console.error(data);
                $scope.msgError = data.error_description;
            } else $scope.msgError = "Login Failed";

            if (callback) callback("Login Failed", null);

            if (bfUtils.isEmulatorCP) {
                if (!data && status == "0") cpSync.SSO.log('Error while testing SSO Login , CORS policy ..');else {
                    if (status) cpSync.SSO.log('Error status:' + status);
                    if (data) cpSync.SSO.log('Error details:' + JSON.stringify(data));
                }
            }
        });
    }

    $scope.showBackLogin = function () {
        authAPI.login();
    };

    $scope.login = function (obj, callback) {
        if (window.spinner && window.spinner.show) {
            window.spinner.show(true);
        }

        if (signOnStrategy != "SSOLogin") {
            buildfireLogin(obj, function (err, result) {
                if (err || !result) {

                    var invalidLoginMessage = null;

                    if (err) {
                        switch (err.code) {
                            case 1303:
                                invalidLoginMessage = err.message; // user blocked. too many login attempts
                                break;
                            default:
                                invalidLoginMessage = "Invalid Login";
                        }
                    } else {
                        // no result returned
                        invalidLoginMessage = "To log in, please make sure you have a valid connection.";
                    }

                    var options = {
                        data: {
                            title: ' ',
                            body: invalidLoginMessage,
                            disableCancel: true
                        }
                    };

                    window.openDialog(options, function () {});

                    console.error(err);
                    if (callback) callback(err, null);
                } else {
                    if (!callback) callback = $scope.loginCallback;

                    if (callback) callback(null, result);
                }
                if (window.spinner && window.spinner.hide) {
                    window.spinner.hide(true);
                }
            });
        } else {
            SSOLogin(obj, function (err, result) {
                if (err) {
                    console.error(err);

                    var options = {
                        data: {
                            title: ' ',
                            body: 'Invalid Login',
                            disableCancel: true
                        }
                    };

                    window.openDialog(options, function () {});

                    if (callback) callback(err, null);
                } else {
                    if (!callback) callback = $scope.loginCallback;
                    callback(null, result);
                }
                if (window.spinner && window.spinner.hide) {
                    window.spinner.hide(true);
                }
            });
        }
    };

    var update = function update(userData, callback) {
        var data = {
            "id": 1, "method": "users/update",
            "params": userData
        };

        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
            if (result.error) {
                var error = null;
                if (result && result.error) {
                    console.error(result.error);
                    error = result.error;
                }
                if (callback) callback(error, null);
            } else {
                var currentUser = authAPI.getCurrentUser();
                if (currentUser != null) {
                    currentUser.firstName = userData.firstName;
                    currentUser.lastName = userData.lastName;
                    currentUser.displayName = userData.displayName;
                    currentUser.imageUrl = userData.imageUrl;
                    authAPI._setCurrentUser(currentUser);
                }
                if (callback) callback(null, currentUser);
            }
        }).error(function (data, status, headers, config) {
            console.error(data);
            if (callback) callback(data, null);
        });
    };

    $scope.getGDPR = function (options, callback) {
        var email = $scope.userObj.email;

        var url = siteConfig.endPoints.crmHost + "/documents/" + options.key + "/check?userKey=" + encodeURIComponent(email) + "&withDetails=true";

        bfUtils.http.get(url).success(function (result) {
            var content = {};
            content.title = $sce.trustAsHtml(result[options.key].title);
            content.subtitle = $sce.trustAsHtml(result[options.key].subtitle);
            content.details = $sce.trustAsHtml(result[options.key].details);
            content.defaultContentKey = options.defaultContentKey;
            content.defaultContentLabel = options.defaultContentLabel;
            callback(null, content);
        }).error(function (err) {
            console.error(err);
            callback(err, null);
        });
    };

    $scope.loadGDPR = function (key, defaultContentKey, defaultContentLabel) {
        $scope.getGDPR({ key: key, defaultContentKey: defaultContentKey, defaultContentLabel: defaultContentLabel }, function (err, gdprContent) {
            if (gdprContent) {
                $scope.GDPR_content = gdprContent;
                $scope.showGDPR = true;
                $rootScope.$broadcast('hideNav');
                if (!$scope.$$phase) $scope.$apply();
            }
        });
    };

    $scope.loadGDPR_Additional = function (key) {
        if (!$scope.GDPR_content_additional) {
            $scope.getGDPR({ key: key }, function (err, gdprContent) {
                if (gdprContent) {
                    $scope.GDPR_content_additional = gdprContent;
                    $scope.showGDPR_additional = true;
                    if (!$scope.$$phase) $scope.$apply();
                }
            });
        } else {
            $scope.showGDPR_additional = true;
        }
    };

    $scope.hideGDPR = function () {
        $rootScope.$broadcast('displayNav');

        $scope.showGDPR = false;
        $scope.showGDPR_additional = false;
        $scope.GDPR_content = null;
        $scope.GDPR_content_additional = null;
    };

    $scope.hideGDPR_additional = function () {
        $scope.showGDPR_additional = false;
    };

    $scope.showTermsOfService = function () {
        $scope.loadGDPR('bf_terms_and_conditions');
    };

    $scope.showPrivacyPolicy = function () {
        $scope.loadGDPR('bf_privacy_policy');
    };

    $scope.showAppTerms = function () {
        window.open(appContext.currentApp.config.TermsOfUse, '_system');
    };

    $scope.shouldShowAppTerms = shouldShowAppTerms();

    $scope.saveGDPR = function (options, saveGDPRCallback) {
        var termsConditionsKey = "bf_terms_and_conditions";
        var privacyPolicyKey = "bf_privacy_policy";

        var getInfo = function getInfo(callback) {
            window.$http.get("https://ipapi.co/json/").success(function (data) {
                if (data) {
                    var formattedData = {
                        ipInfo: {
                            city: data.city,
                            country: data.country_name,
                            countryCode: data.country,
                            lat: data.latitude,
                            lon: data.longitude,
                            regionName: data.region,
                            timezone: data.timezone,
                            zip: data.postal,
                            ip: data.ip
                        }
                    };
                    callback(null, formattedData);
                } else {
                    callback(null, null);
                }
            }).error(function (response) {
                callback(null, null);
            });
        };

        getInfo(function (err, data) {
            var info = {};
            if (data) info = data;
            info.appId = appContext.currentApp.appId;

            var acceptGDPR = function acceptGDPR(keys, callback) {
                if (keys) {
                    var acceptUrl = siteConfig.endPoints.crmHost + "/documents/" + keys + "/accept";
                    bfUtils.http.post(acceptUrl, {
                        userKey: options ? options.email.toLowerCase() : $scope.userObj.email.toLowerCase(),
                        info: info,
                        source: "app"
                    }).success(function (result) {
                        callback(null, result);
                    }).error(function (err) {
                        callback(err);
                        console.error(err);
                    });
                } else {
                    callback(null, null);
                }
            };

            var keys = [termsConditionsKey, privacyPolicyKey];
            if (options.customTermsAndConditionsKey) keys.push(options.customTermsAndConditionsKey);
            if (options.customPrivacyPolicyKey) keys.push(options.customPrivacyPolicyKey);

            acceptGDPR(keys.join(","), function () {
                if (saveGDPRCallback) saveGDPRCallback();
            });
        });
    };

    $scope.register = function (registerOptions, callback) {

        if (!window.appContext || !window.appContext.currentApp) {
            console.error('invalid appContext');
            return;
        }

        $scope.invalidRegister = false;

        if (!callback) callback = $scope.loginCallback;

        var pushSDK = null;
        if (typeof push == 'undefined') pushSDK = {};else pushSDK = push;

        var obj = registerOptions ? registerOptions.user : undefined;

        var regData = obj || {
            firstName: $scope.firstName || $scope.userObj.email,
            lastName: $scope.lastName || '',
            email: $scope.userObj.email,
            password: $scope.password
        };

        regData.deviceId = pushSDK.deviceId;
        regData.osType = pushSDK.platform ? pushSDK.platform.toLowerCase() : 'web';
        regData.passwordStrength = $scope.customRegistrationRules ? $scope.customRegistrationRules.passwordStrength : null;
        regData.externalAppId = window.appContext.currentApp.appId;

        var data = {
            "id": 1, "method": "users/register",
            "params": regData
        };

        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(angular.toJson(data));

        $scope.isRegistering = true;

        window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
            if (result && result.result) {
                var gdprOptions = { email: regData.email };
                if (registerOptions) {
                    gdprOptions.customTermsAndConditionsKey = registerOptions.customTermsAndConditionsKey;
                    gdprOptions.customPrivacyPolicyKey = registerOptions.customPrivacyPolicyKey;
                }
                $scope.saveGDPR(gdprOptions, function () {
                    $scope.login({ email: regData.email, password: regData.password }, function (err, result) {

                        if (regData.userProfile) {
                            userTags.setRegistrationTags(regData.userProfile, true, function (err, result) {
                                if (err) console.log(err);
                            });
                        }

                        if (result && result.userToken) {
                            $scope.upload($scope.uploadFile, function (err, result) {
                                if (err) {
                                    $scope.isRegistering = false;
                                    if (callback) callback(err, null);
                                } else {
                                    var currentUser = authAPI.getCurrentUser();
                                    if (result) {
                                        var userData = {
                                            userToken: currentUser.userToken,
                                            firstName: regData.firstName,
                                            lastName: regData.lastName,
                                            displayName: regData.firstName + ' ' + regData.lastName,
                                            imageUrl: result.result,
                                            externalAppId: window.currentAppId
                                        };

                                        update(userData, function (err, result) {
                                            $scope.isRegistering = false;
                                            if (callback) callback(err, result);
                                        });
                                    } else {
                                        $scope.isRegistering = false;
                                        if (callback) callback(null, currentUser);
                                    }
                                }
                            });
                            authAPI.trackRegister(result);
                        } else {
                            $scope.isRegistering = false;
                        }
                    });
                });
            } else {
                $scope.isRegistering = false;
                $scope.invalidRegister = true;

                var error = null;
                if (result && result.error) {
                    var message = result.error.message;
                    if (result.error.code === 1301 && registerOptions && registerOptions.messages && registerOptions.messages.emailAlreadyInUse) {
                        // email exists
                        message = registerOptions.messages.emailAlreadyInUse;
                    }

                    var options = {
                        data: {
                            title: ' ',
                            body: message,
                            disableCancel: true
                        }
                    };

                    window.openDialog(options, function () {});
                    console.warn(result.error);
                    error = result.error;
                }
            }
        }).error(function (data, status, headers, config) {
            console.error(data);
            $scope.isRegistering = false;
        });
    };

    $scope.upload = function (files, callback) {
        var currentUser = authAPI.getCurrentUser();
        if (currentUser != null) {
            var url = window.siteConfig.endPoints.authHost + "/src/server.js?method=users/uploadImage";
            if (files && files.length == 1) {
                var file = files[0];
                Upload.upload({
                    url: url,
                    fields: { 'userToken': currentUser.userToken, externalAppId: window.currentAppId },
                    file: file
                }).progress(function (evt) {
                    $scope.progressMessage = true;
                    var progressPercentage = parseInt(100.0 * evt.loaded / evt.total);
                    console.log('progress: ' + progressPercentage + '% ' + evt.config.file.name);
                }).success(function (data, status, headers, config) {
                    console.log('file ' + config.file.name + 'uploaded.');

                    if (callback) callback(null, data);
                }).error(function (err) {
                    $scope.msgError = '';
                    $scope.invalidRegister = true;

                    if (callback) callback(err, null);
                });
            } else {
                if (callback) callback(null, null);
            }
        } else {
            if (callback) callback({ message: "Invalid user" }, null);
        }
    };

    $scope.requestLoginProvider = function (loginProviderType) {
        var data = {
            "id": 1, "method": "secretCode/request",
            "params": { externalAppId: window.currentAppId }
        };
        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        if (!$scope.refWindow || $scope.refWindow.closed) {
            window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
                if (result != null && result.result != null && result.result.code) {
                    $scope.secretCodeProvider = result.result.code;

                    if (loginProviderType === "apple") {
                        $scope.refWindow = window.open(window.siteConfig.endPoints.authHost + '/api/sso/apple?code=' + encodeURIComponent($scope.secretCodeProvider) + '&externalAppId=' + encodeURIComponent(window.currentAppId), '_blank', 'location=no,enableViewportScale=yes');
                    } else {
                        $scope.refWindow = window.open(window.siteConfig.endPoints.authHost + '/website/index.html?v=2.0&code=' + encodeURIComponent($scope.secretCodeProvider) + '&loginProviderType=' + loginProviderType + '&externalAppId=' + encodeURIComponent(window.currentAppId), '_blank', 'location=no,enableViewportScale=yes');
                    }

                    if ($scope.refWindow && $scope.refWindow.addEventListener) {
                        $scope.refWindow.addEventListener('exit', function () {
                            $scope.refWindow = null;
                        });
                    }

                    var attempts = 120;
                    setTimeout(secretCodeLogin, 1000, attempts);
                }
            }, function (e) {
                console.log(JSON.stringify(e));
                //callback({ error: { code: -1, message: "failed to communicate with the server" } });
            });
        }
    };

    var secretCodeLogin = function secretCodeLogin(attempts) {

        if (!window.appContext || !window.appContext.currentApp) {
            console.error('invalid appContext');
            return;
        }

        if (attempts > 0) {
            var data = {
                "id": 1, "method": "users/secretCodeLogin",
                "params": {
                    code: $scope.secretCodeProvider,
                    deviceId: push.deviceId,
                    osType: push.platform ? push.platform.toLowerCase() : 'web',
                    externalAppId: window.appContext.currentApp.appId
                }
            };

            var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

            window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
                if (result.error) {
                    var failedLogin = false;
                    if (result.error.code == 1300) {
                        failedLogin = true;
                    }
                    if (result.error.code == 1303) {
                        failedLogin = true;
                    }
                    if (failedLogin) {
                        $scope.secretCodeProvider = null;
                        if ($scope.refWindow != null) {
                            $scope.refWindow.close();
                            $scope.refWindow = null;
                        }
                    }
                } else {
                    if (result.result != null && result.result.userToken != null) {
                        authAPI._setCurrentUser(result.result);

                        //insert registration tags for Social Registrations
                        var fiveMinutesAgo = new Date();
                        fiveMinutesAgo.setMinutes(fiveMinutesAgo.getMinutes() - 5);
                        var userCreatedOn = new Date(result.result.createdOn);

                        //This is to check if the user is new or old (Registration or Login)
                        if (userCreatedOn && userCreatedOn.getTime() >= fiveMinutesAgo.getTime()) {
                            userTags.setRegistrationTags(null, true, function (err, result) {
                                if (err) console.log(err);
                            });
                        }

                        if ($scope.refWindow != null) {
                            $scope.refWindow.close();
                            $scope.refWindow = null;
                        }
                        if ($scope.loginCallback) $scope.loginCallback(null, authAPI.getCurrentUser());
                    } else {
                        //to handle if some one closed the popup window
                        if ($scope.refWindow != null && $scope.refWindow.closed) {
                            $scope.refWindow.close();
                            $scope.secretCodeProvider = null;
                            $scope.refWindow = null;
                        } else {
                            setTimeout(secretCodeLogin, 1000, attempts - 1);
                        }
                    }
                }
            }, function (e) {
                console.log(JSON.stringify(e));
                //callback({ error: { code: -1, message: "faild to communicate with the server" } });
            });
        } else {
            $scope.secretCodeProvider = null;
            if ($scope.refWindow != null) {
                $scope.refWindow.close();
                $scope.refWindow = null;
            }
            if ($scope.loginCallback) {
                $scope.invalidCredentials = true;
                $scope.msgError = 'Invalid Login';
                $scope.loginCallback(null, null);
            }
        }
    };

    $scope.setThemeType = function (data) {
        if (!data) {
            data = {};
        }
        var color = null;

        if (data.customLoginUI && data.customLoginUI.background && data.customLoginUI.background.active && data.customLoginUI.background.activeColor) {
            if (data.customLoginUI.background.color) {
                if (data.customLoginUI.background.color.colorType === 'solid') {
                    color = data.customLoginUI.background.color.solid.colorHex;
                }
            }
        } else if (data.colors && data.colors.backgroundColor) {
            color = data.colors.backgroundColor;
        }

        if (color) {
            // Variables for red, green, blue values
            var r, g, b, hsp;

            // Check the format of the color, HEX or RGB?
            if (color.match(/^rgb/)) {

                // If HEX --> store the red, green, blue values in separate variables
                color = color.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/);

                r = color[1];
                g = color[2];
                b = color[3];
            } else {
                // If RGB --> Convert it to HEX: http://gist.github.com/983661
                color = +("0x" + color.slice(1).replace(color.length < 5 && /./g, '$&$&'));

                r = color >> 16;
                g = color >> 8 & 255;
                b = color & 255;
            }

            // HSP (Highly Sensitive Poo) equation from http://alienryderflex.com/hsp.html
            hsp = Math.sqrt(0.299 * (r * r) + 0.587 * (g * g) + 0.114 * (b * b));

            // Using the HSP value, determine whether the color is light or dark
            if (hsp > 127.5) {
                $scope.themeType = 'light';
            } else {

                $scope.themeType = 'dark';
            }
        }
    };
}]);
"use strict";
/**
 * Created by Ayman on 9/10/2015.
 */

var authAPI = {
	authCtrlScope: null,
	userProfileCtrlScope: null,
	init: function init(context) {
		this.context = context;
		/*var currentUser = authAPI.getCurrentUser();
  if (currentUser)
  	authAPI.triggerOnLogin(currentUser);*/
	},
	initRefresh: function initRefresh() {

		var refresh = function refresh() {
			var user = authAPI.getCurrentUser();
			if (user) {
				authAPI.getUserByAccessToken({ accessToken: user.accessToken }, function (err, refreshedUser) {
					if (refreshedUser) {
						// do not compare user & refreshed as both are coming from different APIs and may not be exact match
						var currentUserUpdateFactors = { isActive: user.isActive, appTags: user.tags ? user.tags[window.currentAppId] : null };
						var refreshedUserUpdateFactors = { isActive: refreshedUser.isActive, appTags: refreshedUser.tags ? refreshedUser.tags[window.currentAppId] : null };
						authAPI._setCurrentUser(refreshedUser); // update anyway
						if (JSON.stringify(currentUserUpdateFactors) !== JSON.stringify(refreshedUserUpdateFactors)) {
							console.log("user update found during sync");
							authAPI.triggerOnUpdate(refreshedUser);
						}
					}
				});
			}
		};

		if (bfUtils.isApp) {
			setTimeout(refresh, 3000);
			setInterval(refresh, 3000 * 100);
		}
	},
	getUserByAccessToken: function getUserByAccessToken(options, callback) {
		var data = {
			"id": 1, "method": "users/getUserByAccessToken",
			"params": {
				accessToken: options.accessToken,
				externalAppId: window.currentAppId
			}
		};

		var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

		window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
			if (result) {
				if (result.error) {
					if (result.error.code === 1311) {
						// invalid access token error; could be a stale or bad token
						var options = {
							data: {
								title: 'Login Required',
								body: "Please login again",
								disableCancel: true
							}
						};

						authAPI.logout();
						callback(null, null);
						window.openDialog(options, function () {});
					} else if (result.error.code === 1309) {
						// user is no longer active
						authAPI.logout();
					} else {
						console.error(result.error);
						callback(result.error, null);
					}
				} else {
					callback(null, result.result);
				}
			} else {
				callback(null, null);
			}
		}).error(function (data, status, headers, config) {
			console.error(data);
			callback(data, null);
		});
	},
	login: function login(options, callback) {
		var currentUser = this.getCurrentUser();
		if (currentUser) {
			if (callback) callback(null, currentUser);
			authAPI.triggerOnLogin(currentUser);
		} else {
			authAPI.authCtrlScope.loginOptions = options;
			authAPI.authCtrlScope.showLogin(function (err, result) {
				if (!err && result) {
					authAPI._setCurrentUser(result);

					authAPI.triggerOnLogin(result);
					authAPI._checkGDPR(result);
					authAPI.authCtrlScope.hideLogin();
					if (!authAPI.authCtrlScope.$$phase) authAPI.authCtrlScope.$apply();
				}
				if (callback) callback(err, result);
			});
			if (!authAPI.authCtrlScope.$$phase) authAPI.authCtrlScope.$apply();
		}
	},
	_setCurrentUser: function _setCurrentUser(user) {
		localStorage.setItem('AUTH_CURRENT_USER', JSON.stringify(user));
	},
	///don't delete this is used for areas that needs to override this function
	secondaryUserLookup: function secondaryUserLookup() {
		return null;
	},
	getCurrentUser: function getCurrentUser(data, callback) {
		if (typeof data == 'function') {
			callback = data;
		}
		var user = this.secondaryUserLookup();
		if (!user) {
			user = localStorage.getItem('AUTH_CURRENT_USER');
			user = JSON.parse(user);
		}
		if (!(user && user.userToken)) {
			user = null;
		}
		if (callback) callback(null, user);else return user;
	},
	_checkGDPR: function _checkGDPR(user) {
		if (!user) return;

		var termsConditionsKey = "bf_terms_and_conditions";
		var privacyPolicyKey = "bf_privacy_policy";

		customRegistration.getSettings(null, function (err, result) {
			var keys = [termsConditionsKey, privacyPolicyKey];
			if (!err && result) {
				var termsConditionsAndPrivacyPolicy = result.singlePage.formControls.find(function (item) {
					return item && item.id === 'termsConditionsAndPrivacyPolicy';
				});
				if (termsConditionsAndPrivacyPolicy.settings && termsConditionsAndPrivacyPolicy.active && termsConditionsAndPrivacyPolicy.settings.termsAndConditionsDocumentKey) {
					keys.push(termsConditionsAndPrivacyPolicy.settings.termsAndConditionsDocumentKey);
				}
				if (termsConditionsAndPrivacyPolicy.settings && termsConditionsAndPrivacyPolicy.active && termsConditionsAndPrivacyPolicy.settings.privacyPolicyDocumentKey) {
					keys.push(termsConditionsAndPrivacyPolicy.settings.privacyPolicyDocumentKey);
				}
			}
			var url = siteConfig.endPoints.crmHost + "/documents/" + keys.join(",") + "/check?userKey=" + encodeURIComponent(user.username);
			if ((bfUtils.isAppHtml5Version || bfUtils.isMobileDevice || bfUtils.isPwaAndroid || bfUtils.isPwaiOS) && window.appContext && window.appContext.liveMode == 1) {
				bfUtils.http.get(url).success(function (result) {
					if (result) {
						for (var keyIndex = 0; keyIndex < keys.length; keyIndex++) {
							if (result[keys[keyIndex]] && !result[keys[keyIndex]].isAccepted) {
								window.location.hash = 'gdpr';
								break;
							}
						}
					}
				}).error(function (err) {
					console.error(err);
				});
			}
		});
	},
	logout: function logout() {
		this._setCurrentUser(null);
		authAPI.triggerOnLogout(null);
	},
	trackRegister: function trackRegister(user) {
		//track register only on live mode
		if (window.appContext && window.appContext.liveMode) {
			var analyticsAPI = new AnalyticsAPI(authAPI.context);
			analyticsAPI.setUserProperties({ email: user.email, username: user.username, firstName: user.firstName, lastName: user.lastName });
			analyticsAPI.trackAction('app/userRegistered');

			var historyUsersItem = localStorage.getItem('HISTORY_USERS');
			if (historyUsersItem) {
				var historyUsers = JSON.parse(historyUsersItem);
				if (historyUsers.length && historyUsers.indexOf(user._id) == -1) {
					historyUsers.push(user._id);
					localStorage.setItem('HISTORY_USERS', JSON.stringify(historyUsers));
				}
			} else {
				localStorage.setItem('HISTORY_USERS', JSON.stringify([user._id]));
			}
		}
	},
	onLogin: function onLogin(callback) {
		document.addEventListener('AUTH_CURRENT_USER_ON_LOGIN', callback, false);
	},
	onLogout: function onLogout(callback) {
		document.addEventListener('AUTH_CURRENT_USER_ON_LOGOUT', callback, false);
	},
	onUpdate: function onUpdate(callback) {
		document.addEventListener('AUTH_CURRENT_USER_ON_UPDATE', callback, false);
	},
	triggerOnUpdate: function triggerOnUpdate(user) {
		if (!user) user = authAPI.getCurrentUser();
		var onUpdateEvent = new CustomEvent('AUTH_CURRENT_USER_ON_UPDATE', { 'detail': user });
		document.dispatchEvent(onUpdateEvent);
	},
	triggerOnLogin: function triggerOnLogin(user) {
		var onUpdateEvent = new CustomEvent('AUTH_CURRENT_USER_ON_LOGIN', { 'detail': user });
		document.dispatchEvent(onUpdateEvent);
	},
	triggerOnLogout: function triggerOnLogout() {
		var onUpdateEvent = new CustomEvent('AUTH_CURRENT_USER_ON_LOGOUT', { 'detail': null });
		document.dispatchEvent(onUpdateEvent);
	},
	openProfile: function openProfile(userId) {
		if (userId) return open(userId);

		var user = this.getCurrentUser();
		if (user && user._id) return open(user._id);

		this.login({}, function (err, user) {
			if (!err && user && user._id) {
				open(user._id);
			};
		});

		function open(id) {
			authAPI.userProfileCtrlScope.open(id);
		}
	},
	getUserProfile: function getUserProfile(options, callback) {
		if (!options || !options.userId) {
			throw new Error("userId have not been provided to getUserInfo");
			return;
		}

		var userInfo = null;

		var getUserSocial = function getUserSocial() {
			var data = {
				"id": 1, "method": "users/getUserProfile",
				"params": { userId: options.userId }
			};

			var url = window.siteConfig.endPoints.socialHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

			bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
				if (callback) {
					if (result && result.result) {
						userInfo = angular.extend({}, result.result, userInfo);
						if (userInfo) {
							callback(null, userInfo);
						} else callback(null, null);
					} else callback(null, userInfo);
				}
			}).error(function (data, status, headers, config) {
				if (callback) callback(data, null);
			});
		};

		var data = {
			"id": 1, "method": "users/getPublicUser",
			"params": { userId: options.userId, externalAppId: window.currentAppId }
		};

		var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

		bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
			if (callback) {
				if (result && result.result) {
					userInfo = result.result;
					getUserSocial();
				} else callback(null, null);
			}
		}).error(function (data, status, headers, config) {
			console.error(data);
			if (callback) callback(data, null);
		});
	},
	getUsersByEmail: function getUsersByEmail(options, callback) {
		if (!options || !options.emails) {
			throw new Error("No emails have not been provided to getUserByEmail");
			return;
		}

		var mergeResults = function mergeResults(users, profiles) {
			for (var i = 0; i < users.length; i++) {
				for (var j = 0; j < profiles.length; j++) {
					if (users[i].email == profiles[j].email) {
						users[i].phone = profiles[j].phone;
					}
				}
			}

			callback(null, users);
		};

		var getProfiles = function getProfiles(users) {
			var data = {
				"id": 1, "method": "users/getUsersProfilesByEmail",
				"params": { emails: options.emails }
			};

			var url = window.siteConfig.endPoints.socialHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

			bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
				if (callback) {
					if (result && result.result) {
						mergeResults(users, result.result);
					} else callback(null, users);
				}
			}).error(function (data, status, headers, config) {
				console.error(data);
				if (callback) callback(data, null);
			});
		};

		var data = {
			"id": 1, "method": "users/getUsersByEmail",
			"params": { emails: options.emails, externalAppId: window.currentAppId }
		};

		var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

		bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
			if (callback) {
				if (result && result.result) {
					getProfiles(result.result);
				} else callback(null, null);
			}
		}).error(function (data, status, headers, config) {
			console.error(data);
			if (callback) callback(data, null);
		});
	},
	getUserPictureUrl: function getUserPictureUrl(params) {
		var key = null;
		var value = null;
		if (!params) {
			params = {};
		}
		if (params.userId) {
			key = 'userId';
			value = params.userId;
		}
		if (params.email) {
			key = 'email';
			value = params.email;
		}
		if (params.username) {
			key = 'username';
			value = params.username;
		}
		if (!key || !value) throw Error('Invalid user picture params');

		value = encodeURIComponent(value);

		return window.siteConfig.endPoints.authHost + "/src/server.js/user/picture?" + key + "=" + value + '&externalAppId=' + encodeURIComponent(window.currentAppId);
	}
};
authAPI.initRefresh();
'use strict';

$app.controller('modalCtrl', ['$scope', '$dialog', '$data', function ($scope, $dialog, $data) {
    $scope.modal = {};

    $scope.modal.body = $data.body;

    $scope.modal.title = $data.title ? $data.title : 'Confirm';
    $scope.modal.okText = $data.okText ? $data.okText : "OK";
    $scope.modal.cancelText = $data.cancelText ? $data.cancelText : "Cancel";
    $scope.modal.disableCancel = $data.disableCancel ? $data.disableCancel : false;

    $scope.close = function () {
        $dialog.close(false);
    };

    $scope.confirm = function () {
        $dialog.close(true);
    };
}]);
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Created by danielhindi on 3/15/16.
 */
var imageTools = {
    get ENUMS() {
        return {
            SIZES: {
                xxs: 32,
                xs: 64,
                s: 128,
                m: 200,
                l: 304,
                xl: 416,
                xxl: 600,
                '720': 720,
                '1080': 1080,
                '1440': 1440,
                get full_width() {
                    return this.findNearest(1);
                },
                get half_width() {
                    return this.findNearest(2);
                },
                get third_width() {
                    return this.findNearest(3);
                },
                get fourth_width() {
                    return this.findNearest(4);
                },
                get fifth_width() {
                    return this.findNearest(5);
                },
                get sixth_width() {
                    return this.findNearest(6);
                },
                findNearest: function findNearest(ratio) {
                    var match = null;
                    for (var i = 0; i < this.VALID_SIZES.length; i++) {
                        var size = this.VALID_SIZES[i];

                        if (window.innerWidth / ratio < this[size]) {
                            match = size;
                            break;
                        }
                    }
                    return this[match];
                },
                VALID_SIZES: ['xxs', 'xs', 's', 'm', 'l', 'xl', 'xxl', //standard
                '720', '1080', '1440', //desktop
                'full_width', 'half_width', 'third_width', 'quarter_width', 'fifth_width', 'sixth_width' // responsive
                ]
            },
            ASPECT_RATIOS: {
                '1:1': 1,
                '4:3': 0.75,
                '16:9': 0.5625,
                '9:16': 1.77777778,
                '11:5': 0.45454545,
                '4:1': 0.25,
                '2.39:1': 0.41841004,
                VALID_RATIOS: ['1:1', '4:3', '16:9', '9:16', '11:5', '4:1', '2.39:1']
            }
        };
    },
    resizeImage: function resizeImage(url, options, element, callback) {
        if (!url) return null;
        // return unsupported file types
        if (/\..{3,4}(?!.)/g.test(url) && !/.(png|jpg|jpeg)(?!.)/gi.test(url)) {
            var filetype = (/.{0,4}(?!.)/g.exec(url) || ['Selected'])[0];
            console.warn(filetype + ' files are not supported by resizeImage. Returning original URL: ' + url);
            return url;
        }

        if (!options) options = { width: window.innerWidth };else if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) != "object") throw "options not an object";

        var ratio = options.disablePixelRation ? 1 : window.devicePixelRatio;

        // Don't pass any value under 1
        if (ratio < 1) {
            var ratio = 1;
        }

        if (options.width == 'full') options.width = window.innerWidth;
        if (options.height == 'full') options.height = window.innerHeight;

        var root;

        /*
        if(imageTools.isProdImageServer(url)){
            url = url.replace(/^https:\/\//i, 'http://');
            root ="https://buildfire.imgix.net" + url.substring(40); // length of root host
        }
        else if (url.indexOf("Kaleo.DevBucket/") > 0 ){
            root ="https://bflegacy.imgix.net/" + url.split('Kaleo.DevBucket/')[1];
        }
         if(false && root){
            if (options.width && !options.height)
                return root + "?w=" + Math.floor(options.width * ratio) ;
            else if (!options.width && options.height)
                return root + "?h=" + Math.floor(options.height * ratio) ;
            else if (options.width && options.height)
                return root + "?w" + Math.floor(options.width * ratio) + "&h=" + Math.floor(options.height * ratio) ;
            else
                return url;
        }
        else
         */
        {
            //var protocol = window.location.protocol == "https:" ? "https:" : "http:";
            var protocol = "https:";
            var root = protocol + "//czi3m2qn.cloudimg.io/";
            var compression = imageTools.getCompression(options.compression);
            var result = '';

            if (options.size && options.aspect) {
                if (this.ENUMS.SIZES.VALID_SIZES.indexOf(options.size) < 0) {
                    var sizes = this.ENUMS.SIZES.VALID_SIZES.join(', ');
                    console.warn('Inavlid size. Availible options are ' + sizes + '. Returning original url');
                    return url;
                }
                if (this.ENUMS.ASPECT_RATIOS.VALID_RATIOS.indexOf(options.aspect) < 0) {
                    var ratios = this.ENUMS.ASPECT_RATIOS.VALID_RATIOS.join(', ');
                    console.warn('Inavlid aspect ratio. Availible options are ' + ratios + '. Returning original url');
                    return url;
                }
                //math.round
                options.width = this.ENUMS.SIZES[options.size];
                options.height = options.width * this.ENUMS.ASPECT_RATIOS[options.aspect];
            }
            // check for missing size or aspect
            if (options.width && !options.height) {
                var size = Math.floor(options.width * ratio);
                result = root + "width/" + size + "/" + compression + url;
            } else if (!options.width && options.height) {
                var size = Math.floor(options.height * ratio);
                result = root + "height/" + size + "/" + compression + url;
            } else if (options.width && options.height) {
                var size = Math.floor(options.width * ratio) + "x" + Math.floor(options.height * ratio);
                result = root + "bound/" + size + "/" + compression + url;
            } else {
                result = url;
            }

            this._handleElement(element, result, callback);

            return result;
        }
    },
    cropImage: function cropImage(url, options, element, callback) {
        if (!url) return null;
        // return unsupported file types
        if (/\..{3,4}(?!.)/g.test(url) && !/.(png|jpg|jpeg)(?!.)/gi.test(url)) {
            var filetype = (/.{0,4}(?!.)/g.exec(url) || ['Selected'])[0];
            console.warn(filetype + ' files are not supported by cropImage. Returning original URL: ' + url);
            return url;
        }

        /*if (imageTools.isProdImageServer(url)) {
            url = url.replace(/^https:\/\//i, 'http://');
        }*/
        if (!options) {
            options = {};
        }
        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) != "object") {
            throw "options not an object";
        }
        if (options.size && options.aspect) {
            if (this.ENUMS.SIZES.VALID_SIZES.indexOf(options.size) < 0) {
                var sizes = this.ENUMS.SIZES.VALID_SIZES.join(', ');
                console.warn('Inavlid size. Availible options are ' + sizes + '. Returning original url');
                return url;
            }
            if (this.ENUMS.ASPECT_RATIOS.VALID_RATIOS.indexOf(options.aspect) < 0) {
                var ratios = this.ENUMS.ASPECT_RATIOS.VALID_RATIOS.join(', ');
                console.warn('Inavlid aspect ratio. Availible options are ' + ratios + '. Returning original url');
                return url;
            }

            options.width = this.ENUMS.SIZES[options.size];
            options.height = options.width * this.ENUMS.ASPECT_RATIOS[options.aspect];
        }
        if (!options.width && !options.height) {
            options = { width: 'full', height: 'full' };
        }
        if (options.width == 'full') {
            options.width = window.innerWidth;
        }
        if (options.height == 'full') {
            options.height = window.innerHeight;
        }
        if (!options.width || !options.height) {
            console.warn('cropImage doenst have width or height please fix. returning original url');
            return url + '?h=' + options.height + '&w=' + options.width;
        }

        var ratio = window.devicePixelRatio;
        if (options && options.disablePixelRatio) {
            ratio = options.disablePixelRatio;
        }

        //var protocol = window.location.protocol == "https:" ? "https:" : "http:";
        var protocol = "https:";
        var root = protocol + "//czi3m2qn.cloudimg.io/crop/";

        var size = Math.floor(options.width * ratio) + "x" + Math.floor(options.height * ratio) + "/";
        var compression = imageTools.getCompression(options.compression);

        var result = root + size + compression + url;

        this._handleElement(element, result, callback);

        return result;
    },
    _handleElement: function _handleElement(element, src, callback) {
        if (!element || !src) return;

        var path = this._getLocalPath(src);

        if (element.tagName === 'IMG') {
            element.style.setProperty('opacity', '0', 'important');
            element.src = path;

            element.onload = function () {
                element.style.removeProperty('opacity');
                if (callback) callback(path);
            };

            element.onerror = function () {
                if (bfUtils.isAppHtml5Version) return;

                imageCacheAPI.download(src, function (error, localPath) {
                    if (error) {
                        return element.src = src;
                    }
                    element.src = localPath;
                });
            };
        } else {
            this._handleBgImage(element, path, src, callback);
        }
    },
    _handleBgImage: function _handleBgImage(element, path, src, callback) {
        applyStyle(element, path);

        var img = new Image();
        img.src = path;

        img.onload = function () {
            if (callback) callback(path);
        };

        img.onerror = function () {
            applyStyle(element);

            if (bfUtils.isAppHtml5Version) {
                return applyStyle(element, src);
            };

            imageCacheAPI.download(src, function (error, localPath) {
                if (error) {
                    if (callback) callback(src);
                    return applyStyle(element, src);
                }
                window.requestAnimationFrame(function () {
                    applyStyle(element, localPath);
                    if (callback) callback(localPath);
                });
            });
        };

        function applyStyle(ele, source) {
            if (!source) {
                return ele.style.removeProperty('background-image');
            }
            var backgroundCss = 'url("' + source + '")';
            ele.style.setProperty('background-image', backgroundCss, 'important');
        }
    },
    _getLocalPath: function _getLocalPath(string) {
        if (bfUtils.isAppHtml5Version) {
            return string;
        }

        string = string.replace(/(http|https):\/\/\S{0,8}.cloudimg.io\//g, '');
        var extension = string.match(/(png|jpg|jpeg)/g)[0] || '';
        extension = extension ? '.' + extension : '';

        var hash = 0;
        if (!string.length) return hash;

        for (var i = 0; i < string.length; i++) {
            var char = string.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash |= 0; // Convert to 32bit integer
        }

        return 'cdvfile://localhost/persistent/imageCache/images/' + hash + extension;
    },
    getCompression: function getCompression(c) {
        var result = 'n/';
        if (c) {
            var isValid = typeof c === "number" && c >= 1 && c <= 100;
            if (isValid) {
                var value = 'png-lossy-' + c + '.q' + c + '/';
                if (/png-lossy-\d{1,3}.q\d{1,3}\//g.test(value)) {
                    result = value;
                }
            } else {
                console.warn('Disabling compression, must be an integer between 1-100');
            }
        }
        return result;
    },
    isProdImageServer: function isProdImageServer(url) {
        return url.indexOf("http://imageserver.prod.s3.amazonaws.com") == 0 || url.indexOf("https://imageserver.prod.s3.amazonaws.com") == 0 || url.indexOf("https://s3-us-west-2.amazonaws.com/imageserver.prod") == 0;
    }
};
"use strict";

var appearanceHandler = {
    busterCounter: 0,
    appThemeCSSElement: document.getElementById('appThemeCSS'),
    appearanceSampleHead: undefined,
    animator: undefined,
    init: function init() {
        if (typeof siteConfig == "undefined") {
            console.warn("siteConfig unidentified");
            return;
        }

        if (!window.appContext || !window.appContext.currentApp) {
            console.error('invalid appContext');
            return;
        }

        appearanceHandler.appearanceSampleHead = document.head || document.getElementsByTagName('head')[0];

        var newAppThemeCSSElement = document.createElement("link");
        newAppThemeCSSElement.setAttribute("id", "appThemeCSS");
        newAppThemeCSSElement.setAttribute("rel", "stylesheet");
        newAppThemeCSSElement.setAttribute("type", "text/css");
        newAppThemeCSSElement.setAttribute("href", siteConfig.endPoints.appHost + '/api/app/styles/appTheme.css?appId=' + appContext.currentApp.appId + '&liveMode=' + appContext.liveMode);
        appearanceHandler.appearanceSampleHead.appendChild(newAppThemeCSSElement);
        if (typeof AppearanceAPI != "undefined") {
            AppearanceAPI.prototype.beforeUpdate(appearanceHandler.transition);
            AppearanceAPI.prototype.onUpdate(appearanceHandler.refresh);
        } else console.error("AppearanceAPI is not defined");
    },
    transition: function transition() {
        if (!appearanceHandler.animator) {
            var pluginElement = document.getElementById('plugin');
            if (pluginElement) {
                appearanceHandler.animator = angular.element(pluginElement).injector().get('cfpLoadingBar');
            }
        }
        if (appearanceHandler.animator) {
            appearanceHandler.animator.start();
        }
    },
    refresh: function refresh() {
        var $body = angular.element(document.body);
        $body.scope().$broadcast('menuUpdate', function () {});

        if (!appearanceHandler.appThemeCSSElement) {
            appearanceHandler.appThemeCSSElement = document.getElementById('appThemeCSS');
        }
        var newAppThemeCSSElement = document.createElement("link");
        newAppThemeCSSElement.setAttribute("rel", "stylesheet");
        newAppThemeCSSElement.setAttribute("type", "text/css");
        newAppThemeCSSElement.setAttribute("href", siteConfig.endPoints.appHost + '/api/app/styles/appTheme.css?appId=' + appContext.currentApp.appId + '&liveMode=' + appContext.liveMode);
        if (appearanceHandler.appThemeCSSElement.href.indexOf("&v=") == -1) {
            newAppThemeCSSElement.href += "&v=" + appearanceHandler.busterCounter;
        } else {
            newAppThemeCSSElement.href = appearanceHandler.appThemeCSSElement.href.replace("&v=" + appearanceHandler.busterCounter, "&v=" + ++appearanceHandler.busterCounter);
        }

        angular.element(document.getElementById('plugin')).injector();

        newAppThemeCSSElement.setAttribute("id", 'appThemeCSS' + appearanceHandler.busterCounter);
        appearanceHandler.appearanceSampleHead.appendChild(newAppThemeCSSElement);
        if (appearanceHandler.busterCounter > 2) {
            // remove oldest one but keep current for phasing out css
            var previousAppThemeCSSElement = document.getElementById('appThemeCSS' + (appearanceHandler.busterCounter - 3).toString());
            if (previousAppThemeCSSElement) {
                previousAppThemeCSSElement.parentNode.removeChild(previousAppThemeCSSElement);
            }
        }
        appearanceHandler.appThemeCSSElement = newAppThemeCSSElement;

        if (appearanceHandler.appThemeCSSElement.addEventListener) {
            appearanceHandler.appThemeCSSElement.addEventListener('load', function () {
                if (appearanceHandler.animator) appearanceHandler.animator.complete();
            }, false);
        } else {
            appearanceHandler.appThemeCSSElement.onload = function () {
                if (appearanceHandler.animator) appearanceHandler.animator.complete();
            };
            appearanceHandler.appThemeCSSElement.onreadystatechange = function () {
                var state = appearanceHandler.appThemeCSSElement.readyState;
                if (state === 'loaded' || state === 'complete') {
                    appearanceHandler.appThemeCSSElement.onreadystatechange = null;
                    if (appearanceHandler.animator) appearanceHandler.animator.complete();
                }
            };
        }
    }
};

appearanceHandler.init();
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

setTimeout(function () {
    if (sessionStorage.getItem('notification')) {
        try {
            var notification = JSON.parse(sessionStorage.getItem('notification'));
            LocalNotificationsAPI.navToPlugin(notification);
        } finally {
            sessionStorage.removeItem('notification');
        }
    }
}, 2000);

var LocalNotificationsAPI = function () {
    var webNotificationsQueue = {};
    var pluginMissingError = "Cordova notification plugin not installed";

    function _LocalNotificationsAPI(context) {
        this.context = context;
    }

    _LocalNotificationsAPI.prototype = {
        schedule: function schedule(notification, callback) {
            var id = generateId();
            var now = new Date();

            if (_LocalNotificationsAPI.isPluginAvailable()) {
                //Don't allow users to specify badge options
                notification.badge = 0;

                //If the send time isn't specified, send it real soon
                if (!notification.at) {
                    notification.at = new Date(now.getTime() + 250);
                } else {
                    notification.at = Date.parse(notification.at);
                }

                notification.id = id;

                notification.data = {
                    actionItem: notification.actionItem,
                    pluginData: notification.data,
                    returnInstanceId: notification.returnToPluginInstanceId || this.context.instanceId,
                    launchInstanceId: this.context.instanceId,
                    pluginId: this.context.pluginId,
                    analyticsData: notification.analyticsData
                };

                cordova.plugins.notification.local.schedule(notification);

                callback(null, { id: notification.id });
            } else {
                var diff = Math.abs(Date.parse(notification.at) - Date.now());

                //Don't send old notifications, give or take a few seconds
                if (diff < -2000) {
                    return;
                }

                notification.data = {
                    actionItem: notification.actionItem,
                    pluginData: notification.data,
                    returnInstanceId: notification.returnToPluginInstanceId || this.context.instanceId,
                    launchInstanceId: this.context.instanceId,
                    pluginId: this.context.pluginId,
                    analyticsData: notification.analyticsData
                };

                var timer = setTimeout(function () {
                    if (notificationInWebQueue(id)) {
                        _LocalNotificationsAPI.notificationModal(notification);
                        removeFromWebQueue(id);
                    }
                }, diff);

                webNotificationsQueue[id] = timer;
                callback(null, { id: id });
            }
        },
        cancel: function cancel(id, callback) {
            if (_LocalNotificationsAPI.isPluginAvailable()) {
                cordova.plugins.notification.local.cancel(id);
                callback(null, { id: id });
            } else if (!isDevice()) {
                removeFromWebQueue(id);
                callback(null, { id: id });
            } else {
                callback(new Error(pluginMissingError), null);
            }
        },

        checkPermission: function checkPermission(data, callback) {
            if (!isDevice()) {
                //Special permissions aren't required in web, so we return true
                if (callback) callback(null, true);
                return;
            }

            if (!_LocalNotificationsAPI.isPluginAvailable()) {
                if (callback) callback(new Error(pluginMissingError), false);

                console.warn(pluginMissingError);
                return;
            }

            cordova.plugins.notification.local.hasPermission(function (granted) {
                if (callback) callback(null, granted);
            });
        },

        requestPermission: function requestPermission(data, callback) {
            if (!isDevice()) {
                //Special permissions aren't required in web, so we return true
                if (callback) callback(null, true);
                return;
            }

            /// ask only if permission hasn't been granted
            if (!_LocalNotificationsAPI.isPluginAvailable()) {
                if (callback) callback(new Error(pluginMissingError), false);

                console.warn(pluginMissingError);
                return;
            }

            cordova.plugins.notification.local.hasPermission(function (granted) {
                if (granted) {
                    if (callback) callback(null, true);
                } else {
                    cordova.plugins.notification.local.registerPermission(function (registerGranted) {
                        if (registerGranted) {
                            if (callback) callback(null, true);
                        } else {
                            console.warn('Permission not granted for local notifications');
                            if (callback) callback(null, false);
                        }
                    });
                }
            });
        }
    };

    function generateId() {
        //Note: ID must be 9 digits or less
        return Math.floor(Math.random() * 1000000000);
    }

    function notificationInWebQueue(id) {
        return webNotificationsQueue.hasOwnProperty(id);
    }

    function removeFromWebQueue(id) {
        if (notificationInWebQueue(id)) {
            clearTimeout(webNotificationsQueue[id]);
            delete webNotificationsQueue[id];
        }
    }

    function isDevice() {
        return typeof cordova != "undefined";
    }

    _LocalNotificationsAPI.isPluginAvailable = function () {
        var isAvailable = true;

        if (typeof cordova == "undefined" || !cordova.plugins || !cordova.plugins.notification || !cordova.plugins.notification.local) {

            isAvailable = false;
        }

        return isAvailable;
    };

    _LocalNotificationsAPI.getPlatform = function () {
        return device.platform ? device.platform.toLowerCase() : '';
    };

    _LocalNotificationsAPI.notificationModal = function (notification) {
        if (!notification || !notification.title && !notification.text) {
            return;
        }
        var options = {
            data: { title: notification.title, body: notification.text }
        };

        window.openDialog(options, function (result) {

            if (result) {
                _LocalNotificationsAPI.navToPlugin(notification);
            }
        });
    };

    _LocalNotificationsAPI.navToPlugin = function (notification) {
        var _nav = function _nav() {
            var delay = 2000;
            var actions = {
                doNothing: 0,
                sendToLauncher: 1,
                sendToPlugin: 2
            },
                action = actions.sendToPlugin,
                returnInstanceId;

            if (_typeof(notification.data) !== 'object') notification.data = JSON.parse(notification.data);

            // if an action is available apply the action
            if (notification.data.actionItem) {
                //Perform action
                ActionItemsAPI.prototype.execute(notification.data.actionItem, function (err, wasSuccess) {});
            }

            returnInstanceId = notification.data.returnInstanceId ? notification.data.returnInstanceId.toLowerCase() : '';

            if (returnInstanceId == 'home' || returnInstanceId == 'none') action = actions.doNothing;else if (postMaster.launcherPluginAPI && postMaster.launcherPluginAPI.context && postMaster.launcherPluginAPI.context.instanceId == returnInstanceId) action = actions.sendToLauncher;

            if (action === actions.doNothing) {
                return;
            }

            if (actions === actions.sendToLauncher) {
                delay = 500;

                postMaster.launcherPluginAPI.navigation.navigateHome();
            } else {
                action = actions.sendToPlugin;

                if (postMaster.widgetPluginAPI && postMaster.widgetPluginAPI.context && postMaster.widgetPluginAPI.context.instanceId == notification.data.returnInstanceId) {
                    delay = 500;
                } else {
                    postMaster.launcherPluginAPI.navigation.navigateToPluginInstance({
                        instanceId: notification.data.returnInstanceId
                    });
                }
            }

            setTimeout(function () {
                var packet = new Packet(null, 'notifications.localNotification.onClick', notification.data.pluginData);

                if (action === actions.sendToLauncher) {
                    postMaster.launcherPluginAPI.sendMessage(null, packet);
                } else {
                    postMaster.widgetPluginAPI.sendMessage(null, packet);
                }
            }, delay);
        };

        var initialDelay = postMaster.launcherPluginAPI ? 0 : 1500;
        setTimeout(function () {
            if (postMaster.launcherPluginAPI) {
                _nav();
            }
        }, initialDelay);
    };

    _LocalNotificationsAPI.sendAnalytics = function (notification) {
        if (notification && notification.data) {
            if (_typeof(notification.data) !== 'object') notification.data = JSON.parse(notification.data);
            if (notification.data && notification.data.analyticsData && notification.data.analyticsData.eventName) {
                var analyticsAPI = new AnalyticsAPI(window.appContext.currentApp.appId, notification.data.pluginId, notification.data.launchInstanceId, window.appContext.liveMode);
                analyticsAPI.trackAction(notification.data.analyticsData.eventName, notification.data.analyticsData.metaData);
            }
        }
    };

    return _LocalNotificationsAPI;
}();

if (bfUtils.isMobileDevice) {
    appState.subscribe({ state: appState.RUNNING }, function () {
        if (LocalNotificationsAPI.isPluginAvailable()) {
            //iOS: Triggers when a notification fires and the app is in focus
            //Android: Triggers when a notification fires, regardless of the app being in focus or not
            cordova.plugins.notification.local.on("trigger", function (notification) {
                console.log('*** notification trigger ***');
                LocalNotificationsAPI.sendAnalytics(notification);
                if (LocalNotificationsAPI.getPlatform() == "ios") {
                    LocalNotificationsAPI.notificationModal(notification);
                }
            });

            //Fired when user clicks on a notification
            //iOS: A notification is only fired if the app is not in focus
            //Android: A notification is always fired.
            cordova.plugins.notification.local.on("click", function (notification) {
                console.log('*** notification click ***');
                LocalNotificationsAPI.sendAnalytics(notification);
                LocalNotificationsAPI.navToPlugin(notification);
            });
        }
    });
}
"use strict";

/**
 * Created by danielhindi on 9/14/16.
 */

var localStorageAPI = {
    _prefix: '_bfls_',
    setItem: function setItem(keyValue, callback) {
        if (!keyValue || !keyValue.key || !keyValue.value) callback(new Error("invalid parameters. Expected Key/Value object"));else {
            localStorage.setItem(localStorageAPI._prefix + keyValue.key, keyValue.value);
            callback(null, true);
        }
    },
    getItem: function getItem(key, callback) {

        if (key && key.key) key = key.key;

        if (!key || !callback) callback(new Error("invalid parameters. Expected Key and Callback"));else {
            var val = localStorage.getItem(localStorageAPI._prefix + key);
            callback(null, val);
        }
    },
    removeItem: function removeItem(key, callback) {

        if (key && key.key) key = key.key;

        if (!key || !callback) callback(new Error("invalid parameters. Expected Key and Callback"));else {
            localStorage.removeItem(localStorageAPI._prefix + key);
            callback(null, true);
        }
    }
};
"use strict";

var validator = {
    validatePassword: function validatePassword(password, options) {
        var simplePasswordValidation = options && options.simplePasswordValidation;
        if (simplePasswordValidation) {
            return password && password.length >= 6 && password.length <= 60;
        } else {
            //8 char min, Capital and small, number and symbol
            if (!password || password.length < 8 || password.length > 60) return false;
            var hasUpperCase = /[A-Z]/.test(password);
            var hasLowerCase = /[a-z]/.test(password);
            var hasNumbers = /\d/.test(password);
            var hasNonalphas = /\W/.test(password);

            return hasUpperCase && hasLowerCase && hasNumbers && hasNonalphas;
        }
    },
    validateEmail: function validateEmail(email) {
        if (!email) return false;
        return (/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,24}$/.test(email)
        );
    },
    passwordPattern: {
        test: function test(value) {
            return validator.validatePassword(value);
        }
    }
};
"use strict";

/**
 * Created by Ayman on 1/10/2018.
 */

function PushNotificationsAPI(context) {
    this.context = context;
}

PushNotificationsAPI.prototype = {
    ///params: {title, text, at, groupName, users, usersTags, queryString}
    schedule: function schedule(params, callback) {
        if (!params || !params.text || !params.title) {
            if (callback) callback('text or title is empty');
            return;
        }
        if (!this.context || !this.context.instanceId) {
            if (callback) callback('instanceId is null, unable to build groupID');
            return;
        }
        if (!params.at) params.at = new Date();
        if (!params.groupName) {
            params.groupName = '';
        }

        var data = {
            groupID: PushNotificationsAPI._getGroupID(this.context, params.groupName),
            users: params.users,
            userTags: params.userTags,
            title: params.title,
            message: params.text,
            sendAfter: params.at,
            source: "plugin",
            richMessage: params.inAppMessage || undefined
        };
        data.sourceId = window.appContext.currentApp.appId + "_" + this.context.instanceId + "_" + data.source;

        if (params.actionItem !== false) {
            if (params.actionItem) {
                data.actionItem = params.actionItem;
            } else {
                data.actionItem = {
                    title: 'View',
                    action: 'linkToApp',
                    instanceId: this.context.instanceId,
                    queryString: params.queryString
                };
            }
        }

        authAPI.getCurrentUser(function (err, user) {
            data.authCreatedBy = user && user._id ? user._id.toString() : null;

            bfUtils.http.post(window.siteConfig.endPoints.pushV2 + "/api/app/" + window.appContext.currentApp.appId + "/notification/", data).success(function (result) {
                if (callback) callback(null, result);
            }).error(function (data, status, headers, config) {
                if (callback) callback(data);
            });
        });
    },
    ///params: id
    cancel: function cancel(id, callback) {
        if (!id) {
            if (callback) callback('id is empty');
            return;
        }
        if (!this.context || !this.context.instanceId) {
            if (callback) callback('instanceId is null, unable to build groupID');
            return;
        }
        var data = {
            source: "plugin"
        };
        data.sourceId = window.appContext.currentApp.appId + "_" + this.context.instanceId + "_" + data.source;

        authAPI.getCurrentUser(function (err, user) {
            data.authCanceledBy = user && user._id ? user._id.toString() : null;

            bfUtils.http.post(window.siteConfig.endPoints.pushV2 + "/api/app/" + window.appContext.currentApp.appId + "/notification/" + id + '/cancel', data).success(function (result) {
                if (callback) callback(null, true);
            }).error(function (data, status, headers, config) {
                if (callback) callback(data);
            });
        });
    },
    ///params: {groupName}
    subscribe: function subscribe(params, callback) {
        if (!params) params = {};
        if (!params.groupName) params.groupName = '';
        if (!this.context || !this.context.instanceId) {
            if (callback) callback('instanceId is null, unable to build groupID');
            return;
        }
        var groupID = PushNotificationsAPI._getGroupID(this.context, params.groupName);
        PushNotificationsAPI._subscribe({ groupID: groupID }, callback);
    },
    ///params: {groupName}
    unsubscribe: function unsubscribe(params, callback) {
        if (!params) params = {};
        if (!params.groupName) params.groupName = '';
        if (!this.context || !this.context.instanceId) {
            if (callback) callback('instanceId is null, unable to build groupID');
            return;
        }
        var groupID = PushNotificationsAPI._getGroupID(this.context, params.groupName);
        PushNotificationsAPI._unsubscribe({ groupID: groupID }, callback);
    }
};

PushNotificationsAPI._getGroupID = function (context, groupName) {
    return window.appContext.currentApp.appId + "_" + context.instanceId + "_" + groupName;
};

PushNotificationsAPI._unsubscribe = function (params, callback) {
    if (!window.push || !window.push.deviceId || !window.push.platform) {
        if (callback) callback('Device not ready to get the deviceId');
        return;
    }
    if (!params) {
        params = {};
    }
    if (!params.groupID) {
        callback('groupID is not specified');
        return;
    }

    authAPI.getCurrentUser(function (err, user) {
        params.deviceID = push.deviceId;
        params.os = window.push.platform ? window.push.platform.toLowerCase() : '';
        params.authUserId = user && user._id ? user._id.toString() : null;

        bfUtils.http.post(window.siteConfig.endPoints.pushV2 + "/api/app/" + window.appContext.currentApp.appId + "/unsubscribe/", params).success(function (result) {
            if (callback) callback(null, true);
        }).error(function (data, status, headers, config) {
            if (callback) callback(data);
        });
    });
};

PushNotificationsAPI._getSubscriptions = function (callback) {
    if (!window.push || !window.push.deviceId || !window.push.platform) {
        if (callback) callback('Device not ready to get the deviceId');
        return;
    }

    var pushV2 = window.siteConfig.endPoints.pushV2;
    var appId = window.appContext.currentApp.appId;
    var url = pushV2 + '/api/app/' + appId + '/subscriptions/';

    var options = {
        deviceID: push.deviceId,
        os: window.push.platform ? window.push.platform.toLowerCase() : ''
    };

    bfUtils.http.post(url, options).success(function (result) {
        return callback(null, result);
    }).catch(function (err) {
        return callback(err, null);
    });
};

PushNotificationsAPI._subscribe = function (params, callback) {
    if (!window.push || !window.push.deviceId || !window.push.platform) {
        if (callback) callback('Device not ready to get the deviceId');
        return;
    }
    if (!params) {
        params = {};
    }
    if (!params.groupID) {
        params.groupID = '';
    }

    authAPI.getCurrentUser(function (err, user) {
        var pushSupportsFCM = typeof PushNotification !== "undefined" && typeof PushNotification.listChannels !== "undefined";
        var isFCM = device.platform && device.platform.toLowerCase() === "android" && pushSupportsFCM;

        params.deviceID = push.deviceId;
        params.os = window.push.platform ? window.push.platform.toLowerCase() : '';
        params.authUserId = user && user._id ? user._id.toString() : null;
        params.device = typeof device !== 'undefined' ? device : null;
        params.deliveryMethod = isFCM ? 'FCM' : null;

        var currentPushDeviceID = localStorage.getItem("currentPushDeviceID");
        if (currentPushDeviceID && currentPushDeviceID !== push.deviceId) {
            params.oldDeviceID = currentPushDeviceID;
        }

        bfUtils.http.post(window.siteConfig.endPoints.pushV2 + "/api/app/" + window.appContext.currentApp.appId + "/subscribe/", params).success(function (result) {
            localStorage.setItem("currentPushDeviceID", push.deviceId);
            if (callback) callback(null, true);
        }).error(function (data, status, headers, config) {
            if (callback) callback(data);
        });
    });
};

(function () {
    authAPI.onLogin(function () {
        setTimeout(function () {
            PushNotificationsAPI._subscribe();
        }, 2000);
    });
    authAPI.onLogout(function () {
        setTimeout(function () {
            PushNotificationsAPI._subscribe();
        }, 2000);
    });
})();
"use strict";

/**
 * Created by Ayman on 4/4/2018.
 */

function FirebaseAPI(context) {
    this.context = context;
}

FirebaseAPI.prototype = {
    createCustomToken: function createCustomToken(params, callback) {
        var self = this;

        function firebaseLogin(user) {
            FirebaseAPI._getUser({
                instanceId: self.context.instanceId,
                appId: window.appContext.currentApp.appId,
                integrationToken: params.integrationToken
            }, function (err, currentUser) {
                if (!currentUser || params && params.forceLogin) {
                    //call login api
                    bfUtils.http.post(window.siteConfig.endPoints.appHost + "/api/user/firebase/login", {
                        authUserId: user._id,
                        authAccessToken: user.accessToken,
                        pluginTypesToken: self.context.pluginId,
                        appId: window.appContext.currentApp.appId,
                        instanceId: self.context.instanceId,
                        integrationToken: params.integrationToken
                    }).success(function (result) {
                        FirebaseAPI._setUser({
                            instanceId: self.context.instanceId,
                            appId: window.appContext.currentApp.appId,
                            integrationToken: params.integrationToken
                        }, result);
                        if (callback) callback(null, result);
                    }).error(function (data, status, headers, config) {
                        if (status == 401 || status == 403) {
                            authAPI.logout();
                            authAPI.login({}, function (err, user) {
                                if (user) {
                                    firebaseLogin(user);
                                } else {
                                    if (callback) callback(null, null);
                                }
                            });
                        } else {
                            if (callback) callback(data);
                        }
                    });
                } else {
                    if (callback) callback(null, currentUser);
                }
            });
        }

        authAPI.getCurrentUser(function (err, user) {
            if (user) {
                firebaseLogin(user);
            } else {
                authAPI.login({}, function (err, user) {
                    if (user) {
                        firebaseLogin(user);
                    } else {
                        if (callback) callback(null, null);
                    }
                });
            }
        });
    }
};

(function () {
    //cache the custom user login per appId and instanceId for max 1 hour
    var users = {};

    FirebaseAPI._getUser = function (params, callback) {
        var key = params.appId + "_" + params.instanceId + "_" + params.integrationToken;
        var user = users[key];
        var prvHour = new Date();
        prvHour.setMinutes(prvHour.getMinutes() - 60);
        if (user && user.createdOn > prvHour) {
            callback(null, user.value);
        } else {
            users[key] = undefined;
            callback(null, null);
        }
    };
    FirebaseAPI._setUser = function (params, value) {
        var key = params.appId + "_" + params.instanceId + "_" + params.integrationToken;
        users[key] = {
            createdOn: new Date(),
            value: value
        };
    };

    authAPI.onLogout(function () {
        users = {};
    });
})();
'use strict';

function PublicFilesAPI(context) {
    this.context = context;
    this.currentUser = null;
};

PublicFilesAPI.prototype = {
    showDialog: function showDialog(options, callback) {
        if (!options) options = {};

        var self = this;

        var form;

        form = document.getElementById('publicFiles_input_form');

        if (!form) {
            form = document.createElement('form');
            form.setAttribute("id", "publicFiles_input_form");
            document.body.appendChild(form);
        } else {
            form.innerHTML = '';
        }

        var fileInput = document.createElement('input');
        fileInput.setAttribute("type", "file");
        fileInput.setAttribute("style", "display:none");
        fileInput.setAttribute("id", "publicFilesHiddenInput" + new Date().toISOString());
        form.appendChild(fileInput);

        if (options && options.allowMultipleFilesUpload) {
            fileInput.setAttribute("multiple", "");
            fileInput.setAttribute("name", "files[]");
        }

        if (options && options.filter) fileInput.accept = options.filter.join(',');

        fileInput.addEventListener("change", function () {
            self.uploadFiles(this.files, options, callback);
        }, false);

        // setTimeout(function () {
        fileInput.click();
        // });
    },
    uploadFiles: function uploadFiles(files, options, callback) {
        var promises = [];
        var onProgressResult = [];
        var self = this;

        if (!callback && typeof options === 'function') {
            callback = options;
            options = {};
        }

        if (!options) options = {};

        var analyticsAPI = new AnalyticsAPI(self.context.appId, self.context.pluginId, self.context.instanceId, window.appContext.liveMode);

        authAPI.getCurrentUser(function (err, user) {
            if (user) {
                self.currentUser = user;
            }

            _uploadFiles(files);
        });

        function upload(file, resultFile) {
            return new Promise(function (resolve, reject) {
                var valid = true;
                if (options.filter && !validateFileExtension(file, options.filter)) {
                    resultFile.status = 'failed';
                    resultFile.error = 'invalid File Format';
                    if (self._onComplete) self._onComplete(resultFile);
                    valid = false;
                    resolve(resultFile);
                }

                if (!validateFileSize(file)) {
                    resultFile.status = 'failed';
                    resultFile.error = 'invalid File Size';
                    if (self._onComplete) self._onComplete(resultFile);
                    valid = false;
                    resolve(resultFile);
                }

                if (valid) {
                    var formData = new FormData();
                    formData.append("file", file);
                    formData.append('pluginId', self.context.pluginId);
                    formData.append('instanceId', self.context.instanceId);
                    formData.append('appId', self.context.appId);

                    if (self.currentUser && self.currentUser.accessToken) formData.append('accessToken', self.currentUser.accessToken);

                    var xhr = new XMLHttpRequest();
                    xhr.upload.addEventListener("progress", function (e) {
                        if (e.lengthComputable) {
                            var percentage = Math.round(e.loaded * 100 / e.total);
                            resultFile.percentage = percentage;
                            if (self._onProgress) self._onProgress(resultFile);
                        }
                    }, false);

                    xhr.onload = function () {

                        var result = null;
                        if (xhr.responseText) {
                            try {
                                result = JSON.parse(xhr.responseText);
                            } catch (e) {}
                        }

                        if (xhr.status == 200) {
                            resultFile.url = result.url;
                            resultFile.size = result.size;
                            resultFile.type = result.type;
                            resultFile.status = 'success';

                            var analyticsMetaData = {
                                data: {
                                    url: result.url,
                                    size: result.size,
                                    type: result.type
                                },
                                _buildfire: { aggregationValue: result.size }
                            };

                            //send to Analytics
                            if (window.siteConfig.scope == 'app') {
                                analyticsAPI.trackAction('app/publicFilesUpload', analyticsMetaData);
                            } else {
                                analyticsAPI.trackAction('cp/publicFilesUpload', analyticsMetaData);
                            }
                        } else {
                            resultFile.status = 'failed';
                            if (result.message) resultFile.error = result.message;else resultFile.error = "An error has occurred";
                        }

                        if (self._onComplete) self._onComplete(resultFile);
                        resolve(resultFile);
                    };

                    xhr.onerror = function () {
                        resultFile.status = 'failed';
                        if (self._onComplete) self._onComplete(resultFile);
                        resolve(resultFile);
                    };

                    xhr.timeout = 60000;
                    xhr.open("POST", window.siteConfig.endPoints.publicFilesHost + "/publicFiles/upload/");
                    xhr.send(formData);
                }
            });
        }

        function validateFileExtension(file, filter) {
            for (var i = 0; i <= filter.length; i++) {
                if (filter[i] == file.type) {
                    return true;
                }
            }

            return false;
        };

        function validateFileSize(file) {
            if (file.size > 26214400) /*25MB*/
                return false;else return true;
        };

        function _uploadFiles(files) {
            for (var i = 0; i < files.length; i++) {
                var _resultFile = { fileId: i, filename: files[i].name };
                files[i].fileId = i;
                onProgressResult.push(_resultFile);
                promises.push(upload(files[i], _resultFile));
            }

            Promise.all(promises).then(function (files) {
                callback(null, files);
            }).catch(function () {
                callback(true, null);
            });
        };
    },
    onProgress: function onProgress(callback) {
        this._onProgress = callback;
    }, onComplete: function onComplete(callback) {
        this._onComplete = callback;
    }
};
'use strict';

var imagePreviewerAPI = {

  /**
   * Shows the image slider
   */
  show: function show(options, callback) {
    if (!this.initialized) this.renderHTML();
    var pswpElement = document.querySelectorAll('.pswp')[0];
    callback = callback || Function.prototype;

    var pswpOptions = {
      index: options.index >= 0 ? options.index : 0,
      history: false,
      counterEl: false,
      captionEl: false,
      fullscreenEl: false,
      zoomEl: false,
      arrowEl: false,
      preloaderEl: false,
      shareEl: false,
      tapToToggleControls: false,
      correctOrientation: true
    };

    var ui = window.PhotoSwipeUI_Default;

    if (!options || !options.images || !options.images.length) {
      return;
    }

    // Fix for those that don't follow the spec
    if (options.images[0] && options.images[0].name) {
      options.images = options.images.map(function (img) {
        return img.name;
      });
    }

    var imagePromises = [];
    function preLoad() {
      options.images.forEach(function (src) {
        var promise = new Promise(function (resolve) {
          var image = new Image();
          image.onload = function () {
            return resolve(image);
          };
          image.src = 'https://czi3m2qn.cloudimg.io/cdno/n/q1/' + src;
        });
        imagePromises.push(promise);
      });
    }
    window.spinner.show();
    preLoad();

    Promise.all(imagePromises).then(function (images) {
      var itemPromises = [];
      images.forEach(function (preloadedImg) {
        itemPromises.push(new Promise(function (resolve) {
          EXIF.getData(preloadedImg, function () {
            var orientation = EXIF.getTag(this, 'Orientation');
            var src = preloadedImg.src,
                naturalHeight = preloadedImg.naturalHeight,
                naturalWidth = preloadedImg.naturalWidth;

            src = src.replace(/q1/, 'n');
            if (orientation === 3 || orientation === 6) {
              resolve({
                src: 'https://czi3m2qn.cloudimg.io/crop/' + naturalHeight + 'x' + naturalWidth + '/q100.i1/' + src,
                msrc: 'https://czi3m2qn.cloudimg.io/crop/' + Math.round(naturalHeight / 3) + 'x' + Math.round(naturalWidth / 3) + '/q25.i1/' + src,
                w: naturalHeight,
                h: naturalWidth
              });
            } else {
              resolve({
                src: 'https://czi3m2qn.cloudimg.io/crop/' + naturalWidth + 'x' + naturalHeight + '/q100.i1/' + src,
                msrc: 'https://czi3m2qn.cloudimg.io/crop/' + Math.round(naturalWidth / 3) + 'x' + Math.round(naturalHeight / 3) + '/q25.i1/' + src,
                w: naturalWidth,
                h: naturalHeight
              });
            }
          });
        }));
      });

      Promise.all(itemPromises).then(function (items) {
        window.pswp = new PhotoSwipe(pswpElement, ui, items, pswpOptions);
        window.pswp.listen('close', callback);
        window.pswp.init();
        window.spinner.hide();
      });
    });
  },


  /**
   * Renders the initial html needed for the image previewer.
   * Should be run only once.
   */
  renderHTML: function renderHTML() {
    var container = document.createElement('div');
    container.style.position = 'relative';
    container.style.zIndex = 99999999;

    container.innerHTML = '\n    <!-- Root element of PhotoSwipe. Must have class pswp. -->\n    <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">\n\n        <!-- Background of PhotoSwipe.\n             It\'s a separate element as animating opacity is faster than rgba(). -->\n        <div class="pswp__bg"></div>\n\n        <!-- Slides wrapper with overflow:hidden. -->\n        <div class="pswp__scroll-wrap">\n\n            <!-- Container that holds slides.\n                PhotoSwipe keeps only 3 of them in the DOM to save memory.\n                Don\'t modify these 3 pswp__item elements, data is added later on. -->\n            <div class="pswp__container">\n                <div class="pswp__item"></div>\n                <div class="pswp__item"></div>\n                <div class="pswp__item"></div>\n            </div>\n\n            <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->\n            <div class="pswp__ui pswp__ui--hidden">\n\n                <div class="pswp__top-bar" style="background: transparent !important; padding-top: env(safe-area-inset-top); padding-top: const(safe-area-inset-top);">\n\n                    <!--  Controls are self-explanatory. Order can be changed. -->\n\n                    <div class="pswp__counter"></div>\n\n                    <span class="glyphicon glyphicon-remove pswp__button pswp__button--close" title="Close (Esc)" style="color: #FFF !important;font-size: 20pt;padding: 15px;width:55px;height:55px">\n                    </span>\n\n                    <button class="pswp__button pswp__button--share" title="Share"></button>\n\n                    <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>\n\n                    <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>\n\n                    <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->\n                    <!-- element will get class pswp__preloader--active when preloader is running -->\n                    <div class="pswp__preloader">\n                        <div class="pswp__preloader__icn">\n                          <div class="pswp__preloader__cut">\n                            <div class="pswp__preloader__donut"></div>\n                          </div>\n                        </div>\n                    </div>\n                </div>\n\n                <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">\n                    <div class="pswp__share-tooltip"></div>\n                </div>\n\n                <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">\n                </button>\n\n                <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">\n                </button>\n\n                <div class="pswp__caption">\n                    <div class="pswp__caption__center"></div>\n                </div>\n\n            </div>\n\n        </div>\n\n    </div>\n    ';

    if (window.location.pathname.toLowerCase().indexOf('plugintester') >= 0) {
      document.getElementById('app').appendChild(container);
    } else {
      document.body.appendChild(container);
    }

    this.initialized = true;
  }
};
"use strict";

function searchEngineAPI(context) {
    this.context = context;
};

searchEngineAPI.prototype = {
    _sendRequest: function _sendRequest(verb, method, data, cb) {
        var json = "";
        var xhr = new XMLHttpRequest();
        var url = window.siteConfig.endPoints.searchEngineHost + "/search_engine/" + method;

        verb = verb.toUpperCase();
        if (verb === "GET" && data) {
            var query = "?";

            for (var key in data) {
                if (data.hasOwnProperty(key)) {
                    query += key + "=" + encodeURIComponent(data[key]) + "&";
                }
            }

            query = query.slice(0, -1);
            url += query;
        } else {
            json = JSON.stringify(data);
        }

        xhr.open(verb, url, true);
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.setRequestHeader("app_id", this.context.appId);
        xhr.setRequestHeader("x-api-key", "GpzNPRVIld3WxoKDAXJZM7cjoUA5p0rS6pqYkCqy"); //keep this hardcoded
        xhr.onreadystatechange = function () {
            var response = null;
            try {
                response = JSON.parse(xhr.responseText);
            } catch (e) {}
            if (xhr.readyState == 4) {
                if (xhr.status === 200) {
                    if (cb) cb(null, response);
                } else {
                    if (cb) cb(response);
                }
            }
        };
        xhr.send(json);
    },
    /**
     * Search data in buildfire search engine.
     * @param {Object} options - search options.
     * @param {string} options.searchText - Your search text.
     * @param {boolean} [options.linkedUser] - If true this will return all public data and the data added by the current logged user.
     * @param {string} [options.pageSize = 50]  - Number of data returned per page size.
     * @param {string} [options.pageIndex = 0] - Number of returned page.
     * @param {string} [options.preHighlightTag] - Use in conjunction with post_tags to define the HTML tags to use for the highlighted text.
     * @param {string} [options.postHighlightTag] - Use in conjunction with pre_tags to define the HTML tags to use for the highlighted text.
     */

    /**
     * @callback cb
     * @param {Object} error
     *
     * @param {Object} response
     * @param {Object} response.hits
     * @param {Object} response.hits.total
     * @param {Object} response.hits.max_score
     * @param {Object[]} response.hits.hits - Array of matched documents/
     */
    search: function search(params, callback) {
        var self = this;
        if (!params) {
            if (callback) callback("invalid params", null);
            return;
        }

        /*
        if (!params.searchText) {
            if (callback)
                callback("Missing searchText parameter", null);
            return;
        }
         */

        var data = {
            instance_id: this.context.instanceId,
            plugin_id: this.context.pluginId,
            tag: params.tag,
            page_index: params.pageIndex,
            page_size: params.pageSize,
            search_text: params.searchText,
            pre_highlight_tag: params.preHighlightTag,
            post_highlight_tag: params.postHighlightTag
        };

        function _send() {
            self._sendRequest('POST', 'search', data, function (err, data) {
                if (callback) callback(err, data);
            });
        }

        if (params.linkedUser) {
            window.authAPI.getCurrentUser(function (err, user) {
                data.user_id = user && user._id ? user._id.toString() : null;
                if (!data.user_id) {
                    if (callback) callback({ message: 'no user found' });
                } else {
                    _send();
                }
            });
        } else {
            _send();
        }
    },
    /**
     * Insert data in buildfire search engine.
     * @param {Object} options - insert options.
     * @param {boolean} [options.linkedUser] - This will make the data linked to the current logged user, which means it will be private.
     * @param {string} options.tag - A unique key for your data, this is important for categorizing your data.
     * @param {string} options.title - Title for your data, this will be searchable by our search engine.
     * @param {string} [options.description] - Description for your data, this will be searchable by our search engine.
     * @param {string} [options.keywords] - Any keywords related to your data, this will be searchable by our search engine.
     * @param {string} [options.imageUrl].
     * @param {Object} [options.data] - You can add whatever you want here, this won't be searchable by our search engine.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     * @param {string} response.id - The id of the newly inserted document.
     */
    insert: function insert(params, callback) {
        var self = this;

        if (!params) {
            if (callback) callback({ message: "invalid params" }, null);
            return;
        }

        if (!params.tag) {
            if (callback) callback({ message: "Missing params tag" }, null);
            return;
        }

        if (!params.title) {
            if (callback) callback({ message: "Missing params title" }, null);
            return;
        }

        var data = {
            instance_id: this.context.instanceId,
            plugin_id: this.context.pluginId,
            tag: params.tag,
            title: params.title,
            description: params.description,
            keywords: params.keywords,
            image_url: params.imageUrl,
            data: params.data
        };

        function _send() {
            self._sendRequest('POST', '', data, function (err, data) {
                if (callback) callback(err, data);
            });
        }

        if (params.linkedUser) {
            window.authAPI.getCurrentUser(function (err, user) {
                data.user_id = user && user._id ? user._id.toString() : null;

                if (!data.user_id) {
                    if (callback) callback({ message: 'no user found' });
                } else {
                    _send();
                }
            });
        } else {
            _send();
        }
    },
    /**
     * save data in buildfire search engine.
     * @param {Object} options - save options.
     * @param {boolean} [options.linkedUser] - This will make the data linked to the current logged user, which means it will be private.
     * @param {string} options.key - A unique key for your document, this will be the id of your document.
     * @param {string} options.tag - A unique key for your data, this is important for categorizing your data.
     * @param {string} options.title - Title for your data, this will be searchable by our search engine.
     * @param {string} [options.description] - Description for your data, this will be searchable by our search engine.
     * @param {string} [options.keywords] - Any keywords related to your data, this will be searchable by our search engine.
     * @param {string} [options.imageUrl].
     * @param {Object} [options.data] - You can add whatever you want here, this won't be searchable by our search engine.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     * @param {string} response.id - The id of the saved document.
     */
    save: function save(params, callback) {
        var self = this;

        if (!params) {
            if (callback) callback({ message: "invalid params" }, null);
            return;
        }

        if (!params.key) {
            if (callback) callback({ message: "Missing params key" }, null);
            return;
        }

        if (!params.tag) {
            if (callback) callback({ message: "Missing params tag" }, null);
            return;
        }

        if (!params.title) {
            if (callback) callback({ message: "Missing params title" }, null);
            return;
        }

        var data = {
            instance_id: this.context.instanceId,
            plugin_id: this.context.pluginId,
            key: params.key,
            tag: params.tag,
            title: params.title,
            description: params.description,
            keywords: params.keywords,
            image_url: params.imageUrl,
            data: params.data
        };

        function _send() {
            self._sendRequest('POST', 'save', data, function (err, data) {
                if (callback) callback(err, data);
            });
        }

        if (params.linkedUser) {
            window.authAPI.getCurrentUser(function (err, user) {
                data.user_id = user && user._id ? user._id.toString() : null;

                if (!data.user_id) {
                    if (callback) callback({ message: 'no user found' });
                } else {
                    _send();
                }
            });
        } else {
            _send();
        }
    },
    /**
     * Update data in buildfire search engine.
     * @param {Object} options - update options.
     * @param {string} options.id - An id for your document to update it.
     * @param {boolean} [options.linked_user] - This will make the data linked to the current logged user, which means it will be private.
     * @param {string} options.tag - A unique key for your data, this is important for categorizing your data.
     * @param {string} options.title - Title for your data, this will be searchable by our search engine.
     * @param {string} [options.description] - Description for your data, this will be searchable by our search engine.
     * @param {string} [options.keywords] - Any keywords related to your data, this will be searchable by our search engine.
     * @param {string} [options.image_url].
     * @param {Object} [options.data] - You can add whatever you want here, this won't be searchable by our search engine.
     */

    /**
     * @callback cb
     * @param {Object} error
     *
     * @param {Object} response
     * @param {string} response.id - The id of the updated document.
     */
    update: function update(params, callback) {
        var self = this;

        if (!params) {
            if (callback) callback({ message: "invalid params" }, null);
            return;
        }

        if (!params.id) {
            if (callback) callback({ message: "Missing params id" }, null);
            return;
        }

        if (!params.tag) {
            if (callback) callback({ message: "Missing params tag" }, null);
            return;
        }

        if (!params.title) {
            if (callback) callback({ message: "Missing params title" }, null);
            return;
        }

        var data = {
            id: params.id,
            instance_id: this.context.instanceId,
            plugin_id: this.context.pluginId,
            tag: params.tag,
            title: params.title,
            description: params.description,
            keywords: params.keywords,
            image_url: params.imageUrl,
            data: params.data
        };

        function _send() {
            self._sendRequest('PUT', '', data, function (err, data) {
                if (callback) callback(err, data);
            });
        }

        if (params.linkedUser) {
            window.authAPI.getCurrentUser(function (err, user) {
                data.user_id = user && user._id ? user._id.toString() : null;

                if (!data.user_id) {
                    if (callback) callback({ message: 'no user found' });
                } else {
                    _send();
                }
            });
        } else {
            _send();
        }
    },
    /**
     * Delete data in buildfire search engine.
     * @param {Object} options - delete options.
     * @param {string} options.id - An id for your document to delete it.
     * @param {string} options.tag - A unique key for your data, this is important for categorizing your data.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {boolean} response
     */
    delete: function _delete(params, callback) {
        var self = this;

        if (!params) {
            if (callback) callback({ message: "invalid params" }, null);
            return;
        }

        if (!params.id) {
            if (callback) callback({ message: "Missing params id" }, null);
            return;
        }

        if (!params.tag) {
            if (callback) callback({ message: "Missing params tag" }, null);
            return;
        }

        var data = {
            id: params.id,
            instance_id: this.context.instanceId,
            plugin_id: this.context.pluginId,
            tag: params.tag
        };

        function _send() {
            self._sendRequest('DELETE', '', data, function (err, data) {
                if (callback) callback(err, data);
            });
        }

        window.authAPI.getCurrentUser(function (err, user) {
            data.user_id = user && user._id ? user._id.toString() : null;
            _send();
        });
    },
    get feeds() {
        var parentThis = this;
        return {
            /**
             * Attach feed in buildfire search engine.
             * @param {Object} options - attach options.
             * @param {string} options.tag - A unique key for your data, this is important for categorizing your data.
             * @param {string} options.title - Title for your data.
             * @param {string} options.feedType - feed type, available types : [rss].
             * @param {Object} options.feedConfig
             * @param {string} options.feedConfig.url - Your feed service url.
             * @param {Object} [options.feedItemConfig]
             * @param {string} [options.feedItemConfig.uniqueKey - Your feed unique id]
             * @param {string} [options.feedItemConfig.titleKey]
             * @param {string} [options.feedItemConfig.descriptionKey]
             * @param {string} [options.feedItemConfig.urlKey]
             * @param {string} [options.feedItemConfig.publishDateKey]
             * @param {string} [options.feedItemConfig.imageUrlKey]
             */

            /**
             * @callback cb
             * @param {Object} error
             * @param {Object} response
             * @param {string} response - return true.
             */
            insert: function insert(params, callback) {
                if (!params) {
                    if (callback) callback({ message: "invalid params" }, null);
                    return;
                }

                if (!params.tag) {
                    if (callback) callback({ message: "Missing params tag" }, null);
                    return;
                }

                if (!params.title) {
                    if (callback) callback({ message: "Missing params title" }, null);
                    return;
                }

                if (!params.feedType) {
                    if (callback) callback({ message: "Missing params feedType" }, null);
                    return;
                }

                if (!params.feedConfig || !params.feedConfig.url) {
                    if (callback) callback({ message: "Missing params feedConfig.url" }, null);
                    return;
                }

                if (!params.feedItemConfig) {
                    params.feedItemConfig = {};
                }

                var data = {
                    instance_id: parentThis.context.instanceId,
                    plugin_id: parentThis.context.pluginId,
                    tag: params.tag,
                    title: params.title,
                    description: params.description,
                    feed_type: params.feedType,
                    feed_config: { url: params.feedConfig.url },
                    feed_item_config: {
                        unique_key: params.feedItemConfig.uniqueKey,
                        title_key: params.feedItemConfig.titleKey,
                        description_key: params.feedItemConfig.descriptionKey,
                        url_key: params.feedItemConfig.urlKey,
                        publish_date_key: params.feedItemConfig.publishDateKey,
                        image_url_key: params.feedItemConfig.imageUrlKey
                    }
                };

                function _send() {
                    parentThis._sendRequest('POST', 'feeds', data, function (err, data) {
                        if (callback) callback(err, data);
                    });
                }

                _send();
            },

            /**
             * delete feed from buildfire search engine.
             * @param {Object} options - delete options.
             * @param {string} options.tag - A unique key for your data, this is important for categorizing your data.
             * @param {string} options.feedId - Feed Id returned from feeds.get method.
             * @param {boolean} [options.removeFeedData] - If true, this will remove all feed data inside the app that's related to this feed.
             */

            /**
             * @callback cb
             * @param {Object} error
             * @param {boolean} response
             */
            delete: function _delete(params, callback) {
                if (!params) {
                    if (callback) callback({ message: "invalid params" }, null);
                    return;
                }

                if (!params.tag) {
                    if (callback) callback({ message: "Missing params tag" }, null);
                    return;
                }

                if (!params.feedId) {
                    if (callback) callback({ message: "Missing params feedId" }, null);
                    return;
                }

                var data = {
                    instance_id: parentThis.context.instanceId,
                    plugin_id: parentThis.context.pluginId,
                    tag: params.tag,
                    feed_id: params.feedId,
                    remove_feed_data: params.removeFeedData
                };

                function _send() {
                    parentThis._sendRequest('DELETE', 'feeds', data, function (err, data) {
                        if (callback) callback(err, data);
                    });
                }

                _send();
            },

            /**
             * get feeds from buildfire search engine.
             * @param {Object} options - get options.
             * @param {string} options.tag - A unique key for your data, this is important for categorizing your data.
             * @param {string} options.feedType - feed type, available types : [rss].
             */

            /**
             * @callback cb
             * @param {Object} error
             * @param {Object} response
             * @param {string} response - return array of feeds.
             */
            get: function get(params, callback) {
                if (!params) {
                    if (callback) callback({ message: "invalid params" }, null);
                    return;
                }

                if (!params.tag) {
                    if (callback) callback({ message: "Missing params tag" }, null);
                    return;
                }

                if (!params.feedType) {
                    if (callback) callback({ message: "Missing params feedType" }, null);
                    return;
                }

                var data = {
                    instance_id: parentThis.context.instanceId,
                    plugin_id: parentThis.context.pluginId,
                    tag: params.tag,
                    feed_type: params.feedType
                };

                function _send() {
                    parentThis._sendRequest('GET', 'feeds', data, function (err, data) {
                        if (callback) callback(err, data);
                    });
                }

                _send();
            }
        };
    }
};
"use strict";

function CreditsAPI(context) {
    this.context = context;
    if (!this.context) {
        throw Error('invalid creditsSystem context');
    }
    if (this.context.apiKeys) {
        this.secretKey = this.context.apiKeys.creditsSystemSecretKey;
    }
};

CreditsAPI.prototype = {
    _sendRequest: function _sendRequest(verb, method, data, cb) {
        var json = "";
        var public_key = undefined;
        var secret_key = undefined;
        if (data.public_key) {
            public_key = data.public_key;
        }
        if (data.secret_key) {
            secret_key = data.secret_key;
        }
        delete data.public_key;
        delete data.secret_key;

        var xhr = new XMLHttpRequest();
        var url = window.siteConfig.endPoints.creditSystemHost + "/credit_system/" + method;

        verb = verb.toUpperCase();
        if (verb === "GET" && data) {
            var query = "?";

            for (var key in data) {
                if (data.hasOwnProperty(key)) {
                    query += key + "=" + encodeURIComponent(data[key]) + "&";
                }
            }

            query = query.slice(0, -1);
            url += query;
        } else {
            json = JSON.stringify(data);
        }

        xhr.open(verb, url, true);
        xhr.setRequestHeader("Content-Type", "application/json");
        if (public_key) {
            xhr.setRequestHeader("public_key", public_key);
        }
        if (secret_key) {
            xhr.setRequestHeader("secret_key", secret_key);
        }

        xhr.setRequestHeader("x-api-key", "ZBtYjI3ZlNaKdhWApTjIF3NYaynO4snJ1zikGTDr");
        /*keep this hardcoded, after discussion between Danny and Ayman, they decide to create generic API Key
           for credit system in order to keep track of AWSGateway API Request for credit system
         */
        xhr.onreadystatechange = function () {
            var response = null;
            try {
                response = JSON.parse(xhr.responseText);
            } catch (e) {}
            if (xhr.readyState == 4) {
                if (xhr.status === 200) {
                    if (cb) cb(null, response);
                } else {
                    if (cb) cb(response);
                }
            }
        };
        xhr.send(json);
    },

    /**
     * get merchant bundles
     * @param {object} params.jsonConfig - json object representing the configurations for the Merchant.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    updateMerchant: function updateMerchant(params, callback) {
        var self = this;

        appApiKeys.get(function (err, keys) {
            var data = {
                secret_key: self.secretKey,
                json_config: params.jsonConfig
            };

            function _send() {
                self._sendRequest('PUT', 'merchants', data, function (err, data) {
                    if (callback) callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                data.user_token = user && user._id ? user._id.toString() : null;
                if (!data.user_token) {
                    if (callback) callback({ message: 'no logged in user' });
                } else {
                    _send();
                }
            });
        });
    },

    /**
     * add credit for user.
     * @param {string} params.bundle_id - the bundle id which has been selected by the user
     * @param {string} params.memo
     * @param {string} options.xRef1
     * @param {string} options.xRef2
     * @param {string} options.xRef3
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    purchaseBundle: function purchaseBundle(params, callback) {
        var self = this;
        if (!params) {
            if (callback) callback("invalid params", null);
            return;
        }

        if (!params.bundleId) {
            if (callback) callback("Missing bundleId parameter", null);
            return;
        }

        function purchase(_ref) {
            var sessionId = _ref.sessionId,
                transactionId = _ref.transactionId;

            if (!transactionId) {
                if (callback) callback("Missing transactionId parameter in purchase", null);
                return;
            }

            if (!sessionId) {
                if (callback) callback("Missing sessionId parameter in purchase", null);
                return;
            }

            appApiKeys.get(function (err, keys) {
                var data = {
                    public_key: keys.creditsSystemPublicKey,
                    payment_provider: params.paymentProvider,
                    transaction_id: transactionId,
                    stripe: {
                        session_id: sessionId
                    },
                    bundle_id: params.bundleId,
                    access_token: params.access_token
                };

                function _send() {
                    self._sendRequest('POST', 'credits/purchase', data, function (err, data) {
                        if (callback) callback(err, data);
                    });
                }

                window.authAPI.getCurrentUser(function (err, user) {
                    data.access_token = user && user.accessToken ? user.accessToken.toString() : null;

                    if (!data.access_token) {
                        if (callback) callback({ message: 'no logged in user' });
                    } else {
                        _send();
                    }
                });
            });
        }

        function start() {
            params.paymentProvider = 'stripe';

            appApiKeys.get(function (err, keys) {
                var data = {
                    public_key: keys.creditsSystemPublicKey,
                    payment_provider: params.paymentProvider,
                    bundle_id: params.bundleId,
                    memo: params.memo,
                    x_ref_1: params.xRef1,
                    x_ref_2: params.xRef2,
                    x_ref_3: params.xRef3,
                    access_token: params.access_token
                };

                self._sendRequest('POST', 'credits/transactions', data, function (err, data) {
                    if (err) {
                        callback(err);
                    } else if (data && data.transactionId && data.stripe && data.stripe.clientReferenceId) {
                        //create stripe api instance
                        var stripeApi = new StripeAPI(self.context);

                        //run stripe checkout
                        stripeApi.purchase({
                            items: [{ sku: data.stripe.skuId }],
                            clientReferenceId: data.stripe.clientReferenceId
                        }, function (err, result) {
                            if (!err) {
                                purchase({
                                    transactionId: data.transactionId,
                                    sessionId: result.id
                                });
                            }
                        });
                    } else {
                        callback({ message: "missing stripe data in transaction" });
                    }
                });
            });
        }

        window.authAPI.getCurrentUser(function (err, user) {
            params.access_token = user && user.accessToken ? user.accessToken.toString() : null;

            if (!params.access_token) {
                if (callback) callback({ message: 'no logged in user' });
            } else {
                start();
            }
        });
    },

    /**
     * get merchant
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    getMerchant: function getMerchant(params, callback) {
        var self = this;

        appApiKeys.get(function (err, keys) {
            var data = {
                public_key: keys.creditsSystemPublicKey,
                secret_key: self.secretKey
            };

            function _send() {
                self._sendRequest('GET', 'merchants', data, function (err, data) {
                    if (callback) callback(err, data);
                });
            }

            _send();
        });
    },

    /**
     * get merchant bundles
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    getBundles: function getBundles(params, callback) {
        var self = this;

        appApiKeys.get(function (err, keys) {
            var data = {
                public_key: keys.creditsSystemPublicKey,
                secret_key: self.secretKey
            };

            function _send() {
                self._sendRequest('GET', 'bundles', data, function (err, data) {
                    if (callback) callback(err, data);
                });
            }

            _send();
        });
    },

    deleteBundle: function deleteBundle(params, callback) {
        var self = this;
        if (!params) {
            if (callback) callback("invalid params", null);
            return;
        }

        appApiKeys.get(function (err, keys) {
            var data = {
                secret_key: self.secretKey,
                bundle_id: params.bundleId
            };

            function _send() {
                self._sendRequest('DELETE', 'bundles', data, function (err, data) {
                    if (callback) callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                data.user_token = user && user._id ? user._id.toString() : null;
                if (!data.user_token) {
                    if (callback) callback({ message: 'no logged in user' });
                } else {
                    _send();
                }
            });
        });
    },

    insertBundle: function insertBundle(params, callback) {
        var self = this;
        if (!params) {
            if (callback) callback("invalid params", null);
            return;
        }

        appApiKeys.get(function (err, keys) {
            var data = {
                secret_key: self.secretKey,
                name: params.name,
                stripe_product_id: params.stripeProductId,
                description: params.description,
                credit_amount: params.creditAmount,
                user_token: params.userToken,
                image_url: params.imageUrl
            };

            function _send() {
                self._sendRequest('POST', 'bundles', data, function (err, data) {
                    if (callback) callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                data.user_token = user && user._id ? user._id.toString() : null;
                if (!data.user_token) {
                    if (callback) callback({ message: 'no logged in user' });
                } else {
                    _send();
                }
            });
        });
    },

    updateBundle: function updateBundle(params, callback) {
        var self = this;
        if (!params) {
            if (callback) callback("invalid params", null);
            return;
        }

        appApiKeys.get(function (err, keys) {
            var data = {
                secret_key: self.secretKey,
                name: params.name,
                stripe_product_id: params.stripeProductId,
                description: params.description,
                credit_amount: params.creditAmount,
                bundle_id: params.bundleId,
                user_token: params.userToken,
                image_url: params.imageUrl
            };

            function _send() {
                self._sendRequest('PUT', 'bundles', data, function (err, data) {
                    if (callback) callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                data.user_token = user && user._id ? user._id.toString() : null;
                if (!data.user_token) {
                    if (callback) callback({ message: 'no logged in user' });
                } else {
                    _send();
                }
            });
        });
    },

    /**
     * Consume User Credits
     * @param {number} params.userToken - A token representing the user wants to consume credit.
     * @param {number} params.creditAmount - Credit Amount.
     * @param {string} params.xRef1 - Ref1.
     * @param {string} params.xRef2 - Ref2.
     * @param {string} params.xRef3 - Ref3.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    adjustCredits: function adjustCredits(params, callback) {
        var self = this;
        if (!params) {
            if (callback) callback("invalid params", null);
            return;
        }

        if (!params.userToken) {
            if (callback) callback("invalid userToken", null);
            return;
        }

        if (!params.creditAmount) {
            if (callback) callback("invalid creditAmount", null);
            return;
        }

        appApiKeys.get(function (err, keys) {
            var data = {
                secret_key: self.secretKey,
                user_token: params.userToken,
                credit_amount: params.creditAmount,
                memo: params.memo,
                x_ref_1: params.xRef1,
                x_ref_2: params.xRef2,
                x_ref_3: params.xRef3
            };

            function _send() {
                self._sendRequest('POST', 'credits/adjust', data, function (err, data) {
                    if (callback) callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                data.created_by_user_token = user && user._id ? user._id.toString() : null;
                if (!data.created_by_user_token) {
                    if (callback) callback({ message: 'no logged in user' });
                } else {
                    _send();
                }
            });
        });
    },

    /**
     * Consume User Credits
     * @param {number} params.creditAmount - Credit Amount
     * @param {string} params.xRef1 - Ref1.
     * @param {string} params.xRef2 - Ref2.
     * @param {string} params.xRef3 - Ref3.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    consumeCredits: function consumeCredits(params, callback) {
        var self = this;
        if (!params) {
            if (callback) callback("invalid params", null);
            return;
        }

        if (!params.creditAmount) {
            if (callback) callback("Missing creditAmount parameter", null);
            return;
        }

        appApiKeys.get(function (err, keys) {
            var data = {
                public_key: keys.creditsSystemPublicKey,
                credit_amount: params.creditAmount,
                x_ref_1: params.xRef1,
                x_ref_2: params.xRef2,
                x_ref_3: params.xRef3,
                memo: params.memo
            };

            function _send() {
                self._sendRequest('POST', 'credits/consume', data, function (err, data) {
                    if (callback) callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                data.access_token = user && user.accessToken ? user.accessToken.toString() : null;
                if (!data.access_token) {
                    if (callback) callback({ message: 'no logged in user' });
                } else {
                    _send();
                }
            });
        });
    },

    /**
     * Transfer Credits
     * @param {number} params.creditAmount - A token representing the users who you need credit balance for.
     * @param {string} params.receiverUserToken - A token representing the user who you need to transfer a credit.
     * @param {string} params.receiverUserEmail - An email representing the user who you need to transfer a credit.
     * @param {string} params.xRef1 - Ref1.
     * @param {string} params.xRef2 - Ref2.
     * @param {string} params.xRef3 - Ref3.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    transferCredits: function transferCredits(params, callback) {
        var self = this;
        if (!params) {
            if (callback) callback("invalid params", null);
            return;
        }

        if (!params.creditAmount) {
            if (callback) callback("Missing creditAmount parameter", null);
            return;
        }

        if (!(params.receiverUserToken || params.receiverUserEmail)) {
            if (callback) callback("Missing (receiverUserToken or receiverUserEmail) parameter", null);
            return;
        }

        appApiKeys.get(function (err, keys) {
            var data = {
                public_key: keys.creditsSystemPublicKey,
                credit_amount: params.creditAmount,
                receiver_user_token: params.receiverUserToken,
                receiver_user_email: params.receiverUserEmail,
                x_ref_1: params.xRef1,
                x_ref_2: params.xRef2,
                x_ref_3: params.xRef3
            };

            function _send() {
                self._sendRequest('POST', 'credits/transfer', data, function (err, data) {
                    if (callback) callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                data.access_token = user && user.accessToken ? user.accessToken.toString() : null;
                if (!data.access_token) {
                    if (callback) callback({ message: 'no logged in user' });
                } else {
                    _send();
                }
            });
        });
    },

    /**
     * Search Transactions
     * @param {array} params.usersTokens - A token representing the users who you need credit balance for.
     * @param {Number} params.pageSize - Page Size.
     * @param {Number} params.pageIndex - Page Index.
     * @param {Date} params.fromDate - From Date.
     * @param {Date} params.toDate - To Date.
     * @param {string} params.xRef1 - X Ref Value.
     * @param {string} params.xRef2 - X Ref Value.
     * @param {string} params.xRef3 - X Ref Value.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    searchTransactions: function searchTransactions(params, callback) {
        var self = this;
        if (!params) {
            if (callback) callback("invalid params", null);
            return;
        }

        appApiKeys.get(function (err, keys) {
            var data = {
                public_key: keys.creditsSystemPublicKey,
                secret_key: self.secretKey,
                users_tokens: params.usersTokens,
                page_size: params.pageSize,
                page_index: params.pageIndex,
                from_date: params.fromDate,
                to_date: params.toDate,
                x_ref_1: params.xRef1,
                x_ref_2: params.xRef2,
                x_ref_3: params.xRef3
            };

            function _send() {
                self._sendRequest('POST', 'credits/transactions/search', data, function (err, data) {
                    if (callback) callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                if (data.public_key) {
                    data.access_token = user && user.accessToken ? user.accessToken.toString() : null;
                    if (!data.access_token) {
                        if (callback) callback({ message: 'no logged in user' });
                        return;
                    }
                }
                _send();
            });
        });
    },

    /**
     * get user
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    getUser: function getUser(params, callback) {
        var self = this;
        if (!params) {
            if (callback) callback("invalid params", null);
            return;
        }

        appApiKeys.get(function (err, keys) {
            var data = {
                public_key: keys.creditsSystemPublicKey
            };
            if (params.secretKey) {
                data.secret_key = params.secretKey;
            }

            function _send() {
                self._sendRequest('GET', 'credits/user', data, function (err, data) {
                    if (callback) callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                data.access_token = user && user.accessToken ? user.accessToken.toString() : null;
                if (!data.access_token) {
                    if (callback) callback({ message: 'no logged in user' });
                } else {
                    _send();
                }
            });
        });
    },

    /**
     * search users
     * @param {array} params.usersTokens - A token representing the users who you need credit balance for.
     * @param {Number} params.pageSize - Page Size.
     * @param {Number} params.pageIndex - Page Index.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    searchUsers: function searchUsers(params, callback) {
        var self = this;
        if (!params) {
            if (callback) callback("invalid params", null);
            return;
        }

        appApiKeys.get(function (err, keys) {
            var data = {
                secret_key: self.secretKey,
                users_tokens: params.usersTokens,
                page_size: params.pageSize,
                page_index: params.pageIndex
            };

            function _send() {
                self._sendRequest('POST', 'credits/users', data, function (err, data) {
                    if (callback) callback(err, data);
                });
            }

            _send();
        });
    },
    /**
     * Get Transaction logs
      * @param {transactionId} transaction id.
      */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    getTransactionsLogs: function getTransactionsLogs(params, callback) {
        var self = this;
        if (!params) {
            if (callback) callback("invalid params", null);
            return;
        }

        appApiKeys.get(function (err, keys) {
            if (!params.creditTransactionId) {
                if (callback) callback("Missing creditTransactionId parameter", null);
                return;
            }

            var data = {
                secret_key: self.secretKey
            };

            function _send() {
                self._sendRequest('GET', 'credits/transaction/' + params.creditTransactionId + '/logs', data, function (err, data) {
                    if (callback) callback(err, data);
                });
            }

            _send();
        });
    }
};
"use strict";

function StripeAPI(context) {
    this.context = context;
    if (!this.context) {
        throw Error('stripeAPI: invalid context');
    }
};

StripeAPI.prototype = {
    _sendRequest: function _sendRequest(verb, method, data, header, cb) {
        var json = "";
        var xhr = new XMLHttpRequest();
        var url = window.siteConfig.endPoints.stripeHost + "/stripe/" + method;

        verb = verb.toUpperCase();
        if (verb === "GET" && data) {
            var query = "?";

            for (var key in data) {
                if (data.hasOwnProperty(key)) {
                    if (typeof data[key] != "undefined") {
                        query += key + "=" + encodeURIComponent(data[key]) + "&";
                    }
                }
            }

            query = query.slice(0, -1);
            url += query;
        } else {
            json = JSON.stringify(data);
        }

        xhr.open(verb, url, true);
        xhr.setRequestHeader("Content-Type", "application/json");
        if (header) {
            for (var key in header) {
                if (header.hasOwnProperty(key)) {
                    xhr.setRequestHeader(key, header[key]);
                }
            }
        }

        xhr.onreadystatechange = function () {
            var response = null;
            try {
                response = JSON.parse(xhr.responseText);
            } catch (e) {}
            if (xhr.readyState == 4) {
                if (xhr.status === 200) {
                    if (cb) cb(null, response);
                } else {
                    if (cb) cb(response);
                }
            }
        };
        xhr.send(json);
    },
    _loadScript: function _loadScript(options, callback) {
        var script = document.createElement("script");
        script.type = "text/javascript";

        // If the browser is Internet Explorer.
        if (script.readyState) {
            script.onreadystatechange = function () {
                if (script.readyState == "loaded" || script.readyState == "complete") {
                    script.onreadystatechange = null;
                    if (callback) callback();
                }
            };
            // For any other browser.
        } else {
            script.onload = function () {
                if (callback) callback();
            };
        }

        script.src = options.url;
        if (options.attr) {
            for (var key in options.attr) {
                script.setAttribute(key, options.attr[key]);
            }
        }

        var scripts = document.getElementsByTagName('script');
        for (var i = scripts.length; i--;) {
            if (scripts[i].src == options.url) {
                if (callback) callback();
                return true;
            }
        }

        document.getElementsByTagName("head")[0].appendChild(script);
    },
    _guid: function _guid() {
        function S4() {
            return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
        }

        return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
    },
    _openStripeCheckout: function _openStripeCheckout(_ref, callback) {
        var items = _ref.items,
            successUrl = _ref.successUrl,
            cancelUrl = _ref.cancelUrl,
            submitType = _ref.submitType,
            customerEmail = _ref.customerEmail,
            sessionId = _ref.sessionId,
            clientReferenceId = _ref.clientReferenceId,
            domain = _ref.domain,
            events = _ref.events;

        var self = this;
        var checkInterval = null;
        var timeoutWithNoVisibility = false;
        var stripePopupWindow = null;
        var successCallback = false;

        function _closeStripeWindow(options) {
            if (!options) {
                options = {};
            }

            clearInterval(checkInterval);

            if (options.invokeDismiss || typeof options.invokeDismiss == "undefined") {
                if (window.richModal) {
                    window.richModal.close();
                }
            }

            if (stripePopupWindow) {
                stripePopupWindow.close();
            }

            if (events && typeof events.onClose === 'function') {
                events.onClose();
            }
        }

        function _checkCheckoutAPI() {

            self._sendRequest('GET', 'checkout/sessions', {
                session_id: sessionId,
                client_reference_id: clientReferenceId
            }, {
                "x-api-key": self.context.apiKeys.awsApiPublicKey
            }, function (err, data) {
                if (data) {
                    //to prevent multiple callbacks
                    if (successCallback) {
                        return;
                    }
                    successCallback = true;

                    _closeStripeWindow();
                    if (callback) {
                        callback(err, data);
                    }
                }
            });
        }

        function _checkCheckoutSession() {
            //start checking every 5 seconds for 15 minutes
            checkInterval = setInterval(function () {

                if (stripePopupWindow && stripePopupWindow.closed) {
                    _closeStripeWindow();
                }

                //check if window is foreground aka Active
                var documentVisibility = window.document.visibilityState;
                if (documentVisibility == "visible") {
                    _checkCheckoutAPI();
                } else {
                    if (!timeoutWithNoVisibility) {
                        timeoutWithNoVisibility = true;

                        setTimeout(function () {
                            timeoutWithNoVisibility = false;
                            _checkCheckoutAPI();
                        }, 60 * 1000);
                    }
                }
            }, 5000);

            // cancel after 15 min
            setTimeout(function () {
                _closeStripeWindow();
            }, 15 * 60 * 1000);
        }

        var url = domain + '/payments/checkout?stripeKey=' + self.context.apiKeys.stripePublicKey;

        if (sessionId) {
            url += "&sessionId=" + encodeURIComponent(sessionId);
        }

        if (clientReferenceId) {
            url += "&clientReferenceId=" + encodeURIComponent(clientReferenceId);
        }

        if (successUrl) {
            url += "&successUrl=" + encodeURIComponent(successUrl);
        }

        if (cancelUrl) {
            url += "&cancelUrl=" + encodeURIComponent(cancelUrl);
        }

        if (submitType) {
            url += "&submitType=" + encodeURIComponent(submitType);
        }

        if (customerEmail) {
            url += "&customerEmail=" + encodeURIComponent(customerEmail);
        }

        if (items) {
            url += "&items=" + encodeURIComponent(JSON.stringify(items));
        }

        //open popup to show cancel button for the user
        if (window.richModal) {
            window.richModal.display({
                title: "",
                showDismissButton: false,
                richContent: "<div style='text-align:center;'>Payment in progress <br/> Please wait...</div>", action: {
                    title: "Cancel", handler: function handler() {
                        _closeStripeWindow({ invokeDismiss: false });
                    }
                }
            });
        }

        if (events && typeof events.onProgress === 'function') {
            events.onProgress(openPaymentWindow);
        }

        function openPaymentWindow() {
            stripePopupWindow = window.open(url, '_blank', 'location=no');
            _checkCheckoutSession();
        }

        if (self.openPaymentWindow === false) {
            //do nothing
        } else {
            openPaymentWindow();
        }
    },
    _checkApiKeys: function _checkApiKeys(callback) {
        var self = this;

        if (self.context.apiKeys && self.context.apiKeys.awsApiPublicKey) {
            if (callback) callback();

            return;
        }

        function _updateKeys() {
            //fetch the keys and save in memory to be ready when it needs
            appApiKeys.get(function (err, keys) {
                self.context.apiKeys = keys;
                if (callback) {
                    callback();
                }
            });
        }

        if (window.appContext.currentApp.apiKeys) {
            if (Object.keys(window.appContext.currentApp.apiKeys).length === 0 && window.appContext.currentApp.apiKeys.constructor === Object) {
                _updateKeys();
            } else {
                self.context.apiKeys = window.appContext.currentApp.apiKeys;

                if (callback) {
                    callback();
                }
            }
        } else {
            _updateKeys();
        }
    },
    /**
     * show stripe popup window.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    pay: function pay(params, callback) {
        var self = this;
        self._checkApiKeys(function () {
            if (!self.context.apiKeys.stripePublicKey) {
                if (callback) callback("Missing stripePublicKey in context", null);
                return;
            }

            self._loadScript({
                url: "https://checkout.stripe.com/checkout.js"
            }, function () {
                var handler = StripeCheckout.configure({
                    key: self.context.apiKeys.stripePublicKey,
                    image: 'https://stripe.com/img/documentation/checkout/marketplace.png',
                    locale: 'auto',
                    token: function token(_token) {
                        // You can access the token ID with `token.id`.
                        // Get the token ID to your server-side code for use.
                        handler.close();

                        if (callback) callback(null, { sourceToken: _token });
                    }
                });

                // Open Checkout with further options:
                handler.open({});

                // Close Checkout on page navigation:
                window.addEventListener('popstate', function () {
                    handler.close();
                });
            });
        });
    },
    /**
     * charge dynamic products using stripe checkout.
     * @param {Object} params.
     * @param {Array.<Object>} params.items - a list of items.
     * @param {string} params.items[].name - The name for the line item.
     * @param {string} [params.items[].description] - The description for the line item.
     * @param {integer} params.items[].amount - The amount to be collected per unit of the line item.
     * @param {string} [params.items[].currency = "usd"] - Three-letter ISO currency code, in lowercase. Must be a supported, for more details check [https://stripe.com/docs/currencies].
     * @param {integer} [params.items[].quantity = 1] - The quantity of the line item being purchased.
     * @param {string} [params.submitType] - Describes the type of transaction being performed by Checkout in order to customize relevant text on the page, such as the submit button. Supported values are "auto, book, donate, or pay".
     * @param {string} [params.customerId] - ID of an existing customer, if one exists. If blank, Checkout will create a new customer object based on information provided during the session. The email stored on the customer will be used to prefill the email field on the Checkout page. If the customer changes their email on the Checkout page, the Customer object will be updated with the new email.
     * @param {string} [params.customerEmail] - If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the customer field.
     * @param {Object} [params.events]
     * @param {function} [params.events.onProgress]
     * @param {function} [params.events.onClose]
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    charge: function charge(params, callback) {
        var self = this;
        self._checkApiKeys(function () {
            if (!self.context.apiKeys.stripePublicKey) {
                if (callback) callback("Missing stripePublicKey in context", null);
                return;
            }

            if (!self.context.apiKeys.awsApiPublicKey) {
                if (callback) callback("Missing awsApiPublicKey in context", null);
                return;
            }

            if (!params) {
                if (callback) callback("invalid params", null);
                return;
            }

            self.openPaymentWindow = params.openPaymentWindow;

            if (!params.items || params.items.length == 0) {
                if (callback) callback("Missing items", null);
                return;
            }

            var _lineItems = [];

            //validate line items required fields
            for (var i = 0; i < params.items.length; i++) {
                if (!params.items[i].name) {
                    if (callback) callback("Missing name in items index " + i, null);
                    return;
                }

                if (!params.items[i].amount) {
                    if (callback) callback("Missing amount in items index " + i, null);
                    return;
                }

                _lineItems.push({
                    name: params.items[i].name,
                    description: params.items[i].description || undefined,
                    amount: params.items[i].amount,
                    currency: params.items[i].currency || "usd",
                    quantity: params.items[i].quantity || 1
                });
            }

            var domain = window.siteConfig.endPoints.appHost;
            // if (window.location.protocol && window.location.protocol.indexOf('http') == 0) {
            //     domain = window.location.protocol + "//" + window.location.host;
            // }

            var _clientRefId = "app_id_" + self.context.appId + "_ref_id_" + self._guid();

            var data = {
                type: 'line_items',
                line_items: _lineItems,
                client_reference_id: _clientRefId,
                success_url: domain + "/payments/success",
                cancel_url: domain + "/payments/cancel"
            };

            if (params.submitType) {
                data["submit_type"] = params.submitType;
            }

            if (params.customerId) {
                data["customer_id"] = params.customerId;
            }

            if (params.customerEmail) {
                data["customer_email"] = params.customerEmail;
            }

            self._sendRequest('POST', 'checkout/sessions', data, {
                "x-api-key": self.context.apiKeys.awsApiPublicKey
            }, function (err, data) {
                if (err) {
                    if (callback) callback(err, data);
                } else {
                    var sessionId = data.sessionId;
                    self._openStripeCheckout({
                        sessionId: sessionId,
                        clientReferenceId: _clientRefId,
                        domain: domain,
                        events: params.events
                    }, function (err, data) {
                        if (callback) {
                            callback(err, data);
                        }
                    });
                }
            });
        });
    },

    /**
     * subscribe to specific stripe plan using stripe checkout.
     * @param {Object} params.
     * @param {Array.<Object>} params.items - a list of items.
     * @param {string} params.items[].planId - Plan ID for this item.
     * @param {integer} [params.items[].quantity = 1] - Quantity for this item.
     * @param {integer} [params.trialPeriodDays ] - The number of trial period days before the customer is charged for the first time. Has to be at least 1.
     * @param {string} [params.customerId] - ID of an existing customer, if one exists. If blank, Checkout will create a new customer object based on information provided during the session. The email stored on the customer will be used to prefill the email field on the Checkout page. If the customer changes their email on the Checkout page, the Customer object will be updated with the new email.
     * @param {string} [params.customerEmail] - If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the customer field.
     * @param {string} [params.metaData] - If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the customer field.
     * @param {Object} [params.events]
     * @param {function} [params.events.onProgress]
     * @param {function} [params.events.onClose]
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    subscribe: function subscribe(params, callback) {
        var self = this;

        self._checkApiKeys(function () {
            if (!self.context.apiKeys.stripePublicKey) {
                if (callback) callback("Missing stripePublicKey in context", null);
                return;
            }

            if (!self.context.apiKeys.awsApiPublicKey) {
                if (callback) callback("Missing awsApiPublicKey in context", null);
                return;
            }

            if (!params) {
                if (callback) callback("invalid params", null);
                return;
            }
            self.openPaymentWindow = params.openPaymentWindow;

            if (!params.items || params.items.length == 0) {
                if (callback) callback("Missing items", null);
                return;
            }

            var _subscriptionData = [];

            //validate subscription data required fields
            for (var i = 0; i < params.items.length; i++) {
                if (!params.items[i].planId) {
                    if (callback) callback("Missing planId in items index " + i, null);
                    return;
                }

                _subscriptionData.push({
                    plan_id: params.items[i].planId,
                    quantity: params.items[i].quantity || 1
                });
            }

            var domain = window.siteConfig.endPoints.appHost;
            // if (window.location.protocol && window.location.protocol.indexOf('http') == 0) {
            //     domain = window.location.protocol + "//" + window.location.host;
            // }

            var _clientRefId = "app_id_" + self.context.appId + "_ref_id_" + self._guid();

            var data = {
                type: 'subscription',
                subscription_data: _subscriptionData,
                client_reference_id: _clientRefId,
                success_url: domain + "/payments/success",
                cancel_url: domain + "/payments/cancel"
            };

            if (params.trialPeriodDays) {
                data["trial_period_days"] = params.trialPeriodDays;
            }

            if (params.customerId) {
                data["customer_id"] = params.customerId;
            }

            if (params.customerEmail) {
                data["customer_email"] = params.customerEmail;
            }

            if (params.metaData) {
                data["metadata"] = params.metaData;
            }

            self._sendRequest('POST', 'checkout/sessions', data, {
                "x-api-key": self.context.apiKeys.awsApiPublicKey
            }, function (err, data) {
                if (err) {
                    if (callback) callback(err, data);
                } else {
                    var sessionId = data.sessionId;
                    self._openStripeCheckout({
                        sessionId: sessionId,
                        clientReferenceId: _clientRefId,
                        domain: domain,
                        events: params.events
                    }, function (err, data) {
                        if (callback) {
                            callback(err, data);
                        }
                    });
                }
            });
        });
    },

    /**
     * purchase stripe products using stripe checkout.
     * @param {Object} params.
     * @param {Array.<Object>} params.items - a list of items.
     * @param {string} params.items[].sku - The ID of the SKU that the customer would like to purchase.
     * @param {integer} [params.items[].quantity = 1] - The quantity of the line item being purchased.
     * @param {string} [params.submitType] - Describes the type of transaction being performed by Checkout in order to customize relevant text on the page, such as the submit button. Supported values are "auto, book, donate, or pay".
     * @param {string} [params.customerEmail] - If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the customer field.
     * @param {string} [params.clientReferenceId] - If provided, this value will be replace the auto-generated clientReferenceId.
     * @param {Object} [params.events]
     * @param {function} [params.events.onProgress]
     * @param {function} [params.events.onClose]
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    purchase: function purchase(params, callback) {
        var self = this;

        self._checkApiKeys(function () {
            if (!self.context.apiKeys.stripePublicKey) {
                if (callback) callback("Missing stripePublicKey in context", null);
                return;
            }

            if (!self.context.apiKeys.awsApiPublicKey) {
                if (callback) callback("Missing awsApiPublicKey in context", null);
                return;
            }

            if (!params) {
                if (callback) callback("invalid params", null);
                return;
            }

            if (!params.items || params.items.length == 0) {
                if (callback) callback("Missing items", null);
                return;
            }

            var _items = [];

            //validate items required fields
            for (var i = 0; i < params.items.length; i++) {
                if (!params.items[i].sku) {
                    if (callback) callback("Missing sku in items index " + i, null);
                    return;
                }

                _items.push({
                    sku: params.items[i].sku,
                    quantity: params.items[i].quantity || 1
                });
            }

            var domain = window.siteConfig.endPoints.appHost;

            // if (window.location.protocol && window.location.protocol.indexOf('http') == 0) {
            //     domain = window.location.protocol + "//" + window.location.host;
            // }

            var _clientRefId = "app_id_" + self.context.appId + "_ref_id_" + self._guid();

            //if provided, replace the auto-generated clientReferenceId
            if (params.clientReferenceId) {
                _clientRefId = params.clientReferenceId;
            }

            var data = {
                items: _items,
                clientReferenceId: _clientRefId,
                successUrl: domain + "/payments/success",
                cancelUrl: domain + "/payments/cancel",
                submitType: params.submitType,
                customerEmail: params.customerEmail,
                domain: domain,
                events: params.events
            };

            self._openStripeCheckout(data, function (err, data) {
                if (callback) {
                    callback(err, data);
                }
            });
        });
    },

    /**
     * get stripe subscription details.
     * @param {Object} params.
     * @param {string} params.subscriptionId - stripe subscription id.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    getSubscription: function getSubscription(params, callback) {
        var self = this;

        self._checkApiKeys(function () {
            if (!self.context.apiKeys.stripePublicKey) {
                if (callback) callback("Missing stripePublicKey in context", null);
                return;
            }

            if (!self.context.apiKeys.awsApiPublicKey) {
                if (callback) callback("Missing awsApiPublicKey in context", null);
                return;
            }

            if (!params) {
                if (callback) callback("invalid params", null);
                return;
            }

            if (!params.subscriptionId) {
                if (callback) callback("Missing params subscriptionId", null);
                return;
            }

            var data = {
                subscription_id: params.subscriptionId
            };

            self._sendRequest('GET', 'customer/subscription', data, {
                "x-api-key": self.context.apiKeys.awsApiPublicKey
            }, function (err, data) {
                if (callback) callback(err, data);
            });
        });
    },

    /**
     * cancel stripe subscription.
     * @param {Object} params.
     * @param {string} params.subscriptionId - stripe subscription id.
     * @param {string} params.customerId - stripe customer id.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    cancelSubscription: function cancelSubscription(params, callback) {
        var self = this;
        self._checkApiKeys(function () {
            if (!self.context.apiKeys.stripePublicKey) {
                if (callback) callback("Missing stripePublicKey in context", null);
                return;
            }

            if (!self.context.apiKeys.awsApiPublicKey) {
                if (callback) callback("Missing awsApiPublicKey in context", null);
                return;
            }

            if (!params) {
                if (callback) callback("invalid params", null);
                return;
            }

            if (!params.subscriptionId) {
                if (callback) callback("Missing params subscriptionId", null);
                return;
            }

            if (!params.customerId) {
                if (callback) callback("Missing params customerId", null);
                return;
            }

            var data = {
                subscription_id: params.subscriptionId,
                customer_id: params.customerId
            };

            self._sendRequest('DELETE', 'customer/subscription', data, {
                "x-api-key": self.context.apiKeys.awsApiPublicKey
            }, function (err, data) {
                if (callback) callback(err, data);
            });
        });
    },

    /**
     * add customer card.
     * @param {Object} params.
     * @param {string} params.customerId - stripe customer id.
     * @param {string} [params.customerEmail] - If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the customer field.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    addCustomerCard: function addCustomerCard(params, callback) {
        var self = this;
        self._checkApiKeys(function () {
            if (!self.context.apiKeys.stripePublicKey) {
                if (callback) callback("Missing stripePublicKey in context", null);
                return;
            }

            if (!self.context.apiKeys.awsApiPublicKey) {
                if (callback) callback("Missing awsApiPublicKey in context", null);
                return;
            }

            if (!params) {
                if (callback) callback("invalid params", null);
                return;
            }

            if (!params.customerId) {
                if (callback) callback("Missing params customerId", null);
                return;
            }

            var domain = window.siteConfig.endPoints.appHost;
            var _clientRefId = "app_id_" + self.context.appId + "_ref_id_" + self._guid();

            var data = {
                mode: "setup",
                type: "setup",
                client_reference_id: _clientRefId,
                success_url: domain + "/payments/success",
                cancel_url: domain + "/payments/cancel"
            };

            if (params.customerEmail) {
                data["customer_email"] = params.customerEmail;
            }

            self._sendRequest('POST', 'checkout/sessions', data, {
                "x-api-key": self.context.apiKeys.awsApiPublicKey
            }, function (err, data) {
                if (err) {
                    if (callback) callback(err, data);
                } else {
                    var sessionId = data.sessionId;
                    self._openStripeCheckout({
                        sessionId: sessionId,
                        clientReferenceId: _clientRefId,
                        domain: domain
                    }, function (err, data) {
                        if (err) {
                            if (callback) {
                                callback(err, null);
                            }
                        } else if (data) {
                            //get setup_intent and send it along with customer_id to "stripe card post API"
                            var insertCustomerCardData = {
                                customer_id: params.customerId,
                                setup_intent: data.setup_intent
                            };

                            self._sendRequest('POST', 'customer/card', insertCustomerCardData, {
                                "x-api-key": self.context.apiKeys.awsApiPublicKey
                            }, function (err, data) {
                                if (callback) {
                                    callback(err, data);
                                }
                            });
                        } else {
                            if (callback) {
                                callback(null, null);
                            }
                        }
                    });
                }
            });
        });
    }
};
"use strict";

var richModal = function () {

    // Prepare DOM for in-app notifications
    var container = document.createElement('div');
    container.id = "richModal";
    container.className = "hidden";

    // Black translucent background
    var screen = document.createElement('div');
    screen.className = 'focus-screen hidden';
    container.appendChild(screen);

    document.body.appendChild(container);

    var currentMessage = null;
    var queue = [];

    /**
     * Creates the node for the modal and populates with message data from the
     * queue.
     *
     * @private
     */
    function renderModal() {
        try {
            if (currentMessage) return;

            // Make sure the user isn't being requested an access code
            if (window.location.hash.indexOf('accessCode') >= 0) {
                return setTimeout(renderModal, 5000); // Try again later
            }

            // Make sure the user isn't on the login screen
            var loginHolder = document.getElementsByClassName('login-holder')[0];
            if (loginHolder && loginHolder.className.indexOf('ng-hide') === -1) {
                return setTimeout(renderModal, 5000); // Try again later
            }

            // Grab the first message from the queue and work with it
            currentMessage = queue.shift();
            var options = currentMessage.options;
            var callback = currentMessage.callback;

            // Remove hidden from container
            var richModalContainer = document.getElementById('richModal');
            richModalContainer.className = '';

            // Fade in focus screen
            var screen = document.getElementsByClassName('focus-screen')[0];
            screen.className = 'focus-screen animated fadeInScreen';
            screen.onclick = function () {
                dismissModal();
            };

            // Create modal
            var modal = document.createElement('div');
            modal.className = 'detail-modal animated fadeInUp';

            if (options.title) {
                var title = document.createElement('h1');
                if (options.title.length > 30) {
                    options.title = options.title.substring(0, 27).trim() + '...';
                }
                title.innerHTML = options.title;
                if (options.design) {
                    var _styles = "";
                    if (options.design.title && options.design.title.align) {
                        _styles += "text-align: " + options.design.title.align + " !important;";
                    }

                    if (options.design.textColor) {
                        _styles += "color: " + options.design.textColor + " !important;";
                    }

                    title.setAttribute('style', _styles);
                }
                modal.appendChild(title);
            }

            if (options.subtitle) {
                var subtitle = document.createElement('span');
                subtitle.className = 'subtitle';
                subtitle.innerHTML = options.subtitle;
                if (options.design) {
                    var _styles = "";
                    if (options.design.subtitle && options.design.subtitle.align) {
                        _styles += "text-align: " + options.design.subtitle.align + " !important;";
                    }

                    if (options.design.textColor) {
                        _styles += "color: " + options.design.textColor + " !important;";
                    }

                    subtitle.setAttribute('style', _styles);
                }
                modal.appendChild(subtitle);
            }

            var richContent = document.createElement('div');
            richContent.className = 'rich-content';
            richContent.innerHTML = options.richContent || '';
            modal.appendChild(richContent);

            var buttonContainer = document.createElement('div');
            buttonContainer.className = 'button-container';
            modal.appendChild(buttonContainer);

            if (options.showDismissButton || typeof options.showDismissButton == "undefined") {
                var dismissButton = document.createElement('button');
                dismissButton.className = options.action ? 'dismiss-button primaryTheme' : 'dismiss-button dismiss-large primaryTheme';
                dismissButton.innerHTML = "Dismiss";
                dismissButton.onclick = function () {
                    dismissModal();
                    if (callback) callback(null, { buttonType: 'dismiss' });
                };
                buttonContainer.appendChild(dismissButton);
            }

            var _customDesignStyles = "";
            if (options.design) {
                if (options.design.fullScreen) {
                    container.classList.add('fullScreen');
                }

                if (options.design.backgroundColor) {
                    _customDesignStyles += 'background : ' + options.design.backgroundColor + ' !important;';
                }

                if (options.design.textColor) {
                    _customDesignStyles += 'color : ' + options.design.textColor + ' !important';
                }

                modal.setAttribute('style', _customDesignStyles);
                dismissButton.setAttribute('style', _customDesignStyles);
            }
        } catch (err) {
            console.error('Failed to render rich modal', err);
        }

        if (options.action) {
            try {
                var actionButton = document.createElement('button');
                actionButton.className = 'action-button primaryTheme';
                if (options.showDismissButton === false) {
                    actionButton.className = 'action-button primaryTheme action-button-large';
                }
                if (options.action.title && options.action.title.length > 11) {
                    options.action.title = options.action.title.substring(0, 8).trim() + '...';
                }
                actionButton.innerHTML = options.action.title || "[ Click ]";

                actionButton.onclick = function () {
                    if (options.action.handler) options.action.handler();else {
                        var actionAPI = new ActionItemsAPI();
                        actionAPI.execute(options.action, function (err, result) {});
                        if (callback) callback(null, { buttonType: 'action', value: options.action });
                    }
                    if (!options.action.preventAutoClose) {
                        dismissModal();
                    }
                };

                if (options.design && _customDesignStyles) {
                    actionButton.setAttribute('style', _customDesignStyles);
                }

                buttonContainer.appendChild(actionButton);
            } catch (err) {
                console.error('Failed to bind action to rich modal', err);
            }
        }
        // Show notification
        document.getElementById('richModal').appendChild(modal);
    }

    /**
     * Fade out the modal and check if anything is remaning on the queue
     */
    function dismissModal() {
        var screen = document.getElementsByClassName('focus-screen')[0];
        if (screen) {
            screen.className = 'focus-screen animated fadeOutScreen';
        }

        var modal = document.getElementsByClassName('detail-modal')[0];
        if (modal) {
            modal.className = 'detail-modal animated fadeOut';
        }

        var modalContainer = document.getElementById('richModal');
        setTimeout(function () {
            if (modal) {
                modal.remove();
            }
            currentMessage = null;

            // If queue has items, continue working on it, or hide modal container
            if (queue.length > 0) {
                setTimeout(renderModal, 300);
            } else {
                if (modalContainer) {
                    modalContainer.className = "hidden";
                }
            }
        }, 700);
    }

    return {
        /**
         * Adds the message to the queue and tries to render it into a modal
         */
        display: function display(options, callback) {
            queue.push({ options: options, callback: callback });
            renderModal();
        },
        close: function close() {
            dismissModal();
        }
    };
}();
'use strict';

var push = {
    pushNotification: null,
    deviceId: null,
    platform: null,
    unseen: 0,
    notificationHandler: null,
    _instance: null,
    init: function init() {
        var configureOptions = function configureOptions() {
            var options = {
                android: {},
                ios: {}
            };

            if (device.platform.toLowerCase() == 'android') {
                options.android = {
                    senderID: '515869937012' //TODO: Get the senderID per app
                };
            } else {
                options.ios = {
                    alert: 'true',
                    badge: 'true',
                    sound: 'true'
                };
            }

            return options;
        };

        var registration = function registration(data) {
            push.registerToken(data.registrationId);
            console.log('push notification registered...');
        };

        var notification = function notification(data) {
            console.log('Notification data: ', data);

            if (data.count && data.additionalData && data.additionalData.foreground) {
                push._instance.getApplicationIconBadgeNumber(function (count) {
                    // ignore when local count matches count on PN; reached max
                    if (data.count != count) {
                        // reset the badge number to prevent phantom count
                        push._instance.setApplicationIconBadgeNumber(function () {
                            push.decrementBadge();
                            console.log("push badge updated from notification", { localCount: count, remoteCount: data.count });
                        }, function (err) {
                            push.decrementBadge();
                            console.log("push badge failed to update from notification", { err: err, localCount: count, remoteCount: data.count });
                        }, parseInt(data.count));
                    }
                }, function (err) {
                    console.log("failed getting local badge", { err: err, remoteCount: data.count });
                });
            } else {
                push.decrementBadge();
            }

            var options = {};
            if (data.additionalData.messageType == 'social') options.buttons = ['Dismiss'];else options.buttons = ['Dismiss', 'Show Details'];

            push.displayMessage(data, options);
        };

        var error = function error(e) {
            console.error(e.message);

            push.err = e;

            var onRegistrationEvent = new CustomEvent('PUSH_ON_REGISTRATION', { 'detail': null });
            document.dispatchEvent(onRegistrationEvent);
        };

        try {
            if (!window.PushNotification) {
                console.error('PushNotification plugin not installed');
                return;
            }

            push.platform = device.platform.toLowerCase();

            var options = configureOptions();

            push._instance = PushNotification.init(options);

            push._instance.on('registration', registration);

            push._instance.on('notification', notification);

            push._instance.on('error', error);

            push.getBadgeNumber(function (err, result) {
                if (!err) {
                    document.dispatchEvent(new CustomEvent('appBadgeNumberUpdated', { 'detail': result }));
                }
            });

            var syncBadgeNumber = function syncBadgeNumber() {
                push.getBadgeNumber(function (err, result) {
                    if (!err) {
                        document.dispatchEvent(new CustomEvent('appBadgeNumberUpdated', { 'detail': result }));
                    }
                });
            };

            document.addEventListener('deviceAppResumed', syncBadgeNumber, false);

            syncBadgeNumber();
        } catch (err) {
            console.error("There was an error on this page.\n\nError description: " + err.message + "\n\n");
        }
    },
    decrementBadge: function decrementBadge(callback) {
        if (push._instance) {
            var os = device.platform ? device.platform.toLowerCase() : '';
            var url = window.siteConfig.endPoints.pushV2 + '/api/app/' + window.appContext.currentApp.appId + '/subscriptions/badges/decrease';
            window.bfUtils.http.post(url, { deviceID: push.deviceId, os: os, value: 1 }).success(function (data) {
                console.log("push badge decremented", data);
            }).error(function (data, status) {
                var error = { data: data, status: status };
                console.error('error decrementing badge', error);
            });

            // don't wait for success or fail on server sync
            push._instance.getApplicationIconBadgeNumber(function (count) {
                if (!count) {
                    if (callback) callback(null, count);
                } else {
                    push._instance.setApplicationIconBadgeNumber(function () {
                        document.dispatchEvent(new CustomEvent('appBadgeNumberUpdated', { 'detail': count - 1 }));
                        if (callback) callback(null, count - 1);
                    }, function (err) {
                        if (callback) callback(err);
                    }, count - 1);
                }
            }, function (err) {
                if (callback) callback(err);
            });
        } else if (callback) callback('push not initialized');
    },
    getBadgeNumber: function getBadgeNumber(callback) {
        if (push._instance) {
            push._instance.getApplicationIconBadgeNumber(function (count) {
                if (callback) callback(null, count);
            }, function (err) {
                if (callback) callback(err);
            });
        } else if (callback) callback('push not initialized');
    },
    clearBadge: function clearBadge(callback) {
        if (push._instance) {
            var os = device.platform ? device.platform.toLowerCase() : '';
            var url = window.siteConfig.endPoints.pushV2 + '/api/app/' + window.appContext.currentApp.appId + '/subscriptions/badges/update';

            window.bfUtils.http.post(url, { deviceID: push.deviceId, os: os, value: 0 }).success(function (data) {
                console.log("push badge cleared", data);
            }).error(function (data, status) {
                var error = { data: data, status: status };
                console.error('error clearing badge', error);
            });

            // don't wait for success or fail on server sync
            push._instance.setApplicationIconBadgeNumber(function () {
                document.dispatchEvent(new CustomEvent('appBadgeNumberUpdated', { 'detail': 0 }));
                if (callback) callback(null, 0);
            }, function (err) {
                if (callback) callback(err);
            }, 0);
        } else if (callback) callback('push not initialized');
    },
    registerToken: function registerToken(deviceID) {
        console.log('registerToken: ' + deviceID);
        push.deviceId = deviceID;

        if (!window.appContext || !window.appContext.currentApp) {
            console.error('invalid appContext cant register device');
            return;
        }

        var pushSupportsFCM = typeof PushNotification !== "undefined" && typeof PushNotification.listChannels !== "undefined";
        var isFCM = device.platform && device.platform.toLowerCase() === "android" && pushSupportsFCM;

        var options = {
            params: {
                data: {
                    method: 'groups/subscriptions/add',
                    "params": {
                        groupID: '',
                        appID: window.appContext.currentApp.appId,
                        deviceID: push.deviceId,
                        os: device.platform ? device.platform.toLowerCase() : '',
                        deliveryMethod: isFCM ? 'FCM' : null,
                        device: device
                    }
                }
            }
        };

        var currentPushDeviceID = localStorage.getItem("currentPushDeviceID");
        if (currentPushDeviceID && currentPushDeviceID !== deviceID) {
            options.params.data.params.oldDeviceID = currentPushDeviceID;
        }

        var httpCallBack = function httpCallBack() {
            if (bfUtils.http) {
                bfUtils.http.jsonp(window.siteConfig.endPoints.push + '/src/server.js?callback=JSON_CALLBACK', options).success(function () {
                    console.log('device is now subscribed to PNs');
                    localStorage.setItem("currentPushDeviceID", deviceID);
                }).error(function (err) {
                    console.error(err);
                });
            }
        };

        setTimeout(function () {
            PushNotificationsAPI._subscribe(null, function (err) {
                if (err) {
                    console.error(err);
                    setTimeout(httpCallBack, 2000);
                }
            });
        }, 2000);
    },
    displayMessage: function displayMessage(payload, options) {
        var _forceToDisplayMessage = false;
        if (!options) {
            options = {};
        }
        _forceToDisplayMessage = options._forceToDisplayMessage;

        push.trackPushNotifications({ eventName: "push_notification/viewed", payload: payload });

        console.log('pushNotifications#displayMessage L152', payload);

        localStorage.payload = JSON.stringify(payload);

        try {
            var notificationId = "";
            if (payload._id) {
                notificationId = payload._id;
            } else if (window.plugins && window.plugins.pushNotification) {
                //old plugin installed
                if (payload && payload.notificationId) {
                    notificationId = payload.notificationId;
                }
            } else {
                //new plugin installed
                if (payload && payload.additionalData && payload.additionalData.notificationId) {
                    notificationId = payload.additionalData.notificationId;
                }
            }

            console.log('Checking message type', payload.messageType, payload);
            if (payload.additionalData && payload.additionalData.messageType === 'social') {
                payload.title = "Alert";
                payload.richContent = payload.message;
                richModal.display(payload);
                console.log('Got social notification', payload);
                return;
            }

            var url = window.siteConfig.endPoints.push + '/src/server.js?callback=JSON_CALLBACK';
            var appId = window.appContext.currentApp.appId.toString();
            var requestOptions = {
                params: {
                    data: {
                        method: "notifications/get",
                        params: {
                            appID: appId,
                            notificationID: notificationId
                        }
                    }
                }
            };

            push.getNotificationData(url, requestOptions, payload, function (err, payload) {
                if (err) return console.error(err);

                var modalOptions = Object.assign({}, payload);
                if (payload.actionItem) {
                    modalOptions.action = {
                        title: payload.actionItem && payload.actionItem.title ? payload.actionItem.title : 'View',
                        handler: function handler() {
                            var actionAPI = new ActionItemsAPI();
                            push.trackPushNotifications({ eventName: "push_notification/clicked", payload: payload });
                            actionAPI.execute(payload.actionItem, function (err, result) {
                                console.info("Action Taken!");
                            });
                        }
                    };
                }

                if (!_forceToDisplayMessage) {
                    if (!payload.richMessage) {
                        if (modalOptions.action && modalOptions.action.handler) {
                            modalOptions.action.handler();
                        }
                        return;
                    }
                }

                modalOptions.richContent = modalOptions.richMessage;
                modalOptions.subtitle = "Sent " + moment(modalOptions.sendAfter).fromNow();
                richModal.display(modalOptions);
            });
        } catch (err) {
            console.error('Failed to parse push notification', err);
        }
    },
    getNotificationData: function getNotificationData(url, requestOptions, payload, callback) {
        window.bfUtils.http.jsonp(url, requestOptions).success(function (data) {
            var dynamicPayload = data && data.result[0] ? data.result[0] : { actionItem: false };

            payload = Object.assign(payload, dynamicPayload);
            callback(null, payload);
        }).catch(callback);
    },
    notificationsTracked: {},
    ///eventName: "push_notification/viewed" or "push_notification/clicked"
    ///payload
    trackPushNotifications: function trackPushNotifications(data) {
        function sendToAnalytics(notificationId, os) {
            var analytics = new AnalyticsAPI(window.appContext.currentApp.appId, "push_notification", notificationId, undefined, os);
            analytics.trackAction(data.eventName);
        }

        if (typeof device != "undefined" && typeof AnalyticsAPI != "undefined" && data && data.payload && data.eventName) {
            var notificationId = null;
            if (window.plugins && window.plugins.pushNotification) {
                //old plugin installed
                if (data.payload.notificationId) {
                    notificationId = data.payload.notificationId;
                }
            } else {
                //new plugin installed
                if (window.PushNotification && data.payload.additionalData && data.payload.additionalData.notificationId) {
                    notificationId = data.payload.additionalData.notificationId;
                }
            }
            if (notificationId) {
                if (!push.notificationsTracked) push.notificationsTracked = {};
                var trackedNotification = push.notificationsTracked[notificationId];
                if (!trackedNotification) {
                    trackedNotification = push.notificationsTracked[notificationId] = { events: [] };
                }
                if (!trackedNotification.events) trackedNotification.events = [];
                if (trackedNotification.events.indexOf(data.eventName) > -1) {
                    return;
                }
                trackedNotification.events.push(data.eventName);

                var os = device.platform ? device.platform.toLowerCase() : '';
                sendToAnalytics(notificationId, os);
            }
        }
    }
};

//window.plugins.pushNotification is used for old builds, it's no longer used for new build
var _oldPush = {
    pushNotification: null,
    unseen: 0,
    // Should be overridden for each specific platform
    notificationHandler: null,
    init: function init() {
        console.warn("window.plugins.pushNotification is used for old builds, it's no longer used for new build");
        try {
            if (typeof window.plugins == "undefined" || typeof window.plugins.pushNotification == "undefined") {
                console.warn("window.plugins.pushNotification is not defined");
                return;
            }

            _oldPush.pushNotification = window.plugins.pushNotification;

            push.platform = device.platform.toLowerCase();

            push.prepareDOM();

            if (device.platform.toLowerCase() == 'android') _oldPush.notificationHandler = new pushAndroidNotificationHandler(_oldPush.pushNotification);else _oldPush.notificationHandler = new pushiOSNotificationHandler(_oldPush.pushNotification);

            _oldPush.notificationHandler.onRegistered = push.registerToken;
            _oldPush.notificationHandler.register();
        } catch (err) {
            console.error("There was an error on this page.\n\nError description: " + err.message + "\n\n");
        }
    }
};

// - Android --------------------------------------------------------------------
//
function pushAndroidNotificationHandler(pushNotification) {
    this.pushNotification = pushNotification;
    this.androidSenderID = "515869937012"; // projectID
}

pushAndroidNotificationHandler.prototype = {
    /**
     * Register the device on the Google Cloud Messaging service (GCM).
     */
    register: function register() {
        if (!navigator.onLine) {
            console.warn('offline: not attempting to register push notifications');
            return;
        }

        this.pushNotification.register(this.successHandler, this.errorHandler, {
            "senderID": this.androidSenderID,
            "ecb": "_oldPush.notificationHandler.onNotification"
        }); // required!
    },
    /**
     * Device registered
     */
    onRegistered: function onRegistered(deviceID) {
        push.deviceId = deviceID;
    },
    /**
     * Handle GCM, this method handles responses to registration and notifications
     */
    onNotification: function onNotification(e) {
        switch (e.event) {
            case 'registered':
                if (e.regid.length > 0) {
                    // Your GCM push server needs to know the regid before it can push to this device
                    // here is where you might want to send it the regid for later use.
                    this.onRegistered(e.regid);
                }
                break;

            case 'message':
                push.decrementBadge();
                // If this flag is set, this notification happened while we were in the foreground.
                // you might want to play a sound to get the user's attention, throw up a dialog, etc.
                if (e.foreground) {}
                //console.log('Forground Message');

                // otherwise we were launched because the user touched a notification in the notification tray.
                else {
                        if (e.coldstart) {
                            //console.log('Cold start notification');
                        } else {
                                //console.log('Background notification');
                            }
                    }

                // Show the message while in background
                var options = {};
                if (e.payload.messageType == 'social') options.buttons = ['Dismiss'];else options.buttons = ['Dismiss', 'Show Details'];
                push.displayMessage(e.payload, options);
                break;

            case 'error':
                console.error("An error occurred: " + e.msg);
                break;

            default:
                console.error("EVENT -> Unknown, an event was received and we do not know what it is");
                break;
        }
    },
    /**
     * Invoked on success.
     */
    successHandler: function successHandler(result) {
        //console.log('success:' + result);
    },
    /**
     * Invoked on failure.
     */
    errorHandler: function errorHandler(error) {
        console.error('error:' + error);
    }
};

// - iOS ------------------------------------------------------------------------
//
function pushiOSNotificationHandler(pushNotification) {
    this.pushNotification = pushNotification;
}

pushiOSNotificationHandler.prototype = {
    /**
     * Device registered
     */
    onRegistered: function onRegistered(deviceID) {
        push.deviceId = deviceID;
    },
    /**
     * Register the device on the Google Cloud Messaging service (GCM).
     */
    register: function register() {
        if (!navigator.onLine) {
            console.warn('offline: not attempting to register push notifications');
            return;
        }

        try {
            this.pushNotification.register(this.onRegistered, this.errorHandler, {
                "badge": "true", "sound": "true", "alert": "true",
                "ecb": "_oldPush.notificationHandler.onNotification"
            }); // required!
        } catch (err) {
            console.error("There was an error on this page.\n\nError description: " + err.message + "\n\n");
        }
    },
    /**
     * Handle APNS, this method handles responses to registration and notifications
     */
    onNotification: function onNotification(e) {
        if (e) {
            var options = {};
            if (e.messageType == 'social') options.buttons = ['Dismiss'];else options.buttons = ['Dismiss', 'Show Details'];
            if (e.alert) {
                push.decrementBadge();
                push.displayMessage(e, options);
            }
        } else {
            window.location.hash = '/pushHistory';
        }

        if (e.sound) {
            //var snd = new Media(e.sound);
            //snd.play();
        }
    },
    tokenHandler: function tokenHandler(result) {
        // Your iOS push server needs to know the token before it can push to this device
        // here is where you might want to send it the token for later use.
        //this.onRegistered(result);
        push.deviceId = result;
    },
    /**
     * Invoked on success.
     */
    successHandler: function successHandler(result) {
        this.onRegistered(result);
        //console.log('success:' + result);
    },
    /**
     * Invoked on failure.
     */
    errorHandler: function errorHandler(error) {
        console.error('ios error:' + error);
    }
};

if (bfUtils.isMobileDevice) {
    // Initialize on device ready
    appState.subscribe({ state: appState.RUNNING }, function () {
        //check if the plugins.pushNotification installed "old plugin"
        if (window.plugins.pushNotification) {
            console.log("running old plugin for push notification");
            _oldPush.init();
        } else {
            console.log("running new plugin phonegap-plugin-push");
            push.init();
        }
    });
}

/**
 * DEBUG
 */
window.testNotification = function () {
    var payload = {
        message: "Lorem ipsum dolor sit amet, consectetur adipisicing elit. Corrupti officiis perferendis expedita rerum delectus dolor neque veniam necessitatibus fuga cum voluptatibus placeat, totam voluptate, nisi reprehenderit odio porro cumque ipsa.<br /><br />Lorem ipsum dolor sit amet, consectetur adipisicing elit. Corrupti officiis perferendis expedita rerum delectus dolor neque veniam necessitatibus fuga cum voluptatibus placeat, totam voluptate, nisi reprehenderit odio porro cumque ipsa.<br /><br />Lorem ipsum dolor sit amet, consectetur adipisicing elit. Corrupti officiis perferendis expedita rerum delectus dolor neque veniam necessitatibus fuga cum voluptatibus placeat, totam voluptate, nisi reprehenderit odio porro cumque ipsa.<br /><br />Lorem ipsum dolor sit amet, consectetur adipisicing elit. Corrupti officiis perferendis expedita rerum delectus dolor neque veniam necessitatibus fuga cum voluptatibus placeat, totam voluptate, nisi reprehenderit odio porro cumque ipsa.<br /><br />",
        title: "Notification Title",
        alert: "This is the alert, not sure what it means",
        messageType: null,
        additionalData: {
            notificationId: "5b5f9bbe39003904daa4f093",
            coldstart: true,
            foreground: true
        }
    };

    var options = {
        buttons: ["Dismiss", "Show Details"]
    };

    push.displayMessage(payload, options);
};
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class BleCentralAPI
 * @summary enables communication between a phone
 * and Bluetooth Low Energy (BLE) peripherals.
 * @since v3.33.8 02/07/2020
 * @author Christopher Berger
 * @link documentation: {{ TBD }}
 */

var BleCentralAPI = function () {
	function BleCentralAPI() {
		_classCallCheck(this, BleCentralAPI);

		this.mockMode = typeof window.ble != 'undefined' ? false : true;

		if (this.mockMode) return console.warn('mock bleCentral interaction');

		this.ble = window.ble;
	}
	//////////////////////////////////// EVENT HANDLING ////////////////////////////////////
	/**
  * @method onDeviceDiscovered
  * 	triggers when a device is discovered
  * 	via any scan method. Sends the device
  * 	back to the SDK to be handled
  * @param {Object} device discovered device
  */


	_createClass(BleCentralAPI, [{
		key: 'onDeviceDiscovered',
		value: function onDeviceDiscovered(device) {
			var packet = new Packet(null, 'services.bluetooth.bleCentral.triggerOnDeviceDiscovered', device, null);
			postMaster.broadcast(packet);
		}
		/**
   * @method onDeviceConnected
   * 	triggers when a device is connected. Sends
   * 	the device back to the SDK to be handled
   * @param {Object} device connected device
   */

	}, {
		key: 'onDeviceConnected',
		value: function onDeviceConnected(device) {
			var packet = new Packet(null, 'services.bluetooth.bleCentral.triggerOnDeviceConnected', device, null);
			postMaster.broadcast(packet);
		}
		/**
   * @method onDeviceDisconnected
   * 	triggers when a device is disconnected.
   * 	Sends info back to the SDK to be handled
   * @param {*} info any info returned from ble
   */

	}, {
		key: 'onDeviceDisconnected',
		value: function onDeviceDisconnected(info) {
			var packet = new Packet(null, 'services.bluetooth.bleCentral.triggerOnDeviceDisconnected', info, null);
			postMaster.broadcast(packet);
		}
		/**
   * @method onNotification
   * 	Triggers when the value of a characteristic
   * 	changes. Sends data back to the SDK to be handled
   * @param {Object} data characteristic data
   */

	}, {
		key: 'onNotification',
		value: function onNotification(data) {
			var packet = new Packet(null, 'services.bluetooth.bleCentral.triggerOnNotification', data, null);
			postMaster.broadcast(packet);
		}
		/**
   * @method onStateNotification
   * 	Triggers when Bluetooth state changes. Sends
   * 	state back to the SDK to be handled.
   * @param {String} state new Bluetooth state
   */

	}, {
		key: 'onStateNotification',
		value: function onStateNotification(state) {
			var packet = new Packet(null, 'services.bluetooth.bleCentral.triggerOnStateNotification', state, null);
			postMaster.broadcast(packet);
		}
		/////////////////////////////////////// SCANNING ///////////////////////////////////////
		/**
   * 	@method scan
   * 		scans for BLE devices. The success callback is
   * 		called each time a peripheral is discovered.
   * 		Scanning automatically stops after the specified
   * 		number of seconds.
   * 	@param {Object} options 
   * 		@param {Array} services optional
   * 		List of services to discover, or [] to find all devices
   * 		@param {Number} seconds optional
   * 		Number of seconds to run discovery
   * 	@param {Function} callback optional
   * 		@returns {Object} 
   */

	}, {
		key: 'scan',
		value: function scan(options, callback) {
			if (this.mockMode) {
				return console.warn('bleCentral mock scan!');
			}
			if (!options) options = {};
			if (!options.services) options.services = [];
			if (!options.seconds) options.seconds = 5;

			var onFail = function onFail(error) {
				(callback || console.error)(error);
			};

			var onScanEnd = function onScanEnd() {
				if (callback) callback(null, { status: 'complete' });
			};

			var timeoutMillis = options.seconds * 1000;

			setTimeout(onScanEnd, timeoutMillis);

			this.ble && this.ble.scan(options.services, options.seconds, this.onDeviceDiscovered, onFail);
		}
		/**
   * 	@method startScan
   * 		scans for BLE devices. The success callback is
   * 		called each time a peripheral is discovered.
   * 		Scanning will continue until stopScan is called.
   * 	@param {Object} options 
   * 		@param {Array} services
   * 		List of services to discover, or [] to find all devices
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'startScan',
		value: function startScan(options, callback) {
			if (this.mockMode) {
				return console.warn('bleCentral mock startScan!');
			}
			if (!options) options = {};
			if (!options.services) options.services = [];

			var onFail = function onFail(error) {
				(callback || console.error)(error);
			};

			this.ble && this.ble.startScan(options.services, this.onDeviceDiscovered, onFail);
		}
		/**
   *  @method startScanWithOptions
   * 		scans for BLE devices. It operates similarly to
   * 		the startScan function, but allows you to specify
   * 		extra options. The success callback is called each
   * 		time a peripheral is discovered. Scanning will
   * 		continue until stopScan is called.
   * 	@param {Object} options 
   * 		@param {Array} services
   * 		List of services to discover, or [] to find all devices
   * 	  @param {Boolean} reportDuplicates
   * 		Specifies if duplicate devices should be reported
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'startScanWithOptions',
		value: function startScanWithOptions(options, callback) {
			if (this.mockMode) {
				return console.warn('bleCentral mock startScanWithOptions!');
			}
			if (!options) options = {};
			if (!options.services) options.services = [];
			if (!options.reportDuplicates) options.reportDuplicates = false;

			var onFail = function onFail(error) {
				(callback || console.error)(error);
			};

			/**
    * reportDuplicates is the onlyscanOption
    * availible as of plugin v1.2.4
    */
			var scanOptions = {
				reportDuplicates: options.reportDuplicates
			};

			this.ble && this.ble.startScanWithOptions(options.services, scanOptions, this.onDeviceDiscovered, onFail);
		}
		/**
   *  @method stopScan
   * 		stops scanning for BLE devices.
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'stopScan',
		value: function stopScan(callback) {
			if (this.mockMode) {
				return console.warn('bleCentral mock stopScan!');
			}

			this.ble && this.ble.stopScan(success, fail);

			function success() {
				if (callback) callback(null, true);
			}

			function fail(error) {
				if (callback) callback(error, null);
			}
		}
		///////////////////////////////////// CONNECTIONS //////////////////////////////////////
		/**
   *  @method connect
   * 		connects to a BLE peripheral. The callback is long
   * 		running. The connect callback will be called when
   * 		the connection is successful. Service and
   * 		characteristic info will be passed to the connect
   * 		callback in the peripheral object.
   *	@param {Object} options 
   * 		@param {String} device_id
   * 		UUID or MAC address of the peripheral
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'connect',
		value: function connect(options, callback) {
			var _this = this;

			if (!options || !options.device_id) {
				var error = new Error('No device_id provided to bleCentral.connect!');
				return (callback || console.error)(error);
			}
			if (this.mockMode) {
				return console.warn('bleCentral mock connect!');
			}

			var onConnect = function onConnect(result) {
				if (callback) callback(null, result);
				_this.onDeviceConnected(result);
			};

			var onDisconnect = function onDisconnect(data) {
				_this.onDeviceDisconnected(data);
			};

			this.ble && this.ble.connect(options.device_id, onConnect, onDisconnect);
		}
		/**
   *  @method autoConnect
   * 		Automatically connect to a device when it is in
   * 		range of the phone. When the device connects, the
   * 		connect callback is called with a peripheral object.
   * 		The call to autoConnect will not time out. It will
   * 		wait forever until the device is in range. When the
   * 		peripheral disconnects, the disconnect callback is
   * 		called with a peripheral object.
   *	@param {Object} options 
   * 		@param {String} device_id
   * 		UUID or MAC address of the peripheral
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'autoConnect',
		value: function autoConnect(options, callback) {
			var _this2 = this;

			if (!options || !options.device_id) {
				var error = new Error('No device_id provided to bleCentral.autoConnect!');
				return (callback || console.error)(error);
			}
			if (this.mockMode) {
				return console.warn('bleCentral mock connect!');
			}

			var onConnect = function onConnect(result) {
				_this2.onDeviceConnected(result);
			};

			var onDisconnect = function onDisconnect(data) {
				_this2.onDeviceDisonnected(data);
			};

			this.ble && this.ble.autoConnect(options.device_id, onConnect, onDisconnect);
		}
		/**
   *  @method disconnect
   * 		disconnects the selected device.
   *	@param {Object} options 
   * 		@param {String} device_id
   * 		UUID or MAC address of the peripheral
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'disconnect',
		value: function disconnect(options, callback) {
			var _this3 = this;

			if (!options || !options.device_id) {
				var error = new Error('No device_id provided to bleCentral.disconnect!');
				return (callback || console.error)(error);
			}
			if (this.mockMode) {
				return console.warn('bleCentral mock connect!');
			}

			var success = function success(result) {
				if (callback) callback(null, result);
				_this3.onDeviceDisconnected(result);
			};

			var fail = function fail(error) {
				if (callback) callback(error, null);
			};

			this.ble && this.ble.disconnect(options.device_id, success, fail);
		}
		/**
   *  @method connectedPeripheralsWithServices
   * 	Retreives a list of the peripherals
   * 	(containing any of the specified services) currently connected
   * 	to the system. The peripheral list is sent to the success callback.
   * 	connectedPeripheralsWithServices will not return any devices
   *  if services are not passed
   *	@param {Object} options 
   * 		@param {Array} services
   * 		List of services to discover
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'connectedPeripheralsWithServices',
		value: function connectedPeripheralsWithServices(options, callback) {
			if (!callback) {
				var error = new Error('No callback provided to bleCentral.connectedPeripheralsWithServices!');
				return console.error(error);
			}
			if (!options || !options.services || !options.services.length) {
				var _error = new Error('No services provided to bleCentral.connectedPeripheralsWithServices!');
				return callback(_error, null);
			}

			if (this.mockMode) {
				console.warn('bleCentral mock connectedPeripheralsWithServices!');
				return callback(null, []);
			}

			this.ble && this.ble.connectedPeripheralsWithServices(options.services, success, fail);

			function success(result) {
				callback(null, result);
			}

			function fail(error) {
				callback(error, null);
			}
		}
		/**
   *  @method peripheralsWithIdentifiers
   * 	Sends a list of known peripherals by their identifiers. 
   *	peripheralsWithIdentifiers will not return any devices
   *  if identifiers are not passed
   * 	to the success callback. 
   *	@param {Object} options 
   * 		@param {Array} identifiers
   * 		List of peripheral UUIDs
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'peripheralsWithIdentifiers',
		value: function peripheralsWithIdentifiers(options, callback) {
			if (!callback) {
				var error = new Error('No callback provided to bleCentral.peripheralsWithIdentifiers!');
				return console.error(error);
			}
			if (!options || !options.identifiers) {
				var _error2 = new Error('No identifiers provided to bleCentral.peripheralsWithIdentifiers!');
				return callback(_error2, null);
			}
			if (this.mockMode) {
				console.warn('bleCentral mock peripheralsWithIdentifiers!');
				return callback(null, []);
			}

			this.ble && this.ble.connectedPeripheralsWithServices(options.services, success, fail);

			function success(result) {
				if (callback) callback(null, result);
			}

			function fail(error) {
				if (callback) callback(error, null);
			}
		}
		////////////////////////////////////// READ/WRITE ///////////////////////////////////////
		/**
   *  @method read
   * 		Reads the value of the characteristic.
   *	@param {Object} options 
   * 		@param {String} device_id
   * 		UUID or MAC address of the peripheral
   * 		@param {String} service_uuid
   * 		UUID of the BLE service
   * 		@param {String} characteristic_uuid
   * 		UUID of the BLE characteristic
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'read',
		value: function read(options, callback) {
			var _this4 = this;

			if (typeof callback != 'function') {
				return console.error(new Error('No callback provided to bleCentral.read!'));
			}
			if (!options) {
				return callback(new Error('No options provided to bleCentral.read!'), null);
			}

			var device_id = options.device_id,
			    service_uuid = options.service_uuid,
			    characteristic_uuid = options.characteristic_uuid;


			if (!device_id || !service_uuid || !characteristic_uuid) {
				var error = new Error('Invalid device info provided to bleCentral.read: ' + JSON.stringify(options));
				return (callback || console.error)(error, null);
			}

			if (this.mockMode) {
				console.warn('bleCentral mock read!');
				return callback(null, null);
			}

			var success = function success(result) {
				try {
					var data = _this4.bufferToArray(result);
					callback(null, data);
				} catch (error) {
					callback(error, null);
				}
			};

			var fail = function fail(error) {
				callback(error, null);
			};

			this.ble && this.ble.read(device_id, service_uuid, characteristic_uuid, success, fail);
		}
		/**
   *  @method write
   * 		Writes data to a characteristic.
   *	@param {Object} options 
   * 		@param {String} device_id
   * 		UUID or MAC address of the peripheral
   * 		@param {String} service_uuid
   * 		UUID of the BLE service
   * 		@param {String} characteristic_uuid
   * 		UUID of the BLE characteristic
   * 		@param {ArrayBuffer} data
   * 		Bianary data to write to the characteristic
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'write',
		value: function write(options, callback) {
			if (!options) {
				var error = new Error('No options provided to bleCentral.write!');
				return (callback || console.error)(error, null);
			}

			var device_id = options.device_id,
			    service_uuid = options.service_uuid,
			    characteristic_uuid = options.characteristic_uuid,
			    data = options.data;


			if (!device_id || !service_uuid || !characteristic_uuid) {
				var _error3 = new Error('Invalid device info provided to bleCentral.write: ' + JSON.stringify(options));
				return (callback || console.error)(_error3, null);
			}

			if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || typeof data.length !== 'number') {
				var _error4 = new Error('Invalid data provided to bleCentral.write: Must be an array!', data);
				return (callback || console.error)(_error4, null);
			}

			if (this.mockMode) {
				console.warn('bleCentral mock write!');
				if (callback) callback(null, null);
				return;
			}

			var buffer = null;
			try {
				buffer = this.arrayToBuffer(data);
			} catch (error) {
				return (callback || console.error)(error, null);
			}

			this.ble && this.ble.write(options.device_id, options.service_uuid, options.characteristic_uuid, buffer, success, fail);

			function success(result) {
				if (callback) callback(null, result);
			}

			function fail(error) {
				if (callback) callback(error, null);
			}
		}
		/**
   *  @method writeWithoutResponse
   * 		Writes data to a characteristic without a response
   * 		from the peripheral. You are not notified if the
   * 		write fails in the BLE stack.
   *	@param {Object} options 
   * 		@param {String} device_id
   * 		UUID or MAC address of the peripheral
   * 		@param {String} service_uuid
   * 		UUID of the BLE service
   * 		@param {String} characteristic_uuid
   * 		UUID of the BLE characteristic
   * 		@param {ArrayBuffer} data
   * 		Bianary data to write to the characteristic
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'writeWithoutResponse',
		value: function writeWithoutResponse(options, callback) {
			if (!options) {
				var error = new Error('No options provided to bleCentral.writeWithoutResponse!');
				return (callback || console.error)(error, null);
			}

			var device_id = options.device_id,
			    service_uuid = options.service_uuid,
			    characteristic_uuid = options.characteristic_uuid,
			    data = options.data;


			if (!device_id || !service_uuid || !characteristic_uuid) {
				var _error5 = new Error('Invalid device info provided to bleCentral.writeWithoutResponse: ' + JSON.stringify(options));
				return (callback || console.error)(_error5, null);
			}

			if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || typeof data.length !== 'number') {
				var _error6 = new Error('Invalid data provided to bleCentral.writeWithoutResponse: Must be an array!', data);
				return (callback || console.error)(_error6, null);
			}

			if (this.mockMode) {
				console.warn('bleCentral mock writeWithoutResponse!');
				if (callback) callback(null, null);
				return;
			}

			var buffer = null;
			try {
				buffer = this.arrayToBuffer(data);
			} catch (error) {
				return (callback || console.error)(error, null);
			}

			this.ble && this.ble.writeWithoutResponse(device_id, service_uuid, characteristic_uuid, buffer, success, fail);

			function success() {
				if (callback) callback(null);
			}

			function fail(error) {
				if (callback) callback(error);
			}
		}
		/**
   *  @method readRSSI
   * 	Samples the RSSI value on the connection to a bluetooth
   * 	device. Requires that you have established a connection
   * 	before invoking (otherwise an error will be thrown).
   *	@param {Object} options 
   * 		@param {String} device_id
   * 		UUID or MAC address of the peripheral
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'readRSSI',
		value: function readRSSI(options, callback) {
			if (!options || !options.device_id) {
				var error = new Error('No device_id provided to bleCentral.readRSSI!');
				return (callback || console.error)(error, null);
			}
			if (this.mockMode) {
				console.warn('bleCentral mock readRSSI!');
				if (callback) callback(null, null);
				return;
			}

			this.ble && this.ble.readRSSI(options.device_id, success, fail);

			function success(result) {
				if (callback) callback(null, result);
			}

			function fail(error) {
				if (callback) callback(error, null);
			}
		}
		///////////////////////////////////// NOTIFICATIONS /////////////////////////////////////
		/**
   *  @method startNotification
   *		Registers a callback that is called every time
   *    the value of a characteristic changes. This method
   * 		handles both notifications and indications.
   *	@param {Object} options 
   * 		@param {String} device_id
   * 		UUID or MAC address of the peripheral
   * 		@param {String} service_uuid
   * 		UUID of the BLE service
   * 		@param {String} characteristic_uuid
   * 		UUID of the BLE characteristic
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'startNotification',
		value: function startNotification(options, callback) {
			var _this5 = this;

			if (!options) {
				var error = new Error('No options provided to bleCentral.startNotification!');
				return (callback || console.error)(error);
			}

			var device_id = options.device_id,
			    service_uuid = options.service_uuid,
			    characteristic_uuid = options.characteristic_uuid;


			if (!device_id || !service_uuid || !characteristic_uuid) {
				var _error7 = new Error('Invalid device info provided to bleCentral.startNotification: ' + JSON.stringify(options));
				return (callback || console.error)(_error7);
			}

			if (this.mockMode) {
				console.warn('bleCentral mock startNotification!');
				if (callback) callback(null);
				return;
			}

			var success = function success(result) {
				try {
					var data = _this5.bufferToArray(result);
					var obj = { device_id: device_id, service_uuid: service_uuid, characteristic_uuid: characteristic_uuid, data: data };
					_this5.onNotification(obj);
				} catch (error) {
					console.error(error);
				}
			};

			function fail(error) {
				if (callback) callback(error);
			}

			this.ble && this.ble.startNotification(device_id, service_uuid, characteristic_uuid, success, fail);
		}
		/**
   *  @method stopNotification
   * 	Stops a previously registered notification callback.
   *	@param {Object} options 
   * 		@param {String} device_id
   * 		UUID or MAC address of the peripheral
   * 		@param {String} service_uuid
   * 		UUID of the BLE service
   * 		@param {String} characteristic_uuid
   * 		UUID of the BLE characteristic
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'stopNotification',
		value: function stopNotification(options, callback) {
			if (!options) {
				var error = new Error('No options provided to bleCentral.stopNotification!');
				return (callback || console.error)(error);
			}

			var device_id = options.device_id,
			    service_uuid = options.service_uuid,
			    characteristic_uuid = options.characteristic_uuid;


			if (!device_id || !service_uuid || !characteristic_uuid) {
				var _error8 = new Error('Invalid device info provided to bleCentral.stopNotification: ' + JSON.stringify(options));
				return (callback || console.error)(_error8);
			}

			if (this.mockMode) {
				console.warn('bleCentral mock stopNotification!');
				if (callback) callback(null);
				return;
			}

			this.ble && this.ble.stopNotification(device_id, service_uuid, characteristic_uuid, success, fail);

			function success(result) {
				if (callback) callback(null, result);
			}

			function fail(error) {
				if (callback) callback(error, null);
			}
		}
		/**
   *  @method startStateNotifications
   * 	Calls the success callback when the Bluetooth is
   * 	enabled or disabled on the device.
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'startStateNotifications',
		value: function startStateNotifications(callback) {
			if (this.mockMode) {
				console.warn('bleCentral mock startStateNotifications!');
				if (callback) callback(null, null);
				return;
			}

			this.ble && this.ble.startStateNotifications(success, fail);

			function success(result) {
				if (callback) callback(null, result);
			}

			function fail(error) {
				if (callback) callback(error, null);
			}
		}
		/**
   *  @method stopStateNotifications
   * 	Calls the success callback when Bluetooth state
   * 	notifications have been stopped.
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'stopStateNotifications',
		value: function stopStateNotifications(callback) {
			if (this.mockMode) {
				console.warn('bleCentral mock stopStateNotifications!');
				if (callback) callback(null, null);
				return;
			}

			this.ble && this.ble.stopStateNotifications(success, fail);

			function success(result) {
				if (callback) callback(null, result);
			}

			function fail(error) {
				if (callback) callback(error, null);
			}
		}
		///////////////////////////////////////// UTILS /////////////////////////////////////////
		/**
   *  @method isConnected
   * 		Calls the success callback when the peripheral is
   * 		connected and the failure callback when not connected.
   *	@param {Object} options 
   * 		@param {String} device_id
   * 		UUID or MAC address of the peripheral
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'isConnected',
		value: function isConnected(options, callback) {
			if (!callback) {
				return console.error(new Error('No callback provided to bleCentral.isConnected!'));
			}
			if (!options || !options.device_id) {
				var error = new Error('No device_id provided to bleCentral.isConnected!');
				return callback(error, null);
			}
			if (this.mockMode) {
				console.warn('bleCentral mock isConnected!');
				return callback(null, null);
			}

			this.ble && this.ble.isConnected(options.device_id, success, fail);

			function success(result) {
				callback(null, result);
			}

			function fail(error) {
				callback(error, null);
			}
		}
		/**
   *  @method isEnabled
   * 	Calls the success callback when Bluetooth is
   * 	enabled and the failure callback when Bluetooth
   * 	is not enabled.
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'isEnabled',
		value: function isEnabled(callback) {
			if (!callback) {
				return console.error(new Error('No callback provided to bleCentral.isEnabled!'));
			}
			if (this.mockMode) {
				console.warn('bleCentral mock isEnabled!');
				return callback(null, null);
			}

			this.ble && this.ble.isEnabled(success, fail);

			function success(result) {
				callback(null, result);
			}

			function fail(error) {
				callback(error, null);
			}
		}
		/**
   *  @method isLocationEnabled
   * 	Calls the success callback when location services
   * 	are enabled and the failure callback when location
   * 	services are not enabled. On some devices, location
   * 	services must be enabled in order to scan for peripherals.
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'isLocationEnabled',
		value: function isLocationEnabled(callback) {
			if (this.mockMode) {
				console.warn('bleCentral mock isLocationEnabled!');
				if (callback) callback(null, null);
				return;
			}

			this.ble && this.ble.isLocationEnabled(success, fail);

			function success(result) {
				if (callback) callback(null, result);
			}

			function fail(error) {
				if (callback) callback(error, null);
			}
		}
		/**
   *  @method showBluetoothSettings
   * 	Opens the Bluetooth settings for the operating systems.
   * 	showBluetoothSettings is not available on iOS. 
   */

	}, {
		key: 'showBluetoothSettings',
		value: function showBluetoothSettings(callback) {
			if (bfUtils.isIOS) {
				return (callback || console.warn)('bleCentral.showBluetoothSettings is not available on iOS!');
			}
			if (this.mockMode) {
				console.warn('bleCentral mock showBluetoothSettings!');
				if (callback) callback(null);
				return;
			}

			this.ble && this.ble.showBluetoothSettings(success, fail);

			function success() {
				if (callback) callback(null);
			}

			function fail(error) {
				if (callback) callback(error);
			}
		}
		/**
   *  @method enable
   * 	Prompts the user to enable Bluetooth. enable is only
   * 	supported on Android and does not work on iOS.
   *  @param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'enable',
		value: function enable(callback) {
			if (bfUtils.isIOS) {
				return (callback || console.warn)('bleCentral.enable is not available on iOS!');
			}
			if (this.mockMode) {
				console.warn('bleCentral mock enable!');
				if (callback) callback(null, null);
				return;
			}

			this.ble && this.ble.enable(success, fail);

			function success(result) {
				if (callback) callback(null, result);
			}

			function fail(error) {
				if (callback) callback(error, null);
			}
		}
		/**
   *  @method bondedDevices
   * 	Sends a list of bonded low energy peripherals to
   * 	the success callback.
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'bondedDevices',
		value: function bondedDevices(callback) {
			if (!callback) {
				return console.error(new Error('No callback provided to bleCentral.bondedDevices!'));
			}
			if (this.mockMode) {
				console.warn('bleCentral mock enable!');
				return callback(null, null);
			}

			this.ble && this.ble.bondedDevices(success, fail);

			function success(result) {
				callback(null, result);
			}

			function fail(error) {
				callback(error, null);
			}
		}
		/**
   *  @method requestMtu
   * 		When performing a write request operation (write without response), the
   * 		data sent is truncated to the MTU size. This function may be used to request
   * 		(on Android) a larger MTU size to be able to send more data at once.
   *	@param {Object} options 
   * 		@param {String} device_id
   * 		UUID or MAC address of the peripheral
   * 		@param {Number} mtu
   * 		MTU size
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'requestMtu',
		value: function requestMtu(options, callback) {
			if (!options || !options.device_id) {
				var error = new Error('No device_id provided to bleCentral.requestMtu!');
				return (callback || console.error)(error, null);
			}
			if (this.mockMode) {
				console.warn('bleCentral mock requestMtu!');
				if (callback) callback(null, null);
				return;
			}

			options.mtu = options.mtu || 100;

			this.ble && this.ble.requestMtu(options.device_id, options.mtu, success, fail);

			function success(result) {
				if (callback) callback(null, result);
			}

			function fail(error) {
				if (callback) callback(error, null);
			}
		}
		/**
   *  @method refreshDeviceCache
   * 		Some devices show old cached services and
   * 		characteristics info. 
   *	@param {Object} options 
   * 		@param {String} device_id
   * 		UUID or MAC address of the peripheral
   * 		@param {Number} timeoutMillis
   * 		Timeout in milliseconds after refresh before discovering services
   * 	@param {Function} callback 
   * 		@returns {Object} 
   */

	}, {
		key: 'refreshDeviceCache',
		value: function refreshDeviceCache(options, callback) {
			if (!options || !options.device_id) {
				var error = new Error('No device_id provided to bleCentral.refreshDeviceCache!');
				return (callback || console.error)(error, null);
			}
			if (this.mockMode) {
				console.warn('bleCentral mock refreshDeviceCache!');
				if (callback) callback(null, null);
				return;
			}

			this.ble && this.ble.refreshDeviceCache(options.device_id, options.timeoutMillis, success, fail);

			function success(result) {
				if (callback) callback(null, result);
			}

			function fail(error) {
				if (callback) callback(error, null);
			}
		}
		/////////////////////////////////////// CONVERSION //////////////////////////////////////

	}, {
		key: 'bufferToArray',
		value: function bufferToArray(buffer) {
			var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Uint8';

			if (!this.arrayTypes[type]) {
				console.error('Invalid array type! Defaulting to Uint8Array.');
				type = 'Uint8';
			}
			return Array.from(new this.arrayTypes[type](buffer));
		}
	}, {
		key: 'arrayToBuffer',
		value: function arrayToBuffer(arr) {
			var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Uint8';

			if (!this.arrayTypes[type]) {
				console.error('Invalid array type! Defaulting to Uint8Array.');
				type = 'Uint8';
			}
			return new this.arrayTypes[type](arr).buffer;
		}
	}, {
		key: 'arrayTypes',
		get: function get() {
			return {
				'Int8': Int8Array,
				'Uint8': Uint8Array,
				'Int16': Int16Array,
				'Uint16': Uint16Array,
				'Int32': Int32Array,
				'Uint32': Uint32Array
			};
		}
	}]);

	return BleCentralAPI;
}();
'use strict';

function ComponentUIAPI(context) {
	this.context = context;
	this.DRAWER_UI_ID = 'bottomDrawerContainer';
	this.SNACKBAR_UI_ID = 'snackbarhero';
	this.init();
}

ComponentUIAPI.prototype = {
	init: function init() {},
	closeDrawer: function closeDrawer(options, callback) {
		if (!options) {
			options = {};
		}
		var _ui = document.getElementById(this.DRAWER_UI_ID);
		if (_ui) {
			if (options.force) _ui.remove();else {
				_ui.classList.add('closing');
				setTimeout(function () {
					_ui.remove();
				}, 300);
			}
		}
	},
	openBottomDrawer: function openBottomDrawer(options, callback) {
		var _this = this;

		if (!options) {
			options = {};
		}
		var drawerUI = document.createElement('div');
		drawerUI.id = this.DRAWER_UI_ID;
		drawerUI.className = 'bottom-drawer-container';
		drawerUI.innerHTML = '<div class="bottom-drawer-backdrop"></div>\n' + '<div class="bottom-drawer-holder"><div class="bottom-drawer backgroundColorTheme"></div></div>\n';

		var bodyDrawer = drawerUI.querySelector('.backgroundColorTheme');
		drawerUI.querySelector('.bottom-drawer-backdrop').onclick = function () {
			_this.closeDrawer();
		};

		if (options.header) {
			var headerUI = document.createElement('div');
			headerUI.className = 'bottom-drawer-header primaryBackgroundTheme';
			headerUI.innerHTML = options.header;

			bodyDrawer.appendChild(headerUI);
		}

		function buildList(items) {
			var listUI = document.createElement('ul');
			listUI.classList.add('action-list');

			function itemClick(itemUI, currentItem) {
				itemUI.onclick = function () {
					callback(null, currentItem);
				};
			}

			for (var i = 0; i < items.length; i++) {
				if (items[i].text) {
					var itemUI = document.createElement('li');
					//no icons for now, we need to import the MD icons
					itemUI.innerHTML = '<div class="item-icon"><span class="icon hide"></span></div>\n' + '<span>' + items[i].text + '</span>';
					itemClick(itemUI, items[i]);
					listUI.appendChild(itemUI);
				}
			}
			return listUI;
		}

		if (options.content) {
			var contentUI = document.createElement('div');
			contentUI.className = 'drawer-content';
			contentUI.innerHTML = options.content;

			bodyDrawer.appendChild(contentUI);
		}
		if (options.listItems) {
			bodyDrawer.appendChild(buildList(options.listItems));
		} else {
			if (options.tabs && options.tabs) {
				var tabsUI = document.createElement('div');
				tabsUI.className = 'md-tabs-scroll';
				var tabsInnerHTML = '';
				for (var i = 0; i < options.tabs.length; i++) {
					tabsInnerHTML += '<button class="btn-tab-drawer-' + i + (i == 0 ? ' md-tab active' : ' md-tab') + '">\n' + options.tabs[i].text + '<div class="active-indicator primaryBackgroundTheme"></div></button>';
				}
				tabsInnerHTML = '<div class="md-tabs">' + tabsInnerHTML + '</div>';
				tabsUI.innerHTML = tabsInnerHTML;

				var count = 0;
				var tabContainers = [];
				var _buttons = tabsUI.querySelectorAll('button');
				_buttons.forEach(function (b) {
					b.setAttribute('data-tabindex', count);
					b.onclick = function () {
						_buttons.forEach(function (_b) {
							_b.classList.remove('active');
						});
						b.classList.add('active');
						var index = b.getAttribute('data-tabindex');
						tabContainers.forEach(function (_container) {
							_container.classList.add('hide');
						});
						tabContainers[index].classList.remove('hide');
					};
					count++;
				});
				bodyDrawer.appendChild(tabsUI);

				for (var _i = 0; _i < options.tabs.length; _i++) {
					if (options.tabs[_i].listItems) {
						tabContainers.push(buildList(options.tabs[_i].listItems));
					} else {
						var _contentUI = document.createElement('div');
						_contentUI.className = 'drawer-content';
						_contentUI.innerHTML = options.tabs[_i].content;

						tabContainers.push(_contentUI);
					}
					if (_i > 0) {
						tabContainers[_i].classList.add('hide');
					}
					bodyDrawer.appendChild(tabContainers[tabContainers.length - 1]);
				}
			}
		}

		//remove the old Drawer
		this.closeDrawer({ force: true });
		//attach drawerUI to body
		(document.getElementById('appBody') || document.getElementById('app')).appendChild(drawerUI);
	},
	showToastMessage: function showToastMessage(options, callback) {
		var _this2 = this;

		if (!options) {
			options = {};
		}

		var snackbarUI = document.getElementById(this.SNACKBAR_UI_ID);
		var message = snackbarUI.querySelector('.snackbar-message');
		message.innerText = options.text;

		var snackbarActions = snackbarUI.querySelector('.snackbar-actions');
		var snackbarAction = snackbarActions.querySelector('.snackbar-action');
		if (options.action && options.action.title) {
			snackbarAction.querySelector('span').innerText = options.action.title;
			snackbarAction.classList.remove('hide');
			snackbarAction.onclick = function () {
				if (callback) callback(null, options.action);
			};
		} else {
			snackbarAction.classList.add('hide');
		}

		if (options.hideDismiss) {
			snackbarActions.querySelector('.dismiss').classList.add('hide');
		} else {
			snackbarActions.querySelector('.dismiss').classList.remove('hide');
			snackbarActions.querySelector('.dismiss').onclick = function () {
				_this2.closeToastMessage({ force: true });
			};
		}

		snackbarUI.classList.remove('hide');
		snackbarUI.querySelector('.snackbar').classList.add('open');
		this.closeToastMessage();
	},
	closeToastMessage: function closeToastMessage(options, callback) {
		if (!options) {
			options = {};
		}
		var snackbarUI = document.getElementById(this.SNACKBAR_UI_ID);
		if (options.force) {
			snackbarUI.querySelector('.snackbar').classList.remove('closing');
			snackbarUI.querySelector('.snackbar').classList.remove('open');
			setTimeout(function () {
				snackbarUI.classList.add('hide');
			}, 250);
		} else {
			snackbarUI.querySelector('.snackbar').classList.add('closing');
			setTimeout(function () {
				snackbarUI.querySelector('.snackbar').classList.remove('closing');
				snackbarUI.querySelector('.snackbar').classList.remove('open');
				setTimeout(function () {
					snackbarUI.classList.add('hide');
				}, 250);
			}, 8 * 1000);
		}
	}
};