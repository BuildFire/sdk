/**
 * Created by Daniel on 9/29/2015.
 * single event handlers that enforce
 * limited lifespan event handlers that are not singletons
 */

var postMaster = {
    controlPluginAPI:null
    ,widgetPluginAPI:null
    ,launcherPluginAPI:null
    ,servicePluginAPIs:{}
    ,postMessageHandler: function(e) {

        if(!e.data)
            return;
        else if( typeof(e.data) == "object")
            e.packet = e.data;
        else{
            /// parse data to once and not per pluginAPI
            try {
                e.packet = JSON.parse(e.data)
            }
            catch (err) {
                console.log("!! Post Master:: Ignore Invalid packet", err, e.data);
                return;
            }
        }

        postMaster._acceptRequest(e)
    }
    , _acceptRequest: function(e){


        if(!e || !e.packet || !e.packet.cmd ) return;


        function tryPMH(pluginAPI,e){
            if(!pluginAPI
                || !pluginAPI.postMessageHandler
                || !e)
                return false;

            try{
                return pluginAPI.postMessageHandler(e);
            }
            catch(err){
                console.error('postMessageHandler error:', err);
                return false;
            }

        }

        var foundHome = false;

        foundHome =tryPMH(postMaster.widgetPluginAPI,e);
        if(foundHome) return;

        if(postMaster.widgetPluginAPI != postMaster.launcherPluginAPI)
            foundHome =tryPMH(postMaster.launcherPluginAPI,e);
        if(foundHome) return;

        foundHome = tryPMH(postMaster.controlPluginAPI,e);
        if(foundHome) return;

        for(var p in postMaster.servicePluginAPIs) {
            foundHome = tryPMH(postMaster.servicePluginAPIs[p], e);
            if(foundHome) return;
        }

        if(!foundHome)
            console.warn('no home for this packet (sad face) ');


    }
    ,broadcast: function(packet,optionalInstanceFilter){

        function trySendMessage(pluginAPI){
            if(!pluginAPI)return;
            if(!optionalInstanceFilter || pluginAPI.context.instanceId == optionalInstanceFilter)
                pluginAPI.sendMessage(null,packet);
        }

        trySendMessage(postMaster.controlPluginAPI);

        if(postMaster.widgetPluginAPI
            && postMaster.widgetPluginAPI != postMaster.launcherPluginAPI) // if widget is same as launcher dont bother running twice
            trySendMessage(postMaster.widgetPluginAPI);

        if(postMaster.launcherPluginAPI && postMaster.widgetPluginAPI == postMaster.launcherPluginAPI) // if widget == launcher then make launcher handle it
            packet.fid = postMaster.launcherPluginAPI.iFrameId;

        if(postMaster.launcherPluginAPI)
            trySendMessage(postMaster.launcherPluginAPI);

        //broadcast to each service
        for(var p in postMaster.servicePluginAPIs)
            trySendMessage(postMaster.servicePluginAPIs[p]);
    }

    ,attachService: function(instanceId,pluginAPI){
        this.servicePluginAPIs[instanceId] = pluginAPI;
    }
    ,dettachService: function(instanceId){
        delete this.servicePluginAPIs[instanceId];
    }

    ,isLauncherPluginActive: function() {
        return postMaster.widgetPluginAPI == null || postMaster.widgetPluginAPI == postMaster.launcherPluginAPI;
    }

};

window.addEventListener('message', postMaster.postMessageHandler, false);
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
!function(a,b,c,d){"use strict";function e(a,b,c){return setTimeout(k(a,c),b)}function f(a,b,c){return Array.isArray(a)?(g(a,c[b],c),!0):!1}function g(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function h(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a}function i(a,b){return h(a,b,!0)}function j(a,b,c){var d,e=b.prototype;d=a.prototype=Object.create(e),d.constructor=a,d._super=e,c&&h(d,c)}function k(a,b){return function(){return a.apply(b,arguments)}}function l(a,b){return typeof a==kb?a.apply(b?b[0]||d:d,b):a}function m(a,b){return a===d?b:a}function n(a,b,c){g(r(b),function(b){a.addEventListener(b,c,!1)})}function o(a,b,c){g(r(b),function(b){a.removeEventListener(b,c,!1)})}function p(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function q(a,b){return a.indexOf(b)>-1}function r(a){return a.trim().split(/\s+/g)}function s(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function t(a){return Array.prototype.slice.call(a,0)}function u(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];s(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function v(a,b){for(var c,e,f=b[0].toUpperCase()+b.slice(1),g=0;g<ib.length;){if(c=ib[g],e=c?c+f:b,e in a)return e;g++}return d}function w(){return ob++}function x(a){var b=a.ownerDocument;return b.defaultView||b.parentWindow}function y(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){l(a.options.enable,[a])&&c.handler(b)},this.init()}function z(a){var b,c=a.options.inputClass;return new(b=c?c:rb?N:sb?Q:qb?S:M)(a,A)}function A(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&yb&&d-e===0,g=b&(Ab|Bb)&&d-e===0;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,B(a,c),a.emit("hammer.input",c),a.recognize(c),a.session.prevInput=c}function B(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=E(b)),e>1&&!c.firstMultiple?c.firstMultiple=E(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=F(d);b.timeStamp=nb(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=J(h,i),b.distance=I(h,i),C(c,b),b.offsetDirection=H(b.deltaX,b.deltaY),b.scale=g?L(g.pointers,d):1,b.rotation=g?K(g.pointers,d):0,D(c,b);var j=a.element;p(b.srcEvent.target,j)&&(j=b.srcEvent.target),b.target=j}function C(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};(b.eventType===yb||f.eventType===Ab)&&(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function D(a,b){var c,e,f,g,h=a.lastInterval||b,i=b.timeStamp-h.timeStamp;if(b.eventType!=Bb&&(i>xb||h.velocity===d)){var j=h.deltaX-b.deltaX,k=h.deltaY-b.deltaY,l=G(i,j,k);e=l.x,f=l.y,c=mb(l.x)>mb(l.y)?l.x:l.y,g=H(j,k),a.lastInterval=b}else c=h.velocity,e=h.velocityX,f=h.velocityY,g=h.direction;b.velocity=c,b.velocityX=e,b.velocityY=f,b.direction=g}function E(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:lb(a.pointers[c].clientX),clientY:lb(a.pointers[c].clientY)},c++;return{timeStamp:nb(),pointers:b,center:F(b),deltaX:a.deltaX,deltaY:a.deltaY}}function F(a){var b=a.length;if(1===b)return{x:lb(a[0].clientX),y:lb(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:lb(c/b),y:lb(d/b)}}function G(a,b,c){return{x:b/a||0,y:c/a||0}}function H(a,b){return a===b?Cb:mb(a)>=mb(b)?a>0?Db:Eb:b>0?Fb:Gb}function I(a,b,c){c||(c=Kb);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function J(a,b,c){c||(c=Kb);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function K(a,b){return J(b[1],b[0],Lb)-J(a[1],a[0],Lb)}function L(a,b){return I(b[0],b[1],Lb)/I(a[0],a[1],Lb)}function M(){this.evEl=Nb,this.evWin=Ob,this.allow=!0,this.pressed=!1,y.apply(this,arguments)}function N(){this.evEl=Rb,this.evWin=Sb,y.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function O(){this.evTarget=Ub,this.evWin=Vb,this.started=!1,y.apply(this,arguments)}function P(a,b){var c=t(a.touches),d=t(a.changedTouches);return b&(Ab|Bb)&&(c=u(c.concat(d),"identifier",!0)),[c,d]}function Q(){this.evTarget=Xb,this.targetIds={},y.apply(this,arguments)}function R(a,b){var c=t(a.touches),d=this.targetIds;if(b&(yb|zb)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=t(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return p(a.target,i)}),b===yb)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Ab|Bb)&&delete d[g[e].identifier],e++;return h.length?[u(f.concat(h),"identifier",!0),h]:void 0}function S(){y.apply(this,arguments);var a=k(this.handler,this);this.touch=new Q(this.manager,a),this.mouse=new M(this.manager,a)}function T(a,b){this.manager=a,this.set(b)}function U(a){if(q(a,bc))return bc;var b=q(a,cc),c=q(a,dc);return b&&c?cc+" "+dc:b||c?b?cc:dc:q(a,ac)?ac:_b}function V(a){this.id=w(),this.manager=null,this.options=i(a||{},this.defaults),this.options.enable=m(this.options.enable,!0),this.state=ec,this.simultaneous={},this.requireFail=[]}function W(a){return a&jc?"cancel":a&hc?"end":a&gc?"move":a&fc?"start":""}function X(a){return a==Gb?"down":a==Fb?"up":a==Db?"left":a==Eb?"right":""}function Y(a,b){var c=b.manager;return c?c.get(a):a}function Z(){V.apply(this,arguments)}function $(){Z.apply(this,arguments),this.pX=null,this.pY=null}function _(){Z.apply(this,arguments)}function ab(){V.apply(this,arguments),this._timer=null,this._input=null}function bb(){Z.apply(this,arguments)}function cb(){Z.apply(this,arguments)}function db(){V.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function eb(a,b){return b=b||{},b.recognizers=m(b.recognizers,eb.defaults.preset),new fb(a,b)}function fb(a,b){b=b||{},this.options=i(b,eb.defaults),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.element=a,this.input=z(this),this.touchAction=new T(this,this.options.touchAction),gb(this,!0),g(b.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function gb(a,b){var c=a.element;g(a.options.cssProps,function(a,d){c.style[v(c.style,d)]=b?a:""})}function hb(a,c){var d=b.createEvent("Event");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var ib=["","webkit","moz","MS","ms","o"],jb=b.createElement("div"),kb="function",lb=Math.round,mb=Math.abs,nb=Date.now,ob=1,pb=/mobile|tablet|ip(ad|hone|od)|android/i,qb="ontouchstart"in a,rb=v(a,"PointerEvent")!==d,sb=qb&&pb.test(navigator.userAgent),tb="touch",ub="pen",vb="mouse",wb="kinect",xb=25,yb=1,zb=2,Ab=4,Bb=8,Cb=1,Db=2,Eb=4,Fb=8,Gb=16,Hb=Db|Eb,Ib=Fb|Gb,Jb=Hb|Ib,Kb=["x","y"],Lb=["clientX","clientY"];y.prototype={handler:function(){},init:function(){this.evEl&&n(this.element,this.evEl,this.domHandler),this.evTarget&&n(this.target,this.evTarget,this.domHandler),this.evWin&&n(x(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&o(this.element,this.evEl,this.domHandler),this.evTarget&&o(this.target,this.evTarget,this.domHandler),this.evWin&&o(x(this.element),this.evWin,this.domHandler)}};var Mb={mousedown:yb,mousemove:zb,mouseup:Ab},Nb="mousedown",Ob="mousemove mouseup";j(M,y,{handler:function(a){var b=Mb[a.type];b&yb&&0===a.button&&(this.pressed=!0),b&zb&&1!==a.which&&(b=Ab),this.pressed&&this.allow&&(b&Ab&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:vb,srcEvent:a}))}});var Pb={pointerdown:yb,pointermove:zb,pointerup:Ab,pointercancel:Bb,pointerout:Bb},Qb={2:tb,3:ub,4:vb,5:wb},Rb="pointerdown",Sb="pointermove pointerup pointercancel";a.MSPointerEvent&&(Rb="MSPointerDown",Sb="MSPointerMove MSPointerUp MSPointerCancel"),j(N,y,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace("ms",""),e=Pb[d],f=Qb[a.pointerType]||a.pointerType,g=f==tb,h=s(b,a.pointerId,"pointerId");e&yb&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Ab|Bb)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var Tb={touchstart:yb,touchmove:zb,touchend:Ab,touchcancel:Bb},Ub="touchstart",Vb="touchstart touchmove touchend touchcancel";j(O,y,{handler:function(a){var b=Tb[a.type];if(b===yb&&(this.started=!0),this.started){var c=P.call(this,a,b);b&(Ab|Bb)&&c[0].length-c[1].length===0&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:tb,srcEvent:a})}}});var Wb={touchstart:yb,touchmove:zb,touchend:Ab,touchcancel:Bb},Xb="touchstart touchmove touchend touchcancel";j(Q,y,{handler:function(a){var b=Wb[a.type],c=R.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:tb,srcEvent:a})}}),j(S,y,{handler:function(a,b,c){var d=c.pointerType==tb,e=c.pointerType==vb;if(d)this.mouse.allow=!1;else if(e&&!this.mouse.allow)return;b&(Ab|Bb)&&(this.mouse.allow=!0),this.callback(a,b,c)},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var Yb=v(jb.style,"touchAction"),Zb=Yb!==d,$b="compute",_b="auto",ac="manipulation",bc="none",cc="pan-x",dc="pan-y";T.prototype={set:function(a){a==$b&&(a=this.compute()),Zb&&(this.manager.element.style[Yb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return g(this.manager.recognizers,function(b){l(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),U(a.join(" "))},preventDefaults:function(a){if(!Zb){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return void b.preventDefault();var d=this.actions,e=q(d,bc),f=q(d,dc),g=q(d,cc);return e||f&&c&Hb||g&&c&Ib?this.preventSrc(b):void 0}},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var ec=1,fc=2,gc=4,hc=8,ic=hc,jc=16,kc=32;V.prototype={defaults:{},set:function(a){return h(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(f(a,"recognizeWith",this))return this;var b=this.simultaneous;return a=Y(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return f(a,"dropRecognizeWith",this)?this:(a=Y(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(f(a,"requireFailure",this))return this;var b=this.requireFail;return a=Y(a,this),-1===s(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(f(a,"dropRequireFailure",this))return this;a=Y(a,this);var b=s(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function b(b){c.manager.emit(c.options.event+(b?W(d):""),a)}var c=this,d=this.state;hc>d&&b(!0),b(),d>=hc&&b(!0)},tryEmit:function(a){return this.canEmit()?this.emit(a):void(this.state=kc)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(kc|ec)))return!1;a++}return!0},recognize:function(a){var b=h({},a);return l(this.options.enable,[this,b])?(this.state&(ic|jc|kc)&&(this.state=ec),this.state=this.process(b),void(this.state&(fc|gc|hc|jc)&&this.tryEmit(b))):(this.reset(),void(this.state=kc))},process:function(){},getTouchAction:function(){},reset:function(){}},j(Z,V,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(fc|gc),e=this.attrTest(a);return d&&(c&Bb||!e)?b|jc:d||e?c&Ab?b|hc:b&fc?b|gc:fc:kc}}),j($,Z,{defaults:{event:"pan",threshold:10,pointers:1,direction:Jb},getTouchAction:function(){var a=this.options.direction,b=[];return a&Hb&&b.push(dc),a&Ib&&b.push(cc),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&Hb?(e=0===f?Cb:0>f?Db:Eb,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?Cb:0>g?Fb:Gb,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return Z.prototype.attrTest.call(this,a)&&(this.state&fc||!(this.state&fc)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=X(a.direction);b&&this.manager.emit(this.options.event+b,a),this._super.emit.call(this,a)}}),j(_,Z,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[bc]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&fc)},emit:function(a){if(this._super.emit.call(this,a),1!==a.scale){var b=a.scale<1?"in":"out";this.manager.emit(this.options.event+b,a)}}}),j(ab,V,{defaults:{event:"press",pointers:1,time:500,threshold:5},getTouchAction:function(){return[_b]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Ab|Bb)&&!f)this.reset();else if(a.eventType&yb)this.reset(),this._timer=e(function(){this.state=ic,this.tryEmit()},b.time,this);else if(a.eventType&Ab)return ic;return kc},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===ic&&(a&&a.eventType&Ab?this.manager.emit(this.options.event+"up",a):(this._input.timeStamp=nb(),this.manager.emit(this.options.event,this._input)))}}),j(bb,Z,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[bc]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&fc)}}),j(cb,Z,{defaults:{event:"swipe",threshold:10,velocity:.65,direction:Hb|Ib,pointers:1},getTouchAction:function(){return $.prototype.getTouchAction.call(this)},attrTest:function(a){var b,c=this.options.direction;return c&(Hb|Ib)?b=a.velocity:c&Hb?b=a.velocityX:c&Ib&&(b=a.velocityY),this._super.attrTest.call(this,a)&&c&a.direction&&a.distance>this.options.threshold&&mb(b)>this.options.velocity&&a.eventType&Ab},emit:function(a){var b=X(a.direction);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),j(db,V,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:2,posThreshold:10},getTouchAction:function(){return[ac]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime<b.time;if(this.reset(),a.eventType&yb&&0===this.count)return this.failTimeout();if(d&&f&&c){if(a.eventType!=Ab)return this.failTimeout();var g=this.pTime?a.timeStamp-this.pTime<b.interval:!0,h=!this.pCenter||I(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,h&&g?this.count+=1:this.count=1,this._input=a;var i=this.count%b.taps;if(0===i)return this.hasRequireFailures()?(this._timer=e(function(){this.state=ic,this.tryEmit()},b.interval,this),fc):ic}return kc},failTimeout:function(){return this._timer=e(function(){this.state=kc},this.options.interval,this),kc},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==ic&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),eb.VERSION="2.0.4",eb.defaults={domEvents:!1,touchAction:$b,enable:!0,inputTarget:null,inputClass:null,preset:[[bb,{enable:!1}],[_,{enable:!1},["rotate"]],[cb,{direction:Hb}],[$,{direction:Hb},["swipe"]],[db],[db,{event:"doubletap",taps:2},["tap"]],[ab]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var lc=1,mc=2;fb.prototype={set:function(a){return h(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?mc:lc},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&ic)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===mc||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(fc|gc|hc)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof V)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(f(a,"add",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(f(a,"remove",this))return this;var b=this.recognizers;return a=this.get(a),b.splice(s(b,a),1),this.touchAction.update(),this},on:function(a,b){var c=this.handlers;return g(r(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this},off:function(a,b){var c=this.handlers;return g(r(a),function(a){b?c[a].splice(s(c[a],b),1):delete c[a]}),this},emit:function(a,b){this.options.domEvents&&hb(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&gb(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},h(eb,{INPUT_START:yb,INPUT_MOVE:zb,INPUT_END:Ab,INPUT_CANCEL:Bb,STATE_POSSIBLE:ec,STATE_BEGAN:fc,STATE_CHANGED:gc,STATE_ENDED:hc,STATE_RECOGNIZED:ic,STATE_CANCELLED:jc,STATE_FAILED:kc,DIRECTION_NONE:Cb,DIRECTION_LEFT:Db,DIRECTION_RIGHT:Eb,DIRECTION_UP:Fb,DIRECTION_DOWN:Gb,DIRECTION_HORIZONTAL:Hb,DIRECTION_VERTICAL:Ib,DIRECTION_ALL:Jb,Manager:fb,Input:y,TouchAction:T,TouchInput:Q,MouseInput:M,PointerEventInput:N,TouchMouseInput:S,SingleTouchInput:O,Recognizer:V,AttrRecognizer:Z,Tap:db,Pan:$,Swipe:cb,Pinch:_,Rotate:bb,Press:ab,on:n,off:o,each:g,merge:i,extend:h,inherit:j,bindFn:k,prefixed:v}),typeof define==kb&&define.amd?define(function(){return eb}):"undefined"!=typeof module&&module.exports?module.exports=eb:a[c]=eb}(window,document,"Hammer");
var WebPullToRefresh = (function () {
	'use strict';

	/**
	 * Hold all of the default parameters for the module
	 * @type {object}
	 */	
	var defaults = {
		// ID of the element holding pannable content area
		contentEl: 'content', 

		// ID of the element holding pull to refresh loading area
		ptrEl: 'ptr', 

		// Number of pixels of panning until refresh 
		distanceToRefresh: 70, 

		// Pointer to function that does the loading and returns a promise
		loadingFunction: false,

		// Dragging resistance level
		resistance: 2.5
	};

	/**
	 * Hold all of the merged parameter and default module options
	 * @type {object}
	 */
	var options = {};

	/**
	 * Pan event parameters
	 * @type {object}
	 */
	var pan = {
		enabled: false,
		distance: 0,
		startingPositionY: 0
	};
	
	/**
	 * Easy shortener for handling adding and removing body classes.
	 */
	var bodyClass = document.body.classList;
	
	/**
	 * Initialize pull to refresh, hammer, and bind pan events.
	 * 
	 * @param {object=} params - Setup parameters for pull to refresh
	 */
	var init = function( params ) {
		params = params || {};
		options = {
			contentEl: params.contentEl || document.getElementById( defaults.contentEl ),
			ptrEl: params.ptrEl || document.getElementById( defaults.ptrEl ),
			distanceToRefresh: params.distanceToRefresh || defaults.distanceToRefresh,
			loadingFunction: params.loadingFunction || defaults.loadingFunction,
			resistance: params.resistance || defaults.resistance
		};

		if ( ! options.contentEl || ! options.ptrEl ) {
			return false;
		}

		var h = new Hammer( options.contentEl );

		h.get( 'pan' ).set( { direction: Hammer.DIRECTION_VERTICAL } );

		h.on( 'panstart', _panStart );
		h.on( 'pandown', _panDown );
		h.on( 'panup', _panUp );
		h.on( 'panend', _panEnd );
	};

	var disable= function(){
		if(options && options.contentEl){
			var h = new Hammer(options.contentEl);
			if(h)h.get('pan').set({ enable: false });
		}
	};
	
	var enable= function(){
		if(options && options.contentEl){
			var h = new Hammer(options.contentEl);
			if(h)h.get('pan').set({ enable: true });
		}
	};

	/**
	 * Determine whether pan events should apply based on scroll position on panstart
	 * 
	 * @param {object} e - Event object
	 */
	var _panStart = function(e) {
		pan.startingPositionY = document.body.scrollTop;

		if ( pan.startingPositionY === 0 ) {
			pan.enabled = true;
		}
	};

	/**
	 * Handle element on screen movement when the pandown events is firing.
	 * 
	 * @param {object} e - Event object
	 */
	var _panDown = function(e) {
		if ( ! pan.enabled ) {
			return;
		}

		e.preventDefault();
		pan.distance = e.distance / options.resistance;

		_setContentPan();
		_setBodyClass();
	};

	/**
	 * Handle element on screen movement when the pandown events is firing.
	 * 
	 * @param {object} e - Event object
	 */
	var _panUp = function(e) {
		if ( ! pan.enabled || pan.distance === 0 ) {
			return;
		}

		e.preventDefault();

		if ( pan.distance < e.distance / options.resistance ) {
			pan.distance = 0;
		} else {
			pan.distance = e.distance / options.resistance;
		}

		_setContentPan();
		_setBodyClass();
	};

	/**
	 * Set the CSS transform on the content element to move it on the screen.
	 */
	var _setContentPan = function() {
		// Use transforms to smoothly animate elements on desktop and mobile devices
		options.contentEl.style.transform = options.contentEl.style.webkitTransform = 'translate3d( 0, ' + pan.distance + 'px, 0 )';
		options.ptrEl.style.transform = options.ptrEl.style.webkitTransform = 'translate3d( 0, ' + ( pan.distance - options.ptrEl.offsetHeight ) + 'px, 0 )';
	};

	/**
	 * Set/remove the loading body class to show or hide the loading indicator after pull down.
	 */
	var _setBodyClass = function() {
		if ( pan.distance > options.distanceToRefresh ) {
			bodyClass.add( 'ptr-refresh' );
		} else {
			bodyClass.remove( 'ptr-refresh' );
		}		
	};

	/**
	 * Determine how to animate and position elements when the panend event fires.
	 * 
	 * @param {object} e - Event object
	 */
	var _panEnd = function(e) {
		if ( ! pan.enabled ) {
			return;
		}

		e.preventDefault();

		options.contentEl.style.transform = options.contentEl.style.webkitTransform = '';
		options.ptrEl.style.transform = options.ptrEl.style.webkitTransform = '';

		if ( document.body.classList.contains( 'ptr-refresh' ) ) {
			_doLoading();
		} else {
			_doReset();
		}

		pan.distance = 0;
		pan.enabled = false;
	};

	/**
	 * Position content and refresh elements to show that loading is taking place.
	 */
	var _doLoading = function() {
		bodyClass.add( 'ptr-loading' );

		// If no valid loading function exists, just reset elements
		if ( ! options.loadingFunction ) {
			return _doReset();
		}

		// The loading function should return a promise
		var loadingPromise = options.loadingFunction();

		// For UX continuity, make sure we show loading for at least one second before resetting
		setTimeout( function() {
			// Once actual loading is complete, reset pull to refresh
			loadingPromise.then( _doReset );
		}, 1000 );
	};

	/**
	 * Reset all elements to their starting positions before any paning took place.
	 */
	var _doReset = function() {
		bodyClass.remove( 'ptr-loading' );
		bodyClass.remove( 'ptr-refresh' );
		bodyClass.add( 'ptr-reset' );

		var bodyClassRemove = function() {
			bodyClass.remove( 'ptr-reset' );
			document.body.removeEventListener( 'transitionend', bodyClassRemove, false );
		};

		document.body.addEventListener( 'transitionend', bodyClassRemove, false );
	};

	return {
		init: init
		,disable: disable
		,enable: enable
	}

})();

// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// 2016-07-07, Brian Grinstead, MIT License
!function(a){function b(a,d){if(a=a?a:"",d=d||{},a instanceof b)return a;if(!(this instanceof b))return new b(a,d);var e=c(a);this._originalInput=a,this._r=e.r,this._g=e.g,this._b=e.b,this._a=e.a,this._roundA=P(100*this._a)/100,this._format=d.format||e.format,this._gradientType=d.gradientType,this._r<1&&(this._r=P(this._r)),this._g<1&&(this._g=P(this._g)),this._b<1&&(this._b=P(this._b)),this._ok=e.ok,this._tc_id=O++}function c(a){var b={r:0,g:0,b:0},c=1,e=null,g=null,i=null,j=!1,k=!1;return"string"==typeof a&&(a=K(a)),"object"==typeof a&&(J(a.r)&&J(a.g)&&J(a.b)?(b=d(a.r,a.g,a.b),j=!0,k="%"===String(a.r).substr(-1)?"prgb":"rgb"):J(a.h)&&J(a.s)&&J(a.v)?(e=G(a.s),g=G(a.v),b=h(a.h,e,g),j=!0,k="hsv"):J(a.h)&&J(a.s)&&J(a.l)&&(e=G(a.s),i=G(a.l),b=f(a.h,e,i),j=!0,k="hsl"),a.hasOwnProperty("a")&&(c=a.a)),c=z(c),{ok:j,format:a.format||k,r:Q(255,R(b.r,0)),g:Q(255,R(b.g,0)),b:Q(255,R(b.b,0)),a:c}}function d(a,b,c){return{r:255*A(a,255),g:255*A(b,255),b:255*A(c,255)}}function e(a,b,c){a=A(a,255),b=A(b,255),c=A(c,255);var d,e,f=R(a,b,c),g=Q(a,b,c),h=(f+g)/2;if(f==g)d=e=0;else{var i=f-g;switch(e=h>.5?i/(2-f-g):i/(f+g),f){case a:d=(b-c)/i+(c>b?6:0);break;case b:d=(c-a)/i+2;break;case c:d=(a-b)/i+4}d/=6}return{h:d,s:e,l:h}}function f(a,b,c){function d(a,b,c){return 0>c&&(c+=1),c>1&&(c-=1),1/6>c?a+6*(b-a)*c:.5>c?b:2/3>c?a+6*(b-a)*(2/3-c):a}var e,f,g;if(a=A(a,360),b=A(b,100),c=A(c,100),0===b)e=f=g=c;else{var h=.5>c?c*(1+b):c+b-c*b,i=2*c-h;e=d(i,h,a+1/3),f=d(i,h,a),g=d(i,h,a-1/3)}return{r:255*e,g:255*f,b:255*g}}function g(a,b,c){a=A(a,255),b=A(b,255),c=A(c,255);var d,e,f=R(a,b,c),g=Q(a,b,c),h=f,i=f-g;if(e=0===f?0:i/f,f==g)d=0;else{switch(f){case a:d=(b-c)/i+(c>b?6:0);break;case b:d=(c-a)/i+2;break;case c:d=(a-b)/i+4}d/=6}return{h:d,s:e,v:h}}function h(b,c,d){b=6*A(b,360),c=A(c,100),d=A(d,100);var e=a.floor(b),f=b-e,g=d*(1-c),h=d*(1-f*c),i=d*(1-(1-f)*c),j=e%6,k=[d,h,g,g,i,d][j],l=[i,d,d,h,g,g][j],m=[g,g,i,d,d,h][j];return{r:255*k,g:255*l,b:255*m}}function i(a,b,c,d){var e=[F(P(a).toString(16)),F(P(b).toString(16)),F(P(c).toString(16))];return d&&e[0].charAt(0)==e[0].charAt(1)&&e[1].charAt(0)==e[1].charAt(1)&&e[2].charAt(0)==e[2].charAt(1)?e[0].charAt(0)+e[1].charAt(0)+e[2].charAt(0):e.join("")}function j(a,b,c,d,e){var f=[F(P(a).toString(16)),F(P(b).toString(16)),F(P(c).toString(16)),F(H(d))];return e&&f[0].charAt(0)==f[0].charAt(1)&&f[1].charAt(0)==f[1].charAt(1)&&f[2].charAt(0)==f[2].charAt(1)&&f[3].charAt(0)==f[3].charAt(1)?f[0].charAt(0)+f[1].charAt(0)+f[2].charAt(0)+f[3].charAt(0):f.join("")}function k(a,b,c,d){var e=[F(H(d)),F(P(a).toString(16)),F(P(b).toString(16)),F(P(c).toString(16))];return e.join("")}function l(a,c){c=0===c?0:c||10;var d=b(a).toHsl();return d.s-=c/100,d.s=B(d.s),b(d)}function m(a,c){c=0===c?0:c||10;var d=b(a).toHsl();return d.s+=c/100,d.s=B(d.s),b(d)}function n(a){return b(a).desaturate(100)}function o(a,c){c=0===c?0:c||10;var d=b(a).toHsl();return d.l+=c/100,d.l=B(d.l),b(d)}function p(a,c){c=0===c?0:c||10;var d=b(a).toRgb();return d.r=R(0,Q(255,d.r-P(255*-(c/100)))),d.g=R(0,Q(255,d.g-P(255*-(c/100)))),d.b=R(0,Q(255,d.b-P(255*-(c/100)))),b(d)}function q(a,c){c=0===c?0:c||10;var d=b(a).toHsl();return d.l-=c/100,d.l=B(d.l),b(d)}function r(a,c){var d=b(a).toHsl(),e=(d.h+c)%360;return d.h=0>e?360+e:e,b(d)}function s(a){var c=b(a).toHsl();return c.h=(c.h+180)%360,b(c)}function t(a){var c=b(a).toHsl(),d=c.h;return[b(a),b({h:(d+120)%360,s:c.s,l:c.l}),b({h:(d+240)%360,s:c.s,l:c.l})]}function u(a){var c=b(a).toHsl(),d=c.h;return[b(a),b({h:(d+90)%360,s:c.s,l:c.l}),b({h:(d+180)%360,s:c.s,l:c.l}),b({h:(d+270)%360,s:c.s,l:c.l})]}function v(a){var c=b(a).toHsl(),d=c.h;return[b(a),b({h:(d+72)%360,s:c.s,l:c.l}),b({h:(d+216)%360,s:c.s,l:c.l})]}function w(a,c,d){c=c||6,d=d||30;var e=b(a).toHsl(),f=360/d,g=[b(a)];for(e.h=(e.h-(f*c>>1)+720)%360;--c;)e.h=(e.h+f)%360,g.push(b(e));return g}function x(a,c){c=c||6;for(var d=b(a).toHsv(),e=d.h,f=d.s,g=d.v,h=[],i=1/c;c--;)h.push(b({h:e,s:f,v:g})),g=(g+i)%1;return h}function y(a){var b={};for(var c in a)a.hasOwnProperty(c)&&(b[a[c]]=c);return b}function z(a){return a=parseFloat(a),(isNaN(a)||0>a||a>1)&&(a=1),a}function A(b,c){D(b)&&(b="100%");var d=E(b);return b=Q(c,R(0,parseFloat(b))),d&&(b=parseInt(b*c,10)/100),a.abs(b-c)<1e-6?1:b%c/parseFloat(c)}function B(a){return Q(1,R(0,a))}function C(a){return parseInt(a,16)}function D(a){return"string"==typeof a&&-1!=a.indexOf(".")&&1===parseFloat(a)}function E(a){return"string"==typeof a&&-1!=a.indexOf("%")}function F(a){return 1==a.length?"0"+a:""+a}function G(a){return 1>=a&&(a=100*a+"%"),a}function H(b){return a.round(255*parseFloat(b)).toString(16)}function I(a){return C(a)/255}function J(a){return!!V.CSS_UNIT.exec(a)}function K(a){a=a.replace(M,"").replace(N,"").toLowerCase();var b=!1;if(T[a])a=T[a],b=!0;else if("transparent"==a)return{r:0,g:0,b:0,a:0,format:"name"};var c;return(c=V.rgb.exec(a))?{r:c[1],g:c[2],b:c[3]}:(c=V.rgba.exec(a))?{r:c[1],g:c[2],b:c[3],a:c[4]}:(c=V.hsl.exec(a))?{h:c[1],s:c[2],l:c[3]}:(c=V.hsla.exec(a))?{h:c[1],s:c[2],l:c[3],a:c[4]}:(c=V.hsv.exec(a))?{h:c[1],s:c[2],v:c[3]}:(c=V.hsva.exec(a))?{h:c[1],s:c[2],v:c[3],a:c[4]}:(c=V.hex8.exec(a))?{r:C(c[1]),g:C(c[2]),b:C(c[3]),a:I(c[4]),format:b?"name":"hex8"}:(c=V.hex6.exec(a))?{r:C(c[1]),g:C(c[2]),b:C(c[3]),format:b?"name":"hex"}:(c=V.hex4.exec(a))?{r:C(c[1]+""+c[1]),g:C(c[2]+""+c[2]),b:C(c[3]+""+c[3]),a:I(c[4]+""+c[4]),format:b?"name":"hex8"}:(c=V.hex3.exec(a))?{r:C(c[1]+""+c[1]),g:C(c[2]+""+c[2]),b:C(c[3]+""+c[3]),format:b?"name":"hex"}:!1}function L(a){var b,c;return a=a||{level:"AA",size:"small"},b=(a.level||"AA").toUpperCase(),c=(a.size||"small").toLowerCase(),"AA"!==b&&"AAA"!==b&&(b="AA"),"small"!==c&&"large"!==c&&(c="small"),{level:b,size:c}}var M=/^\s+/,N=/\s+$/,O=0,P=a.round,Q=a.min,R=a.max,S=a.random;b.prototype={isDark:function(){return this.getBrightness()<128},isLight:function(){return!this.isDark()},isValid:function(){return this._ok},getOriginalInput:function(){return this._originalInput},getFormat:function(){return this._format},getAlpha:function(){return this._a},getBrightness:function(){var a=this.toRgb();return(299*a.r+587*a.g+114*a.b)/1e3},getLuminance:function(){var b,c,d,e,f,g,h=this.toRgb();return b=h.r/255,c=h.g/255,d=h.b/255,e=.03928>=b?b/12.92:a.pow((b+.055)/1.055,2.4),f=.03928>=c?c/12.92:a.pow((c+.055)/1.055,2.4),g=.03928>=d?d/12.92:a.pow((d+.055)/1.055,2.4),.2126*e+.7152*f+.0722*g},setAlpha:function(a){return this._a=z(a),this._roundA=P(100*this._a)/100,this},toHsv:function(){var a=g(this._r,this._g,this._b);return{h:360*a.h,s:a.s,v:a.v,a:this._a}},toHsvString:function(){var a=g(this._r,this._g,this._b),b=P(360*a.h),c=P(100*a.s),d=P(100*a.v);return 1==this._a?"hsv("+b+", "+c+"%, "+d+"%)":"hsva("+b+", "+c+"%, "+d+"%, "+this._roundA+")"},toHsl:function(){var a=e(this._r,this._g,this._b);return{h:360*a.h,s:a.s,l:a.l,a:this._a}},toHslString:function(){var a=e(this._r,this._g,this._b),b=P(360*a.h),c=P(100*a.s),d=P(100*a.l);return 1==this._a?"hsl("+b+", "+c+"%, "+d+"%)":"hsla("+b+", "+c+"%, "+d+"%, "+this._roundA+")"},toHex:function(a){return i(this._r,this._g,this._b,a)},toHexString:function(a){return"#"+this.toHex(a)},toHex8:function(a){return j(this._r,this._g,this._b,this._a,a)},toHex8String:function(a){return"#"+this.toHex8(a)},toRgb:function(){return{r:P(this._r),g:P(this._g),b:P(this._b),a:this._a}},toRgbString:function(){return 1==this._a?"rgb("+P(this._r)+", "+P(this._g)+", "+P(this._b)+")":"rgba("+P(this._r)+", "+P(this._g)+", "+P(this._b)+", "+this._roundA+")"},toPercentageRgb:function(){return{r:P(100*A(this._r,255))+"%",g:P(100*A(this._g,255))+"%",b:P(100*A(this._b,255))+"%",a:this._a}},toPercentageRgbString:function(){return 1==this._a?"rgb("+P(100*A(this._r,255))+"%, "+P(100*A(this._g,255))+"%, "+P(100*A(this._b,255))+"%)":"rgba("+P(100*A(this._r,255))+"%, "+P(100*A(this._g,255))+"%, "+P(100*A(this._b,255))+"%, "+this._roundA+")"},toName:function(){return 0===this._a?"transparent":this._a<1?!1:U[i(this._r,this._g,this._b,!0)]||!1},toFilter:function(a){var c="#"+k(this._r,this._g,this._b,this._a),d=c,e=this._gradientType?"GradientType = 1, ":"";if(a){var f=b(a);d="#"+k(f._r,f._g,f._b,f._a)}return"progid:DXImageTransform.Microsoft.gradient("+e+"startColorstr="+c+",endColorstr="+d+")"},toString:function(a){var b=!!a;a=a||this._format;var c=!1,d=this._a<1&&this._a>=0,e=!b&&d&&("hex"===a||"hex6"===a||"hex3"===a||"hex4"===a||"hex8"===a||"name"===a);return e?"name"===a&&0===this._a?this.toName():this.toRgbString():("rgb"===a&&(c=this.toRgbString()),"prgb"===a&&(c=this.toPercentageRgbString()),("hex"===a||"hex6"===a)&&(c=this.toHexString()),"hex3"===a&&(c=this.toHexString(!0)),"hex4"===a&&(c=this.toHex8String(!0)),"hex8"===a&&(c=this.toHex8String()),"name"===a&&(c=this.toName()),"hsl"===a&&(c=this.toHslString()),"hsv"===a&&(c=this.toHsvString()),c||this.toHexString())},clone:function(){return b(this.toString())},_applyModification:function(a,b){var c=a.apply(null,[this].concat([].slice.call(b)));return this._r=c._r,this._g=c._g,this._b=c._b,this.setAlpha(c._a),this},lighten:function(){return this._applyModification(o,arguments)},brighten:function(){return this._applyModification(p,arguments)},darken:function(){return this._applyModification(q,arguments)},desaturate:function(){return this._applyModification(l,arguments)},saturate:function(){return this._applyModification(m,arguments)},greyscale:function(){return this._applyModification(n,arguments)},spin:function(){return this._applyModification(r,arguments)},_applyCombination:function(a,b){return a.apply(null,[this].concat([].slice.call(b)))},analogous:function(){return this._applyCombination(w,arguments)},complement:function(){return this._applyCombination(s,arguments)},monochromatic:function(){return this._applyCombination(x,arguments)},splitcomplement:function(){return this._applyCombination(v,arguments)},triad:function(){return this._applyCombination(t,arguments)},tetrad:function(){return this._applyCombination(u,arguments)}},b.fromRatio=function(a,c){if("object"==typeof a){var d={};for(var e in a)a.hasOwnProperty(e)&&(d[e]="a"===e?a[e]:G(a[e]));a=d}return b(a,c)},b.equals=function(a,c){return a&&c?b(a).toRgbString()==b(c).toRgbString():!1},b.random=function(){return b.fromRatio({r:S(),g:S(),b:S()})},b.mix=function(a,c,d){d=0===d?0:d||50;var e=b(a).toRgb(),f=b(c).toRgb(),g=d/100,h={r:(f.r-e.r)*g+e.r,g:(f.g-e.g)*g+e.g,b:(f.b-e.b)*g+e.b,a:(f.a-e.a)*g+e.a};return b(h)},b.readability=function(c,d){var e=b(c),f=b(d);return(a.max(e.getLuminance(),f.getLuminance())+.05)/(a.min(e.getLuminance(),f.getLuminance())+.05)},b.isReadable=function(a,c,d){var e,f,g=b.readability(a,c);switch(f=!1,e=L(d),e.level+e.size){case"AAsmall":case"AAAlarge":f=g>=4.5;break;case"AAlarge":f=g>=3;break;case"AAAsmall":f=g>=7}return f},b.mostReadable=function(a,c,d){var e,f,g,h,i=null,j=0;d=d||{},f=d.includeFallbackColors,g=d.level,h=d.size;for(var k=0;k<c.length;k++)e=b.readability(a,c[k]),e>j&&(j=e,i=b(c[k]));return b.isReadable(a,i,{level:g,size:h})||!f?i:(d.includeFallbackColors=!1,b.mostReadable(a,["#fff","#000"],d))};var T=b.names={aliceblue:"f0f8ff",antiquewhite:"faebd7",aqua:"0ff",aquamarine:"7fffd4",azure:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"000",blanchedalmond:"ffebcd",blue:"00f",blueviolet:"8a2be2",brown:"a52a2a",burlywood:"deb887",burntsienna:"ea7e5d",cadetblue:"5f9ea0",chartreuse:"7fff00",chocolate:"d2691e",coral:"ff7f50",cornflowerblue:"6495ed",cornsilk:"fff8dc",crimson:"dc143c",cyan:"0ff",darkblue:"00008b",darkcyan:"008b8b",darkgoldenrod:"b8860b",darkgray:"a9a9a9",darkgreen:"006400",darkgrey:"a9a9a9",darkkhaki:"bdb76b",darkmagenta:"8b008b",darkolivegreen:"556b2f",darkorange:"ff8c00",darkorchid:"9932cc",darkred:"8b0000",darksalmon:"e9967a",darkseagreen:"8fbc8f",darkslateblue:"483d8b",darkslategray:"2f4f4f",darkslategrey:"2f4f4f",darkturquoise:"00ced1",darkviolet:"9400d3",deeppink:"ff1493",deepskyblue:"00bfff",dimgray:"696969",dimgrey:"696969",dodgerblue:"1e90ff",firebrick:"b22222",floralwhite:"fffaf0",forestgreen:"228b22",fuchsia:"f0f",gainsboro:"dcdcdc",ghostwhite:"f8f8ff",gold:"ffd700",goldenrod:"daa520",gray:"808080",green:"008000",greenyellow:"adff2f",grey:"808080",honeydew:"f0fff0",hotpink:"ff69b4",indianred:"cd5c5c",indigo:"4b0082",ivory:"fffff0",khaki:"f0e68c",lavender:"e6e6fa",lavenderblush:"fff0f5",lawngreen:"7cfc00",lemonchiffon:"fffacd",lightblue:"add8e6",lightcoral:"f08080",lightcyan:"e0ffff",lightgoldenrodyellow:"fafad2",lightgray:"d3d3d3",lightgreen:"90ee90",lightgrey:"d3d3d3",lightpink:"ffb6c1",lightsalmon:"ffa07a",lightseagreen:"20b2aa",lightskyblue:"87cefa",lightslategray:"789",lightslategrey:"789",lightsteelblue:"b0c4de",lightyellow:"ffffe0",lime:"0f0",limegreen:"32cd32",linen:"faf0e6",magenta:"f0f",maroon:"800000",mediumaquamarine:"66cdaa",mediumblue:"0000cd",mediumorchid:"ba55d3",mediumpurple:"9370db",mediumseagreen:"3cb371",mediumslateblue:"7b68ee",mediumspringgreen:"00fa9a",mediumturquoise:"48d1cc",mediumvioletred:"c71585",midnightblue:"191970",mintcream:"f5fffa",mistyrose:"ffe4e1",moccasin:"ffe4b5",navajowhite:"ffdead",navy:"000080",oldlace:"fdf5e6",olive:"808000",olivedrab:"6b8e23",orange:"ffa500",orangered:"ff4500",orchid:"da70d6",palegoldenrod:"eee8aa",palegreen:"98fb98",paleturquoise:"afeeee",palevioletred:"db7093",papayawhip:"ffefd5",peachpuff:"ffdab9",peru:"cd853f",pink:"ffc0cb",plum:"dda0dd",powderblue:"b0e0e6",purple:"800080",rebeccapurple:"663399",red:"f00",rosybrown:"bc8f8f",royalblue:"4169e1",saddlebrown:"8b4513",salmon:"fa8072",sandybrown:"f4a460",seagreen:"2e8b57",seashell:"fff5ee",sienna:"a0522d",silver:"c0c0c0",skyblue:"87ceeb",slateblue:"6a5acd",slategray:"708090",slategrey:"708090",snow:"fffafa",springgreen:"00ff7f",steelblue:"4682b4",tan:"d2b48c",teal:"008080",thistle:"d8bfd8",tomato:"ff6347",turquoise:"40e0d0",violet:"ee82ee",wheat:"f5deb3",white:"fff",whitesmoke:"f5f5f5",yellow:"ff0",yellowgreen:"9acd32"},U=b.hexNames=y(T),V=function(){var a="[-\\+]?\\d+%?",b="[-\\+]?\\d*\\.\\d+%?",c="(?:"+b+")|(?:"+a+")",d="[\\s|\\(]+("+c+")[,|\\s]+("+c+")[,|\\s]+("+c+")\\s*\\)?",e="[\\s|\\(]+("+c+")[,|\\s]+("+c+")[,|\\s]+("+c+")[,|\\s]+("+c+")\\s*\\)?";return{CSS_UNIT:new RegExp(c),rgb:new RegExp("rgb"+d),rgba:new RegExp("rgba"+e),hsl:new RegExp("hsl"+d),hsla:new RegExp("hsla"+e),hsv:new RegExp("hsv"+d),hsva:new RegExp("hsva"+e),hex3:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex6:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,hex4:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex8:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/}}();"undefined"!=typeof module&&module.exports?module.exports=b:"function"==typeof define&&define.amd?define(function(){return b}):window.tinycolor=b}(Math);
(function () {
    console.log('httpClient is loading');
    function CustomPromise(callback) {
        this.promise = new Promise(callback);
        this.promise.success = function (callback) {
            this.then(callback);
            return this;
        };
        this.promise.error = function (callback) {
            this.then(null, callback);
            return this;
        };
        return this.promise;
    }

    function httpClient() {
    }
    httpClient.get = function (url, config) {
        return httpClient.request('GET', url, undefined, config);
    };
    httpClient.post = function (url, data, config) {
        return httpClient.request('POST', url, data);
    };
    httpClient.put = function (url, data, config) {
        return httpClient.request('PUT', url, data);
    };
    httpClient.jsonp = function (url, data, config) {
        var req = {
            url: url,
            data: data,
            config: config
        };
        throw new Error('jsonp not ready');
    };

    httpClient.request = function (method, url, data, config) {
        console.log('httpClient create request for url: ', url, ' using method: ', method);
        return new CustomPromise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.onload = function () {
                console.log('httpClient read response for url: ', url, ' using method: ', method);
                var options = {
                    status: xhr.status,
                    statusText: xhr.statusText
                };
                var body = 'response' in xhr ? xhr.response : xhr.responseText;
                resolve(body ? JSON.parse(body) : null);
            };
            xhr.onerror = function () {
                console.log('httpClient failed for url: ', url, ' using method: ', method);
                reject(new TypeError('Network request failed'));
            };
            xhr.ontimeout = function () {
                console.log('httpClient timed out for url: ', url, ' using method: ', method);
                reject(new TypeError('Network request failed'));
            };

            console.log('httpClient requesting for url: ', url, ' using method: ', method);
            xhr.open(method, url, true);
            xhr.send(data);
        });
    };
    
    window.httpClient = httpClient;
}());
"use strict";

/*Utility class for any random function we may neeed in the future  */
var bfUtils = {
    get deviceOnline () {
        if (typeof(navigator) != "undefined") {
            if (navigator.connection && navigator.connection.type)
                return navigator.connection.type != "none";
            else if (typeof(navigator.onLine) != "undefined") {
                return navigator.onLine;
            } else {
                return true;
            }
        } else
            return true;
    },
    get isMobileDevice () {
        return window.location.protocol.indexOf('http') < 0;
    },
    get isAndroid () {
        return window.location.protocol.indexOf('http') < 0 && typeof device != "undefined" && device.platform == "Android";
    },
    get isIOS () {
        return window.location.protocol.indexOf('http') < 0 && typeof device != "undefined" && device.platform == "iOS";
    },
    get isPwaAndroid(){
        var isMatch = (navigator.userAgent.match(/Android/i)) ? true : false;

      return isMatch;
    },
    get isPwaiOS() {
        return (("standalone" in window.navigator) && !window.navigator.standalone);
    },
    get isAppHtml5Version(){
        return window.self == window.top;
    },
    get isEmulatorCP() {
        return window.top && window.top != window && window.location.protocol.indexOf('http') == 0;
    },
    get isApp() {
        return window.siteConfig ? window.siteConfig.scope === "app" : false;
    },
    tryParseJSON : function(str){
        try {
            return JSON.parse(str);
        }
        catch(e){
            console.error('Cannot parse data :: ' + str , e.message , e.stack) ;
            return undefined;
        }
    },
    get http () {
        if(window.$http){
            return window.$http;
        }
        else {
            return window.httpClient;
        }
    }
};


"use strict";
var customRegistration = {
    googleMapServices: {},
    get wl_name() {
        let whitlabelName = 'Full ';

        if (appContext && appContext.currentApp && appContext.currentApp.config) {
            whitlabelName = appContext.currentApp.config.whitlabelName + ' ';
        }

        return whitlabelName;
    },
    getSettings: function(options, callback) {
        let tagName = 'appearance',
            context = {
                appId: window.appContext.currentApp.appId
                , pluginId: tagName
                , instanceId: tagName
            };

        let dsAppearance = new window.DatastoreAPI(context);

        dsAppearance.get({tag: tagName, withDynamicData: true}, function(err, result){
            if(err){
                console.error(err);
                callback(err);
                return;
            }
            if (result && result.data && result.data.customRegistration && window.appContext.currentApp.config.type === "enterprise") {
                callback(null, result.data.customRegistration);
            } else {
                callback(null, null);
            }
        });
    },
    getFields: function(options, callback) {
        let customRegistrationFields = options.customRegistrationSettings;
        if (customRegistrationFields && customRegistrationFields.singlePage && customRegistrationFields.singlePage.formControls) {
            let fields = [];
            let rules = {};
            let gdprLinks = [];
            let initializers = [];

            customRegistrationFields.singlePage.formControls.forEach(function(control, controlIndex){
                switch(control.id){
                    case 'fullName':
                        if(control.active) {
                            if(control.settings.displayNameEnabled) {
                                fields.push({
                                    type: "text",
                                    viewType: "none",
                                    name: "displayName",
                                    order: controlIndex,
                                    label: control.options.fieldsLabels.displayName,
                                    iconClass: control.icon,
                                    validate: function(value) {
                                        this.error = null;
                                        if ((!value || !value.trim().length) && control.settings.required) {
                                            this.error = control.options.errorMessages.fullNameRequired;
                                        }
                                    },
                                    touch: function(value) {
                                        this.validate(value);
                                    },
                                    messages: control.options.errorMessages,
                                    value: options.defaults ? options.defaults.displayName : undefined
                                });
                            }
                            if(control.settings.firstNameEnabled) {
                                fields.push({
                                    type: "text",
                                    viewType: "text",
                                    name: "firstName",
                                    order: controlIndex,
                                    label: control.options.fieldsLabels.firstName,
                                    iconClass: control.icon,
                                    validate: function(value) {
                                        this.error = null;
                                        if ((!value || !value.trim().length) && control.settings.required) {
                                            this.error = control.options.errorMessages.fullNameRequired;
                                        }
                                    },
                                    touch: function(value) {
                                        this.validate(value);
                                    },
                                    messages: control.options.errorMessages,
                                    value: options.defaults ? options.defaults.firstName : undefined
                                });
                            }
                            if(control.settings.lastNameEnabled) {
                                fields.push({
                                    type: "text",
                                    viewType: "text",
                                    name: "lastName",
                                    order: controlIndex,
                                    label: control.options.fieldsLabels.lastName,
                                    iconClass: control.icon,
                                    validate: function(value) {
                                        this.error = null;
                                        if ((!value || !value.trim().length) && control.settings.required) {
                                            this.error = control.options.errorMessages.fullNameRequired;
                                        }
                                    },
                                    touch: function(value) {
                                        this.validate(value);
                                    },
                                    messages: control.options.errorMessages,
                                    value: options.defaults ? options.defaults.lastName : undefined
                                });
                            }
                        }
                        break;
                    case 'email':
                        fields.push({
                            type: "email",
                            viewType: "email",
                            name: "email",
                            autocorrect: "off",
                            autocapitalize: "none",
                            order: controlIndex,
                            label: control.options.fieldsLabels.email,
                            iconClass: control.icon,
                            validate: function(value) {
                                this.error = null;
                                if ((!value || !value.trim().length)) {
                                    this.error = control.options.errorMessages.emailRequired;
                                    return;
                                }
                                if (!window.validator.validateEmail(value)) {
                                    this.error = control.options.errorMessages.emailInvalidFormat;
                                    return;
                                }
                                if ((!value || !value.trim().length)) {
                                    this.error = control.options.errorMessages.emailAlreadyInUse;
                                }
                            },
                            touch: function(value) {
                                this.validate(value);
                            },
                            messages: control.options.errorMessages,
                            value: options.defaults ? options.defaults.email : undefined
                        });
                        break;
                    case 'address':
                        if(control.active) {
                            let googleMapsApiKey = control.options.addressGoogleApiKey;
                            if (control.options.addressGoogleApiKey) {
                                initializers.push(function() {
                                    setTimeout(function(){
                                        let node = document.getElementById('customRegistrationScript');
                                        if(node) {
                                            document.getElementsByTagName('head')[0].removeChild(node);
                                        }
                                        customRegistration.googleMapServices.mapsApiKeyError = null;
                                        node = document.createElement('script');
                                        node.id = 'customRegistrationScript';
                                        node.src = `https://maps.googleapis.com/maps/api/js?key=${googleMapsApiKey}&libraries=places&callback=googleMapsInitCallback`;
                                        node.type = 'text/javascript';
                                        document.getElementsByTagName('head')[0].appendChild(node);

                                        window.googleMapsInitCallback = function() {
                                            customRegistration.googleMapServices.autoAddressCompleteService = new google.maps.places.AutocompleteService();
                                            customRegistration.googleMapServices.addressGeocoder = new google.maps.Geocoder();

                                        };
                                        if (options.refreshUI) options.refreshUI();
                                    }, 0);
                                });
                            }
                            if(control.settings.showFullAddress) {
                                fields.push({
                                    type: "text",
                                    viewType: "text",
                                    name: "address",
                                    order: controlIndex,
                                    label: control.options.fieldsLabels.address,
                                    iconClass: control.icon,
                                    change: function(value) {
                                        let field = this;
                                        field.extra = null;
                                        if(customRegistration.googleMapServices.mapsApiKeyError) {
                                            field.error = customRegistration.googleMapServices.mapsApiKeyError;
                                        }
                                        if(customRegistration.googleMapServices.autoAddressCompleteService) {
                                            customRegistration.googleMapServices.checkMapsApiKeyErrors = true;
                                            // don't keep listening to google maps api authentication errors
                                            setTimeout(function() {
                                                customRegistration.googleMapServices.checkMapsApiKeyErrors = false;
                                            }, 3000);
                                            customRegistration.googleMapServices.autoAddressCompleteService.getPlacePredictions({
                                                input: value
                                            }, function(predictions, status) {
                                                if (status !== google.maps.places.PlacesServiceStatus.OK) {
                                                    field.error = control.options.errorMessages.invalidGoogleAddress;
                                                }
                                                field.suggestions = predictions;
                                                if (options.refreshUI) options.refreshUI();
                                            });
                                        } else {
                                            field.error = control.options.errorMessages.invalidGoogleAddress;
                                        }
                                    },
                                    selectSuggestion: function(suggestion) {
                                        let field = this;
                                        field.error = null;
                                        field.suggestions = null;
                                        field.value = suggestion.description;

                                        customRegistration.googleMapServices.addressGeocoder.geocode({placeId: suggestion.place_id}, function(results, status) {
                                            if(results && results[0] && results[0]) {
                                                let lat = results[0].geometry.location.lat();
                                                let lng = results[0].geometry.location.lng();
                                                if(control.settings.required) {
                                                    let street = results[0].address_components.find(function(addressComponent) {
                                                        return addressComponent.types && addressComponent.types.find(function(addressType) {
                                                            return addressType === "street_number";
                                                        });
                                                    });
                                                    if (!street) {
                                                        field.error = control.options.errorMessages.invalidGoogleAddress;
                                                    }
                                                }
                                                field.extra = { lat: lat, lng: lng, place: suggestion, addressComponents: results[0].address_components };
                                            } else {
                                                field.error = control.options.errorMessages.invalidGoogleAddress;
                                            }
                                            if (options.refreshUI) options.refreshUI();
                                        });
                                    },
                                    validate: function(value) {
                                        let field = this;
                                        field.error = null;
                                        if ((!value || !value.trim().length) && control.settings.required) {
                                            this.error =  control.options.errorMessages.addressRequired;
                                            return;
                                        }
                                        if (!field.extra) {
                                            this.error =  control.options.errorMessages.invalidGoogleAddress;
                                        }
                                    },
                                    touch: function(value) {
                                        if(!this.suggestions && !this.suggestions.length) {
                                            this.validate(value);
                                        }
                                    },
                                    messages: control.options.errorMessages,
                                    value: options.defaults && options.defaults.userProfile && options.defaults.userProfile.address
                                        ? options.defaults.userProfile.address.fullAddress : undefined,
                                    extra: options.defaults && options.defaults.userProfile && options.defaults.userProfile.address
                                        ? options.defaults.userProfile.address.geoLocation : undefined
                                });
                                if(control.settings.showAptNo) {
                                    fields.push({
                                        type: "text",
                                        viewType: "text",
                                        name: "aptNo",
                                        order: controlIndex,
                                        label: control.options.fieldsLabels.aptNo,
                                        iconClass: control.icon,
                                        containerClass: "small-login-field",
                                        validate: function(value) {
                                            this.error = null;
                                            if ((!value || !value.trim().length) && control.settings.required) {
                                                this.error =  control.options.errorMessages.addressRequired;
                                            }
                                        },
                                        touch: function(value) {
                                            this.validate(value);
                                        },
                                        messages: control.options.errorMessages,
                                        value: options.defaults && options.defaults.userProfile
                                                && options.defaults.userProfile.address
                                                && options.defaults.userProfile.address.customFields
                                            ? options.defaults.userProfile.address.customFields.aptNo : undefined
                                    });
                                }
                            }
                            if(control.settings.showZipCode) {
                                fields.push({
                                    type: "text",
                                    viewType: "text",
                                    name: "zipCode",
                                    order: controlIndex,
                                    label: control.options.fieldsLabels.zipCode,
                                    iconClass: control.icon,
                                    validate: function(value) {
                                        this.error = null;
                                        if ((!value || !value.trim().length) && control.settings.required) {
                                            this.error =  control.options.errorMessages.addressRequired;
                                        }
                                    },
                                    touch: function(value) {
                                        this.validate(value);
                                    },
                                    messages: control.options.errorMessages,
                                    value: options.defaults && options.defaults.userProfile
                                    && options.defaults.userProfile.address
                                    && options.defaults.userProfile.address.customFields
                                        ? options.defaults.userProfile.address.customFields.zipCode : undefined
                                });
                            }
                        }
                        break;
                    case 'password':
                        if(!options.isProfileMode) {
                            fields.push({
                                type: "password",
                                name: "password",
                                order: controlIndex,
                                label: control.options.fieldsLabels.password,
                                iconClass: control.icon,
                                togglePasswordVisibility: control.settings.validation === "showHidePassword",
                                info: control.settings.passwordStrength === "simple" ? control.options.infoMessages.passwordSimpleRules : control.options.infoMessages.passwordRules,
                                validate: function(value) {
                                    this.error = null;
                                    if(control.settings.validation === "retypePassword") {
                                        let retypePasswordField = fields.find(function(element) {
                                            return element.name === "retypePassword";
                                        });
                                        retypePasswordField.error = null;
                                    }
                                    if ((!value || !value.trim().length)) {
                                        this.error = control.options.errorMessages.passwordRequired;
                                        return;
                                    }
                                    if (!window.validator.validatePassword(value, {simplePasswordValidation: control.settings.passwordStrength === "simple"})) {
                                        this.error = control.settings.passwordStrength === "simple" ? control.options.errorMessages.invalidPasswordSimpleRules : control.options.errorMessages.invalidPasswordRules;
                                    }
                                },
                                touch: function(value) {
                                    this.validate(value);
                                },
                                messages: control.options.errorMessages
                            });
                            if(control.settings.validation === "retypePassword") {
                                fields.push({
                                    type: "password",
                                    name: "retypePassword",
                                    order: controlIndex,
                                    label: control.options.fieldsLabels.retypePassword,
                                    iconClass: control.icon,
                                    togglePasswordVisibility: control.settings.validation === "showHidePassword",
                                    validate: function(value) {
                                        let passwordField = fields.find(function(element) {
                                            return element.name === "password";
                                        });
                                        this.error = null;
                                        if ((!value || !value.trim().length)) {
                                            this.error = control.options.errorMessages.passwordRequired;
                                            return;
                                        }
                                        if (passwordField.value !== value) {
                                            this.error = control.options.errorMessages.passwordsDontMatch;
                                        }
                                    },
                                    touch: function(value) {
                                        this.validate(value);
                                    },
                                    messages: control.options.errorMessages
                                });
                            }
                        }
                        rules.passwordStrength = control.settings.passwordStrength;
                        break;
                    case 'bio':
                        if(control.active) {
                            fields.push({
                                type: "textarea",
                                viewType: "multiline",
                                name: "bio",
                                order: controlIndex,
                                label: control.options.fieldsLabels.bio,
                                iconClass: control.icon,
                                validate: function (value) {
                                    this.error = null;
                                    if ((!value || !value.trim().length) && control.settings.required) {
                                        this.error = control.options.errorMessages.bioRequired;
                                    }
                                },
                                touch: function(value) {
                                    this.validate(value);
                                },
                                messages: control.options.errorMessages,
                                value: options.defaults && options.defaults.userProfile
                                    ? options.defaults.userProfile.bio : undefined
                            });
                        }
                        break;
                    case 'telephone':
                        if(control.active) {
                            fields.push({
                                type: "text",
                                viewType: "text",
                                name: "tel",
                                order: controlIndex,
                                label: control.options.fieldsLabels.tel,
                                iconClass: control.icon,
                                validate: function(value) {
                                    this.error = null;
                                    if ((!value || !value.trim().length) && control.settings.required) {
                                        this.error =  control.options.errorMessages.invalidEntry;
                                        return;
                                    }
                                    if(value) {
                                        let isValid = /^(?:(?:\(?(?:00|\+)([1-4]\d\d|[1-9]\d?)\)?)?[\-\.\ \\\/]?)?((?:\(?\d{1,}\)?[\-\.\ \\\/]?){0,})(?:[\-\.\ \\\/]?(?:#|ext\.?|extension|x)[\-\.\ \\\/]?(\d+))?$/i.test(value)
                                        if(!isValid) {
                                            this.error =  control.options.errorMessages.invalidEntry;
                                        }
                                    }
                                },
                                info: control.settings.showReasonForTelephone ? control.options.infoMessages.reasonForTelephone : null,
                                touch: function(value) {
                                    this.validate(value);
                                },
                                messages: control.options.errorMessages,
                                value: options.defaults && options.defaults.userProfile
                                    ? options.defaults.userProfile.tel : undefined
                            });
                        }
                        break;
                    case 'birthDate':
                        if(control.active) {
                            let getDisplayValue = function(value){
                                if(value) {
                                    return moment(value).format('L');
                                }
                                return null;
                            };
                            fields.push({
                                type: "date",
                                viewType: "text",
                                name: "birthDate",
                                order: controlIndex,
                                label: control.options.fieldsLabels.dateBirth,
                                minDate: control.settings.maxAgeIsRequired && control.settings.maxAgeRequired ? moment().subtract(control.settings.maxAgeRequired, 'years').toDate() : undefined,
                                maxDate: control.settings.minAgeIsRequired && control.settings.minAgeRequired ? moment().subtract(control.settings.minAgeRequired, 'years').toDate() : undefined,
                                iconClass: control.icon,
                                displayValue: getDisplayValue(options.defaults && options.defaults.userProfile
                                    ? options.defaults.userProfile.birthDate : undefined),
                                validate: function(value) {
                                    this.error = null;
                                    if (!value) {
                                        if (control.settings.required) {
                                            this.error =  control.options.errorMessages.birthRequired;
                                        }
                                        return;
                                    }
                                    let momentDate = moment(value);
                                    let years = moment().diff(momentDate, 'years');
                                    if(control.settings.maxAgeIsRequired && control.settings.maxAgeRequired && years > control.settings.maxAgeRequired) {
                                        this.error =  control.options.errorMessages.maxAge + " " + control.settings.maxAgeRequired;
                                        return;
                                    }
                                    if(control.settings.minAgeIsRequired && control.settings.minAgeRequired && years < control.settings.minAgeRequired) {
                                        this.error =  control.options.errorMessages.minAge + " " + control.settings.minAgeRequired;
                                    }
                                },
                                change: function(value) {
                                    this.validate(value);
                                    this.displayValue = getDisplayValue(value);
                                },
                                touch: function(value) {
                                    this.validate(value);
                                },
                                messages: control.options.errorMessages,
                                value: options.defaults && options.defaults.userProfile ?
                                    (options.defaults.userProfile.birthDate ? new Date(options.defaults.userProfile.birthDate) : null) : undefined
                            });
                        }
                        break;
                    case 'termsConditionsAndPrivacyPolicy':
                        if(!options.isProfileMode) {
                            if(control.active) {
                                let tosLabel = customRegistration.wl_name + 'Terms Of Use';
                                let privacyLabel = customRegistration.wl_name + 'Privacy Policy';

                                gdprLinks.push({
                                    type: "check",
                                    name: "termsAndConditions",
                                    order: 1,
                                    preLinkText: control.options.fieldsLabels.iAccept,
                                    linkText: control.options.fieldsLabels.termsAndConditions,
                                    key: control.settings.termsAndConditionsDocumentKey,
                                    iconClass: control.icon,
                                    validate: function(value) {
                                        this.error = null;
                                        if (!value) {
                                            this.error = control.options.errorMessages.termsAndConditionsAcceptRequired;
                                        }
                                    },
                                    touch: function(value) {
                                        this.validate(value);
                                    },
                                    open: function() {
                                        options.openGDPRContent({ key: control.settings.termsAndConditionsDocumentKey, defaultContentKey: 'bf_terms_and_conditions', defaultContentLabel: tosLabel });
                                    }
                                });
                                gdprLinks.push({
                                    type: "check",
                                    name: "privacyPolicy",
                                    order: 2,
                                    preLinkText: control.options.fieldsLabels.iAccept,
                                    linkText: control.options.fieldsLabels.privacyPolicy,
                                    key: control.settings.privacyPolicyDocumentKey,
                                    iconClass: control.icon,
                                    validate: function(value) {
                                        this.error = null;
                                        if (!value) {
                                            this.error = control.options.errorMessages.termsAndConditionsAcceptRequired;
                                        }
                                    },
                                    touch: function(value) {
                                        this.validate(value);
                                    },
                                    open: function() {
                                        options.openGDPRContent({key: control.settings.privacyPolicyDocumentKey, defaultContentKey: 'bf_privacy_policy', defaultContentLabel: privacyLabel });
                                    }
                                });
                            }
                        }
                        break;
                    default:
                        break;
                }
            });
            let fetch = function(options, callback) {
                let hasErrors = false;
                let registrationInfo = {};
                if(options && options.validateFields) {
                    fields.forEach(function (field) {
                        field.validate(field.value);
                        if (field.error) {
                            hasErrors = true;
                        }
                        registrationInfo[field.name] = {
                            value: field.value,
                            extra: field.extra,
                            messages: field.messages
                        };
                    });
                }
                if(options && options.validateLinks) {
                    if(gdprLinks) {
                        gdprLinks.forEach(function(link){
                            link.validate(link.value);
                            if(link.error) {
                                hasErrors = true;
                            }
                        });
                    }
                }
                if (!hasErrors) {

                    callback(null, {
                        // return an object that matches kauth schema
                        user: {
                            email: registrationInfo.email.value,
                            password: registrationInfo.password ? registrationInfo.password.value : undefined,
                            firstName: registrationInfo.firstName ? registrationInfo.firstName.value : undefined,
                            lastName: registrationInfo.lastName ? registrationInfo.lastName.value : undefined,
                            displayName: registrationInfo.displayName ? registrationInfo.displayName.value : undefined,
                            userProfile: {
                                address: {
                                    fullAddress: registrationInfo.address ? registrationInfo.address.value : undefined,
                                    customFields: {
                                        aptNo: registrationInfo.aptNo ? registrationInfo.aptNo.value : undefined,
                                        zipCode: registrationInfo.zipCode ? registrationInfo.zipCode.value : undefined,
                                    },
                                    geoLocation: registrationInfo.address && registrationInfo.address.extra ? registrationInfo.address.extra : undefined,
                                },
                                bio: registrationInfo.bio ? registrationInfo.bio.value : undefined,
                                birthDate: registrationInfo.birthDate ?
                                    (registrationInfo.birthDate.value ? new Date(registrationInfo.birthDate.value) : null) : undefined,
                                tel: registrationInfo.tel ? registrationInfo.tel.value : undefined,
                            }
                        },
                        messages: {
                            emailAlreadyInUse: registrationInfo.email.messages.emailAlreadyInUse
                        }
                    });
                } else {
                    callback(true, null);
                }
            };
            callback(null, {fields: fields, rules: rules, gdprLinks: gdprLinks, initializers: initializers, fetch: fetch});
        } else {
            callback(null, null);
        }
    },
};

function gm_authFailure() {
    if(customRegistration.googleMapServices.checkMapsApiKeyErrors) {
        customRegistration.googleMapServices.mapsApiKeyError = "There seems to be an issue with google maps key";
    }
}
/**
 * Created by Rami on 03/08/2016.
 */
"use strict";
var userTags = {
    get isUserTaggingEnabled() {
        return window.appContext && window.appContext.currentApp && window.appContext.currentApp.config && window.appContext.currentApp.config.userTagging && window.appContext.currentApp.config.userTagging != "hidden" && window.appContext.currentApp.config.userTagging != "disabled";
    },
    init: function () {
    },
    checkPluginAccessSettings: function (pluginInstance, callback) {
        var accessSettings = pluginInstance.accessSettings;

        //skip the tag permission settings if the user on EmulatorCP
        if (!bfUtils.isEmulatorCP && pluginInstance.requiresLogin) {
            authAPI.getCurrentUser(function (err, user) {
                if (err) {
                    console.error(err);
                    callback(err, null);
                    return;
                }
                if (user) {
                    if (!userTags.isUserTaggingEnabled
                        || window.appContext.currentApp.config.advancedPluginAccessSettings != 'enabled') {
                        callback(null, true);
                        return;
                    }

                    if (!accessSettings) {
                        callback(null, true);
                        return;
                    }

                    if (!accessSettings.requiresTags) {
                        callback(null, true);
                        return;
                    }

                    if (!accessSettings.requiredTags || accessSettings.requiredTags.length == 0) {
                        callback(null, true);
                        return;
                    }

                    if (accessSettings.giveAccessWhen) {
                        if (user.tags && user.tags[window.appContext.currentApp.appId] && user.tags[window.appContext.currentApp.appId].length > 0) {

                            var tags = user.tags[window.appContext.currentApp.appId];

                            if (accessSettings.giveAccessWhen == 'matchAllTags') {
                                for (var i = 0; i < accessSettings.requiredTags.length; i++) {
                                    var matched = false;
                                    for (var j = 0; j < tags.length; j++) {
                                        if (tags[j].tagName == accessSettings.requiredTags[i].name && accessSettings.requiredTags[i].appliedCount <= tags[j].appliedCount) {
                                            matched = true;
                                            break;
                                        }
                                    }

                                    if (!matched) {
                                        callback(null, false);
                                        return;
                                    }
                                }
                                callback(null, true);
                                /*If all the required tags have been checked and none of them doesn't match the criteria then return true*/
                            } else {
                                for (var i = 0; i < accessSettings.requiredTags.length; i++) {
                                    for (var j = 0; j < tags.length; j++) {
                                        if (tags[j].tagName == accessSettings.requiredTags[i].name && accessSettings.requiredTags[i].appliedCount <= tags[j].appliedCount) {
                                            callback(null, true);
                                            return;
                                        }
                                    }
                                }
                                callback(null, false);
                                /*If all the required tags have been checked and none of them match the criteria then return false*/
                            }
                        } else {
                            callback(null, false);
                        }
                    }
                    else
                        callback(null, false);
                }
                else {
                    callback(null, false);
                }
            });
        } else {
            callback(null, true);
        }
    },
    setBehavioralTags: function (instanceId) {
        //skip the BehavioralTags if the user on EmulatorCP
        if (!bfUtils.isEmulatorCP && bfUtils.deviceOnline && userTags.isUserTaggingEnabled) {
            authAPI.getCurrentUser(null, function (err, user) {
                if (err)
                    console.log(err);
                else if (user) {
                    bfUtils.http.post(window.siteConfig.endPoints.appHost + "/api/userTagging/app/" + window.appContext.currentApp.appId + "/user/assignBehavioralTag", {
                        instanceId: instanceId,
                        accessToken: user.accessToken
                    })
                        .success(function (requiresHardBuild) {

                        })
                        .error(function (err) {
                                console.log(err);
                            }
                        );
                }
            });
        }
    },
    removeProfileTags: function (callback) {
        var tags = ["$$profile_birth_year:", "$$profile_birth_month:", "$$profile_zip:" , "$$profile_city:" , "$$profile_state:" , "$$profile_town:" , "$$profile_country:"];
        userTags.unassignUserTags(tags , {isPrefix : true ,  removeTag: true} , function (err,result) {
            if(err)
                callback(err, null);
            else
                callback(null, true);

        });
    },
    setRegistrationTags: function (userProfile, isNewRegistration, callback) {

        var getAddressComponent = function(place, type) {
            let result;

            for (let i = 0; i < place.length; i++) {
                const addressType = place[i].types[0];
                if (addressType == type ) {
                    result = place[i].short_name;
                    return result;
                }
            }
            return;
        };

        if (userTags.isUserTaggingEnabled) {
            var registrationTags = [];

            if (isNewRegistration) {
                var currentDate = new Date();
                registrationTags.push("$$registered");
                registrationTags.push("$$registered_year:" + currentDate.getFullYear());
                registrationTags.push("$$registered_month:" + (currentDate.getMonth() + 1));
            }


            if (userProfile) {
                if (userProfile.birthDate) {
                    registrationTags.push("$$profile_birth_year:" + userProfile.birthDate.getFullYear());
                    registrationTags.push("$$profile_birth_month:" + (userProfile.birthDate.getMonth() + 1))
                }

                if (userProfile.address && userProfile.address.customFields && userProfile.address.customFields.zipCode) {
                    registrationTags.push("$$profile_zip:" + userProfile.address.customFields.zipCode);
                }

                if(userProfile.address &&  userProfile.address.geoLocation && userProfile.address.geoLocation.addressComponents){
                    var country = getAddressComponent(userProfile.address.geoLocation.addressComponents , "country");
                    if(country)
                        registrationTags.push("$$profile_country:" + country.replace(/ /g, "_"));

                    var state = getAddressComponent(userProfile.address.geoLocation.addressComponents , "administrative_area_level_1");
                    if(state)
                        registrationTags.push("$$profile_state:" + state.replace(/ /g, "_"));

                    var city = getAddressComponent(userProfile.address.geoLocation.addressComponents , "administrative_area_level_2");
                    if(city)
                        registrationTags.push("$$profile_city:" + city.replace(/ /g, "_"));

                    var town = getAddressComponent(userProfile.address.geoLocation.addressComponents , "locality");
                    if(town)
                        registrationTags.push("$$profile_town:" + town.replace(/ /g, "_"));


                }
            }


            if (!isNewRegistration) {
                userTags.removeProfileTags(function (err, result) {
                    if (err)
                        callback(err);
                    else {
                        userTags.assignUserTags(registrationTags,callback);
                    }
                });
            } else {
                userTags.assignUserTags(registrationTags,callback);
            }
        }
    },
    assignUserTags: function (tags, callback) {
        if(typeof(tags) == "string")
            tags = tags.split(",");

        authAPI.getCurrentUser(function (err, user) {
            if (err) {
                console.log(err);
                callback(err,null);
            }
            else if (user) {
                bfUtils.http.post(window.siteConfig.endPoints.appHost + "/api/userTagging/app/" + window.appContext.currentApp.appId + "/user/assign", {
                    tags: tags,
                    accessToken: user.accessToken
                })
                    .success(function (result) {
                        callback(null, true);
                    })
                    .error(function (err) {
                            console.log(err);
                            callback(err);
                        }
                    );
            }
        });
    },
    unassignUserTags: function (tags, options , callback) {
        if(typeof(tags) == "string")
            tags = tags.split(",");

        authAPI.getCurrentUser(function (err, user) {
            if (err) {
                console.log(err);
                callback(err,null);
            }
            else if (user) {
                bfUtils.http.post(window.siteConfig.endPoints.appHost + "/api/userTagging/app/" + window.appContext.currentApp.appId + "/user/unassign", {
                    tags: tags,
                    isPrefix: options.isPrefix || false,
                    accessToken: user.accessToken,
                    removeTag: options.removeTag || false
                })
                    .success(function (result) {
                        callback(null, true);
                    })
                    .error(function (err) {
                            console.log(err);
                            callback(err, null);
                        }
                    );
            }
        });
    }

};

userTags.init();

"use strict";
/**
 * Created by Daniel on 3/30/2015.
 * only allow reads without secure api key
 * cache data here so that we dont hit the server for the same info over and over
 */


function RemoteDatastore(appId, pluginId, instanceId, liveMode, dataStoreUrl) {
    this.appId = appId;
    this.pluginId = pluginId;
    this.instanceId = instanceId;
    this.liveMode = liveMode;
    this.dataStoreUrl = dataStoreUrl;
}


RemoteDatastore.prototype = {
    createReadUrl: function (tag, id, withDynamicData) {

        var url = this.dataStoreUrl + "/plugin/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + this.liveMode + "/" + id;
        if (withDynamicData) {
            url += "?withDynamicData=true";
        }
        return url;
    }
    , createSearchUrl: function (tag) {
        return this.dataStoreUrl + "/plugin/search/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + this.liveMode + "/";
    }
    , createWriteUrl: function (tag) {
        return this.dataStoreUrl + "/plugin/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    }
    , createCloneUrl: function (tag) {
        return this.dataStoreUrl + "/app/" + this.appId + "/plugin/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/clone/";
    }
    , createSearchAndUpdateUrl: function (tag) {
        return this.dataStoreUrl + "/plugin/searchAndUpdate/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    }
    , createDeleteUrl: function (tag, id) {
        return this.dataStoreUrl + "/plugin/delete/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + id;
    }
    , createSaveUrl: function (tag) {
        return this.dataStoreUrl + "/plugin/save/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    }
    , createBulkInsertUrl: function (tag) {
        return this.dataStoreUrl + "/plugin/bulkInsert/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    }
    , createPublishUrl: function () {
        return this.dataStoreUrl + "/publish/" + this.appId;
    }
    , createServicesUrl: function () {
        return this.dataStoreUrl + "/app/" + this.appId + "/services/" + this.liveMode;
    }
    , createDeletePluginInstanceUrl: function (id) {
        return this.dataStoreUrl + "/plugin/deletePluginInstance/" + this.appId + "/" + id;
    }
    , resolveTag: function (tag) {
        if (tag == null || tag == undefined || tag == "") return 'primary';
        return tag;
    }
    , _httpGet: function (url, context, callback) {
        if (typeof(context) == 'function' && !callback) {
            callback = context;
            context = this;
        }

        if(bfUtils.http){
            bfUtils.http.get(url).success(
                function (data) {
                    callback.apply (context, [null, data]);
                }
            ).error(
                function (data, status, headers, config) {
                    var errMsg = 'datastore GET Error with URL: ' + config.url;
                    callback(errMsg);
                    console.error('datastore GET Error: '+config.url, status );
                }
            );
        }else{
            callback('datastore GET Error:bfUtils.http is undefined. Try again later.');
        }
    }
    , _httpPost: function (url, data, callback) {

        bfUtils.http.post(url, data).success(
            function (result) {
                callback(null, result);
            }
        ).error(
            function (data, status, headers, config) {
                var errMsg = 'datastore POST Error with URL: ' + config.url;
                callback(errMsg);
                console.error('datastore POST Result: ', status, config.url);
            }
        );
    }
    , _httpPut: function (url, data, callback) {
        bfUtils.http.put(url, data).success(
            function (result) {
                callback(null, result);
            }
        ).error(
            function (data, status, headers, config) {
                var errMsg = 'datastore PUT Error with URL: ' + config.url;
                callback(errMsg);
                console.error('datastore PUT Result: ', status, config.url);
            }
        );
    }
    , get:function(id, tag, data, withDynamicData, callback){
        this._httpGet(this.createReadUrl(tag, id, withDynamicData), data, callback);
        return this;
    }
    , save: function (tag, data, callback) {
        this._httpPost(this.createSaveUrl(tag), data, callback);
        return this;
    }
    , insert: function (tag, data, callback) {
        this._httpPost(this.createWriteUrl(tag), data, callback);
        return this;
    }
    , clone: function (tag, data, callback) {
        this._httpPost(this.createCloneUrl(tag), data, callback);
        return this;
    }
    , bulkInsert: function (tag, data, callback) {
        this._httpPost(this.createBulkInsertUrl(tag), data, callback);
        return this;
    }
    , update: function (tag, data, callback) {
        this._httpPut(this.createWriteUrl(tag), data, callback);
        return this;
    }
    , searchAndUpdate: function (tag, data, callback) {
        this._httpPost(this.createSearchAndUpdateUrl(tag), data, callback);
        return this;
    }
    , delete: function (tag, id, data, callback) {
        this._httpPost(this.createDeleteUrl(tag, id), data, callback);
        return this;
    }
    , search: function (tag, options, data, callback) {
        this._httpPost(this.createSearchUrl(tag), data, callback);
        return this;
    }
    , publish: function (data, callback) {
        this._httpPost(this.createPublishUrl(), data, callback);
        return this;
    }
    , getServices: function (data, callback) {
        this._httpGet(this.createServicesUrl(), data, callback);
        return this;
    }
    , deletePluginInstance: function (id, data, callback) {
        this._httpPost(this.createDeletePluginInstanceUrl(id), data, callback);
        return this;
    }
};

"use strict";
/**
 * Created by Daniel on 3/30/2015.
 * only allow reads without secure api key
 * cache data here so that we dont hit the server for the same info over and over
 */


function DatastoreAPI(appId, pluginId, instanceId, liveMode, writeKey /*, publishKey*/) {

    if(!window.appContext || !window.appContext.currentApp){
        console.warn("invalid appContext in datastore");
        //return;
        //If this not an issue after Augest First , 2016 then remove this if statement
    }

    this.enableCache = window.location.protocol.indexOf('http') < 0; // enable for non web only
    this.dataStoreUrl = window.siteConfig.endPoints.datastoreHost;

    this._featureSecurityAccess = undefined;
    if (window.appContext && window.appContext.currentApp && window.appContext.currentApp.config) {
        if (typeof window.appContext.currentApp.config.featureSecurityAccess == 'undefined') {
            if (window.appContext.currentApp.config.type == "enterprise") {
                this._featureSecurityAccess = 'enabled';
            }
        }
        else {
            this._featureSecurityAccess = window.appContext.currentApp.config.featureSecurityAccess;
        }
    }

    if (typeof(appId) == "object") {
        var config = appId;
        this.appId = config.appId;
        this.pluginId = config.pluginId;
        this.instanceId = config.instanceId;
        this.liveMode = config.liveMode;
        this.writeKey = config.writeKey || (window.appContext.currentApp ? window.appContext.currentApp.keys.datastoreKey : null);
    }
    else {
        this.appId = appId;
        this.pluginId = pluginId;
        this.instanceId = instanceId;
        this.liveMode = liveMode;
        if(writeKey)
            this.writeKey =writeKey;
        else
        if(window.appContext.currentApp && window.appContext.currentApp.keys && window.appContext.currentApp.keys.datastoreKey)
            this.writeKey =window.appContext.currentApp.keys.datastoreKey;
        else
        if(window.appContext.currentApp &&  window.appContext.currentApp.datastoreWriteKey)
            this.writeKey =window.appContext.currentApp.datastoreWriteKey;
        else
            this.writeKey=null;
    }

    if (typeof(CustomEvent) == "undefined")
        console.warn("Browser doesn't support CustomEvent");

    // check for backward compatibility with old SDK versions. overrides.js loads in SDK only.
    if(typeof RemoteDatastore == "undefined" && document.querySelector('script[src="scripts/overrides.js"]')) {
        console.error("SDK is outdated. Please update to the most recent version.");
        throw "SDK is outdated. Please update to the most recent version.";
    }

    var remoteDatastoreProvider = new RemoteDatastore(this.appId, this.pluginId, this.instanceId, this.liveMode, this.dataStoreUrl);
    if(this.enableCache && typeof OfflineDatastore != 'undefined') {
        this._provider = new OfflineDatastore(this.appId, this.pluginId, this.instanceId, this.liveMode, remoteDatastoreProvider);
    } else {
        this._provider = remoteDatastoreProvider;
    }
}


DatastoreAPI.prototype = {
    deviceOnline : function(){
        if(typeof(navigator) != "undefined" && navigator.connection && navigator.connection.type)
            return navigator.connection.type != "none";
        else
            return true;
    }
    , onUpdate: function (callback) {
    }
    , triggerOnUpdate: function (data) {
        if (this.onUpdate)this.onUpdate(data);
    }
    , onRefresh: function (callback) {
        document.addEventListener('datastoreOnRefresh', callback, false);
    }
    , triggerOnRefresh: function (data) {
        var onUpdateEvent = new CustomEvent('datastoreOnRefresh', {'detail': data});
        document.dispatchEvent(onUpdateEvent);
    }
    , onDisableRefresh: function (callback) {
        document.addEventListener('datastoreOnDisableRefresh', callback, false);
    }
    , disableRefresh: function () {
        document.dispatchEvent(new CustomEvent('datastoreOnDisableRefresh'));
    }
    , resolveTag: function (tag) {
        if (tag == null || tag == undefined || tag == "") return 'primary';
        return tag;
    }
    , get: function (obj, callback) {
        if (typeof(callback) != "function") return; // don't bother

        var self=this;

        var tag;
        var id = '';
        var withDynamicData = false;
        if (typeof(obj) == "object") {
            if (typeof(obj.tag) == "string")
                tag = obj.tag;
            else
                tag = '';
            if (typeof(obj.id) == "string")
                id = obj.id;
            else
                id = '';
            withDynamicData = obj.withDynamicData;
        }
        else if (typeof(obj) == "string")
            tag = obj;
        else if (tag == null || tag == undefined)
            tag = '';

        if (typeof(tag) != "string") tag = '';
        var requestTime = Date.now();
        this._provider.get(id,tag,{ds: this
            , obj: obj
        },withDynamicData, function (err, data) {
            //var responseTime = Date.now() - requestTime;
            //console.log('datastore: response time ' + responseTime);
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                if (data == null) {
                    callback(null, null);
                }
                else {
                    var saveTag = data.tag;
                    data.tag = tag;
                    if(withDynamicData && data && data.data && data.data._buildfire){
                        self._dynamicDataSecurityFilter(data.data._buildfire, function (err, result) {
                            data.data._buildfire = result;
                            callback(null, data);
                            data.tag = saveTag;
                        });
                    }
                    else{
                        callback(null, data);
                        data.tag = saveTag;
                    }
                }
            }
        });
        return this;
    }
    , save: function (obj, callback) {
        if (window.toast)window.toast('saving...');
        if (!this.writeKey) {
            console.error ("no write key has been provided");
            return;
        }
        var tag = obj.tag, data = obj.obj;

        if (typeof(data) == "object") {
            data = this._cleanUp(data);
            if (typeof(angular) != "undefined")
                data = angular.toJson({data: data, writeKey: this.writeKey, id: obj.id});
            else
                data = JSON.stringify({data: data, writeKey: this.writeKey, id: obj.id});
        }


        var t = this;
        this._provider.save(tag, data, function(err) {
            if (err == 404) {
                if (window.toast)window.toast('404', 'danger');
                callback(null, null);
            } else if (err) {
                if (window.toast)window.toast('error saving', 'danger');
                callback(err);
            } else {
                var result = {
                    id: obj.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    }
    , insert: function (obj, callback) {

        var tag = obj.tag, data = obj.obj, checkDuplicate = obj.checkDuplicate;

        if (typeof(data) == "object") {
            data = this._cleanUp(data);
            data = {data: data, writeKey: this.writeKey};
            if (checkDuplicate)
                data.checkDuplicate = checkDuplicate;
            data = JSON.stringify(data);
        }

        var t = this;
        this._provider.insert(tag, data, function (err, response) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                obj.id = response.id;
                var result = {
                    id: response.id,
                    data: obj.obj,
                    tag: tag
                }
                callback(null, result);
                t.triggerOnUpdate(result);

            }

        });
        return this;
    }
    , clone: function (obj, callback) {

        var tag = obj.tag, data = obj.obj, checkDuplicate = obj.checkDuplicate;

        if (typeof(data) == "object") {
            data = this._cleanUp(data);
            data = {data: data, writeKey: this.writeKey};
            if (checkDuplicate)
                data.checkDuplicate = checkDuplicate;
            data = JSON.stringify(data);
        }

        var t = this;
        this._provider.clone(tag, data, function (err, response) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                obj.id = response.id;
                var result = {
                    id: response.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    }
    , bulkInsert: function (obj, callback) {
        var tag = obj.tag, data = obj.obj;

        if (typeof(data) == "object") {
            data = this._cleanUp(data);
            data = JSON.stringify({data: data, writeKey: this.writeKey, checkDuplicate: false});
        }

        var t = this;
        this._provider.bulkInsert(tag, data, function (err, response) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                var result = {
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    }
    , update: function (args, callback) {
        if (window.toast)window.toast('saving...');
        var tag = args.tag, data = args.obj;


        if (typeof(data) == "object") {
            data = this._cleanUp(data);
            data = JSON.stringify({id: args.id, data: data, writeKey: this.writeKey});
        }

        var t = this;
        this._provider.update(tag, data, function (err, response) {
            if (err == 404) {
                if (window.toast)window.toast('404');
                callback(null, null);
            }
            else if (err) {
                if (window.toast)window.toast('error updating');
                callback(err);
            }
            else {
                //if (window.toast)window.toast('saved.');
                response.record.tag = args.tag;
                callback(null, response.record);
                t.triggerOnUpdate(response.record);
            }

        });
        return this;
    }
    , searchAndUpdate: function (args, callback) {
        if (window.toast)window.toast('saving...');
        var tag = args.tag, data = args.obj;

        if (typeof(data) == "object") {
            data = this._cleanUp(data);
            data = JSON.stringify({search: args.search, data: data, writeKey: this.writeKey});
        }

        var t = this;
        this._provider.searchAndUpdate(tag, data, function (err, response) {
            if (err == 404) {
                if (window.toast)window.toast('404');
                callback(null, null);
            }
            else if (err) {
                if (window.toast)window.toast('error updating');
                callback(err);
            }
            else {
                //if (window.toast)window.toast('saved.');
                callback(null, response);
                t.triggerOnUpdate(response);
            }
        });
        return this;
    }
    , delete: function (args, callback) {

        var tag = args.tag;

        var data = JSON.stringify({writeKey: this.writeKey});

        var t = this;
        this._provider.delete(tag, args.id, data, function (err, response) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                callback(null, response);
                t.triggerOnUpdate(args);
            }

        });
        return this;
    }
    , deletePluginInstance: function (args, callback) {
        var data = JSON.stringify({writeKey: this.writeKey});

        var t = this;
        this._provider.deletePluginInstance(args.id, data, function (err, response) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                callback(null, response);
                t.triggerOnUpdate(args);
            }

        });
        return this;
    }
    , search: function (packet, callback) {
        var self = this;
        var tag = packet.tag;
        var data = packet.obj;
        if (typeof(callback) != "function") return; // dont bother

        if (typeof(tag) != "string")
            tag = '';

        if (typeof(data) == "object")
            data = JSON.stringify(data);

        this._provider.search(tag, packet.obj, data, function (err, data) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                /*try {*/

                    if (data == null)
                        callback(null, null);
                    else if (typeof(data) == "string")
                        callback(null, bfUtils.tryParseJSON(data));
                    else {
                        if (self.pluginId === 'pluginInstances') {
                            //
                            if (typeof (userTags) != "undefined" && userTags.checkPluginAccessSettings && data.result) {
                                self._pluginInstancesSecurityFilter(data.result);
                            }
                            callback(null, data);
                        }
                        else {
                            callback(null, data);
                        }
                    }
                /*}
                catch (e) {
                    callback({data : 'cannot parse data: ' + JSON.stringify(packet) , error : JSON.stringify(e)  });
                }*/
            }

        });
        return this;
    }
    , publish: function (callback) {
        var data = JSON.stringify({publishKey: this.publishKey});
        var t = this;
        this._provider.publish(data, function (err, response) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                /*try {*/
                    callback(null, bfUtils.tryParseJSON(response));
                /*}
                catch (e) {
                    callback('cannot parse data: ' + response);
                }*/
                t.triggerOnUpdate(obj);
            }

        });
        return this;
    }
    , getServices: function (data, callback) {
        this._provider.getServices(data, function (err, response) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                callback(null, response);
            }
        });
        return this;
    }
    , _cleanUp: function (data) {
        if (data) {
            var clone = JSON.parse(JSON.stringify(data));
            this._cleanUpTree(clone);
            return clone;
        }
        else {
            return data;
        }
    }
    , _cleanUpTree: function (node) {
        for (var property in node) {
            var subNode = node[property];
            if (property == '_buildfire' && subNode) { // clean auto injected _buildfire
                delete subNode.result;
                delete subNode.err;
            }
            else {
                if (subNode !== null && typeof(subNode) == "object") {
                    this._cleanUpTree(node[property]);
                }
            }
        }
    },
    _dynamicDataSecurityFilter: function (_buildfire, callback) {
        if (typeof (userTags) != "undefined" && userTags.checkPluginAccessSettings) {
            for (var key in _buildfire) {
                if (!key)
                    continue;
                var currentInstance = _buildfire[key];
                if (currentInstance && currentInstance.result) {
                    this._pluginInstancesSecurityFilter(currentInstance.result);
                }
            }
        }
        callback(null, _buildfire);
    },
    _pluginInstancesSecurityFilter: function (pluginInstances) {
        var self = this;
        if (pluginInstances) {
            pluginInstances.forEach(function (pInstance) {
                if (pInstance && pInstance.data) {
                    pInstance.hasAccess = true;
                    if (self._featureSecurityAccess === 'enabled') {
                        userTags.checkPluginAccessSettings(pInstance.data, function (err, hasAccess) {
                            pInstance.hasAccess = hasAccess;
                        });
                    }
                }
            });
        }
    }
};

var appApiKeys = {
    _callbacksQueue: [],
    _getInProgress: false,
    get: function(callback){
        if (window.appContext) {
            if(window.appContext.currentApp.apiKeys) {
                if (callback) callback(null, window.appContext.currentApp.apiKeys);
                return window.appContext.currentApp.apiKeys;
            }

            if(callback) appApiKeys._callbacksQueue.splice(0, 0, callback);

            if (!appApiKeys._getInProgress) {
                appApiKeys._getInProgress = true;
                let _APIKeys = new window.DatastoreAPI({
                    appId: window.appContext.currentApp.appId
                    , pluginId: 'apiKeys'
                    , instanceId: 'apiKeys'
                });

                _APIKeys.get({tag: 'apiKeys'}, function (err, result) {
                    if (err) {
                        while (callback = appApiKeys._callbacksQueue.pop())
                        {
                            callback(err);
                        }
                        appApiKeys._getInProgress = false;
                        return;
                    }
                    if (result && result.data) {
                        //fetch the keys and save in memory to be ready when it needs
                        window.appContext.currentApp.apiKeys = result.data;
                    } else {
                        window.appContext.currentApp.apiKeys = {};
                    }
                    while (callback = appApiKeys._callbacksQueue.pop())
                    {
                        callback(null, window.appContext.currentApp.apiKeys);
                    }
                    appApiKeys._getInProgress = false;
                });
            }
        } else {
            if (callback) {
                callback('no appContext');
            }
        }
    }
};

"use strict";

function UserDatastoreAPI(appId, pluginId, instanceId, isAppUser, writeKey) {

    if(!window.appContext || !window.appContext.currentApp){
        console.error("invalid appCOntext in userstore");
        return;
    }

    this.enableCache = false;// don't enable, cache is not invalidated properly
    this.dataStoreUrl = window.siteConfig.endPoints.datastoreHost;

    if (typeof(appId) == "object") {
        var config = appId;
        this.appId = config.appId;
        this.pluginId = config.pluginId;
        this.instanceId = config.instanceId;
        this.isAppUser = config.type != 'control';
        if (!this.isAppUser)
            this.writeKey = config.writeKey || (window.appContext.currentApp ? window.appContext.currentApp.keys.datastoreKey : null);
        else
            this.writeKey = authAPI.getCurrentUser()? authAPI.getCurrentUser()._id:null;
       

    }
    else {
        this.appId = appId;
        this.pluginId = pluginId;
        this.instanceId = instanceId;
      
        this.isAppUser = isAppUser;
        if (!this.isAppUser)
            this.writeKey = writeKey || (window.appContext.currentApp ? window.appContext.currentApp.keys.datastoreKey : null);
        else
            this.writeKey = authAPI.getCurrentUser()? authAPI.getCurrentUser()._id:null;
    }


       if (typeof(CustomEvent) == "undefined")
        console.warn("Browser doesnt support CustomEvent");


}


UserDatastoreAPI.prototype = {
    onUpdate: function (callback) {

        //document.addEventListener('datastoreOnUpdate', callback, false);
    }
    , triggerOnUpdate: function (data) {
        if (this.onUpdate)this.onUpdate(data);
        //var onUpdateEvent = new CustomEvent('datastoreOnUpdate', {'detail': data});
        //document.dispatchEvent(onUpdateEvent);
    }
    , onRefresh: function (callback) {
        document.addEventListener('userDataOnRefresh', callback, false);
    }
    , triggerOnRefresh: function (data) {
        var onUpdateEvent = new CustomEvent('userDataOnRefresh', {'detail': data});
        document.dispatchEvent(onUpdateEvent);
    }
    , onDisableRefresh: function (callback) {
        document.addEventListener('userDatastoreOnDisableRefresh', callback, false);
    }
    , disableRefresh: function () {
        document.dispatchEvent(new CustomEvent('userDatastoreOnDisableRefresh'));
    }
    , resolveTag: function (tag) {
        if (tag == null || tag == undefined || tag == "") return 'primary';
        return tag;
    }
    , createReadUrl: function (tag, userToken, id) {
        return this.dataStoreUrl + "/user/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag)  + "/" + userToken + "/"+ id;
    }
    , createSearchUrl: function (tag) {
        return this.dataStoreUrl + "/user/search/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag)  + "/";
    }
    , createWriteUrl: function (tag,userToken) {
        return this.dataStoreUrl + "/user/insert/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken +  "/";
    }
    , createSearchAndUpdateUrl: function (tag,userToken) {
        return this.dataStoreUrl + "/user/searchAndUpdate/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken +  "/";
    }
    , createDeleteUrl: function (tag, id, userToken) {
        return this.dataStoreUrl + "/user/delete/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken + "/" + id;
    }
    , createSaveUrl: function (tag, userToken) {
        return this.dataStoreUrl + "/user/save/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken + "/";
    }
    , createBulkInsertUrl: function (tag, userToken) {
        return this.dataStoreUrl + "/user/bulkInsert/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken + "/";
    }
  
    , _httpGet: function (url, context, callback) {
        if (typeof(context) == 'function' && !callback) {
            callback = context;
            context = this;
        }
        bfUtils.http.get(url).success(
            function (data) {
                callback.apply (context, [null, data]);
            }
        ).error(
            function (err, status) {
                err = err || "http error with status: " + status;
                callback.apply(context, [err]);
                console.error('user datastore GET Error: ', url, err);
            }
        );

    }
    , _httpPost: function (url, data, callback) {

        bfUtils.http.post(url, data).success(
            function (result) {
                callback(null, result);
            }
        ).error(
            function (err, status) {
                err = err || "http error with status: " + status;
                callback(err);
                console.error('user datastore POST Result: ', url, err);
            }
        );
    }
    , _httpPut: function (url, data, callback) {
        bfUtils.http.put(url, data).success(
            function (result) {
                callback(null, result);
            }
        ).error(
            function (err, status) {
                err = err || "http error with status: " + status;
                callback(err);
                console.error('user datastore PUT Result: ', url, err);
            }
        );
    }
    , get: function (obj, callback) {
        console.log('user datastore: get ' + JSON.stringify(obj));
        if (typeof(callback) != "function") return; // don't bother

        /*
         ///create a delay
         console.warn('create artificial delay >>');
         var originalCallback=callback;;
         callback = function(err,data){ setTimeout(function(){
         console.warn('<< resume');
         originalCallback(err,data)
         },5000); };
         */
         if (this.isAppUser)
            this.writeKey = authAPI.getCurrentUser()? authAPI.getCurrentUser()._id:null;
        
        if (!this.writeKey) {
            console.error ("no write key has been provided");
            callback('no logged in user found', null);
            return;
        }
        var tag;
        var id = '';
        var withDynamicData = false;
        if (typeof(obj) == "object") {
            if (typeof(obj.tag) == "string")
                tag = obj.tag;
            else
                tag = '';
            if (typeof(obj.id) == "string")
                id = obj.id;
            else
                id = '';
        }
        else if (typeof(obj) == "string")
            tag = obj;
        else if (tag == null || tag == undefined)
            tag = '';

        if (typeof(tag) != "string") tag = '';

        //check if the dataDump record exist
        //if true : return cached record in callback ,continue with http call (without callback) ,update local cache , trigger on update
        //else : continue with http normally

        var isCallBackDone = false;
        var cachedData = null;
        //check local storage
        try {
            if (this.enableCache && typeof userDataDumpAPI !== 'undefined') {
                console.log('data cache: check for cache');
                cachedData = userDataDumpAPI.getData(this.appId, this.pluginId, this.instanceId, this.resolveTag(tag), obj.id);
                if (cachedData) {
                    console.log('data cache: found cache');
                    var result = cachedData;
                    result.tag = obj.tag;
                    result.obj = obj.obj;
                    callback(null, result);
                    isCallBackDone = true;
                }

            }
        } catch (ex) {
            debugger;
            console.error('dataDump error: ' + ex);
        }


        //var t = this;
        var requestTime = Date.now();
        this._httpGet(this.createReadUrl(tag,this.writeKey, id, withDynamicData)
            , {ds: this
                , isCallBackDone: isCallBackDone
                , obj: obj
                ,userDataDumpAPI:window.userDataDumpAPI
            }
            , function (err, data) {
                var context = this;
                var responseTime = Date.now() - requestTime;
                console.log('user datastore: response time ' + responseTime);
                if (err) {
                    if (!context.isCallBackDone) callback(err);
                }
                else if (err == 404) {
                    if (!context.isCallBackDone) callback(null, null);
                }
                else {
                    try {
                        if (data == null) {
                            if (!context.isCallBackDone) callback(null, null);
                        }
                        else {
                            if (context.ds.enableCache && typeof context.userDataDumpAPI !== 'undefined')
                                context.userDataDumpAPI.setData(context.ds.appId, context.ds.pluginId, context.ds.instanceId, context.ds.resolveTag(context.obj.tag), context.obj.id, data);

                            data.tag = context.obj.tag;
                            if (!context.isCallBackDone)
                                callback(null, data);
                            else if (cachedData && cachedData.lastUpdated != data.lastUpdated) {
                                console.log('data cache: send updated object onUpdate');
                                // needs some time to load before sending the update
                                //setTimeout(function(){context.ds.triggerOnUpdate(data);},3000);
                                context.ds.triggerOnUpdate(data)

                            }

                        }
                    }
                    catch (e) {
                        if (!isCallBackDone) callback(e);
                    }
                }

            });
        return this;
    }
    , save: function (obj, callback) {
        if (window.toast) window.toast('saving...');
        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser()? authAPI.getCurrentUser()._id:null;
         
        }
       
        if (!this.writeKey) {
            console.error ("no write key has been provided");
            if(callback) callback('no logged in user found', null);
            return;
        }
        var tag = obj.tag,
        data = obj.obj,
        userToken = obj.userToken ? obj.userToken : this.writeKey;
        
        if (typeof (data) == "object") {
            if (typeof (angular) != "undefined") {
                if (this.isAppUser)
                 data = angular.toJson({ data: data, userToken: this.writeKey, id: obj.id });
                else
                    data = angular.toJson({ data: data, writeKey: this.writeKey, id: obj.id });
        }
            else {
                if (this.isAppUser)
                    data = JSON.stringify({ data: data, userToken: this.writeKey, id: obj.id });
                else
                    data = JSON.stringify({ data: data, writeKey: this.writeKey, id: obj.id });
    }
        }


        var t = this;
        this._httpPost(this.createSaveUrl(tag, userToken), data, function (err, response) {
            if (err == 404) {
                if (window.toast)window.toast('404', 'danger');
                callback(null, null);
            }
            else if (err) {
                if (window.toast)window.toast('error saving', 'danger');
                callback(err);
            }
            else {
                //if (window.toast)window.toast('saved');
                var result = {
                    id: obj.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    }
    , insert: function (obj, callback) {
        
        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser()? authAPI.getCurrentUser()._id:null;
        }
      
        
        if (!this.writeKey) {
            console.error ("no write key has been provided");
            if(callback) callback('no logged in user found', null);
            return;
        }
        var tag = obj.tag,
        data = obj.obj,
        checkDuplicate = obj.checkDuplicate,
        userToken = obj.userToken ? obj.userToken : this.writeKey;

        if (typeof(data) == "object") {
             
            if (this.isAppUser)
                data = { data: data, userToken: this.writeKey };
            else
                data = { data: data, writeKey: this.writeKey };

            if (checkDuplicate)
                data.checkDuplicate = checkDuplicate;
            data = JSON.stringify(data);
        }

        var t = this;
        this._httpPost(this.createWriteUrl(tag, userToken), data, function (err, response) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                obj.id = response.id;
                var result = {
                    id: response.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);

            }

        });
        return this;
    }
    , bulkInsert: function (obj, callback) {
        
        
        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser()? authAPI.getCurrentUser()._id:null;
        }
        
        if (!this.writeKey) {
            console.error ("no write key has been provided");
            if(callback) callback('no logged in user found', null);
            return;
        }

        var tag = obj.tag,
        data = obj.obj,
        userToken = obj.userToken ? obj.userToken : this.writeKey;

        if (typeof(data) == "object") {
          
            if (this.isAppUser)
                data = JSON.stringify({ data: data, userToken: this.writeKey, checkDuplicate: false });
            else
                data = JSON.stringify({ data: data, writeKey: this.writeKey, checkDuplicate: false });
        }

        var t = this;
        this._httpPost(this.createBulkInsertUrl(tag, userToken), data, function (err, response) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                var result = {
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }

        });
        return this;
    }
    , update: function (args, callback) {
        if (window.toast) window.toast('saving...');
        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser()? authAPI.getCurrentUser()._id:null;
        }
        
        if (!this.writeKey) {
            console.error ("no write key has been provided");
            if(callback) callback('no logged in user found', null);
            return;
        }
        var tag = args.tag,
        data = args.obj,
        userToken = args.userToken ? args.userToken : this.writeKey;


        if (typeof(data) == "object") {
        
            if (this.isAppUser)
                data = JSON.stringify({ id: args.id, data: data, userToken: this.writeKey });
            else
                data = JSON.stringify({ id: args.id, data: data, writeKey: this.writeKey });

        }

        var t = this;
        this._httpPut(this.createWriteUrl(tag, userToken), data, function (err, response) {
            if (err == 404) {
                if (window.toast)window.toast('404');
                callback(null, null);
            }
            else if (err) {
                if (window.toast)window.toast('error updating');
                callback(err);
            }
            else {
                //if (window.toast)window.toast('saved.');
                response.record.tag = args.tag;
                callback(null, response.record);
                t.triggerOnUpdate(response.record);
            }

        });
        return this;
    }
    , searchAndUpdate: function (args, callback) {
        if (window.toast) window.toast('saving...');
        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser()? authAPI.getCurrentUser()._id:null;
        }

        if (!this.writeKey) {
            console.error ("no write key has been provided");
            if(callback) callback('no logged in user found', null);
            return;
        }
        var tag = args.tag,
        data = args.obj,
        userToken = args.userToken ? args.userToken : this.writeKey;

        if (typeof(data) == "object") {
            if (this.isAppUser)
                data = JSON.stringify({ search: args.search, data: data, userToken: this.writeKey });
            else
                data = JSON.stringify({ search: args.search, data: data, writeKey: this.writeKey });
        }

        var t = this;
        this._httpPost(this.createSearchAndUpdateUrl(tag, userToken), data, function (err, response) {
            if (err == 404) {
                if (window.toast)window.toast('404');
                callback(null, null);
            }
            else if (err) {
                if (window.toast)window.toast('error updating');
                callback(err);
            }
            else {
                //if (window.toast)window.toast('saved.');
                callback(null, response);
                t.triggerOnUpdate(response);
            }
        });
        return this;
    }
    , delete: function (args, callback) {
        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser()? authAPI.getCurrentUser()._id:null;
        }
        
        if (!this.writeKey) {
            console.error ("no write key has been provided");
            if(callback) callback('no logged in user found', null);
            return;
        }
        var data = {};
        var tag = args.tag,
        userToken = args.userToken ? args.userToken : this.writeKey;

        if (this.isAppUser)
             data = JSON.stringify({ userToken: this.writeKey });
        else
             data = JSON.stringify({writeKey: this.writeKey});

        var t = this;
        this._httpPost(this.createDeleteUrl(tag, args.id, userToken), data, function (err, response) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                callback(null, response);
                t.triggerOnUpdate(args);
            }

        });
        return this;
    }
    , search: function (packet, callback) {
        
        if (this.isAppUser)
            this.writeKey = authAPI.getCurrentUser()? authAPI.getCurrentUser()._id:null;
        
        if (!this.writeKey) {
            console.error ("no write key has been provided");
            if(callback) callback('no logged in user found', null);
            return;
        }
        var tag = packet.tag;
        var data = packet.obj;
        if (typeof(callback) != "function") return; // dont bother

        //if(typeof(data) != "object")debugger;

        if (typeof(tag) != "string")
            tag = '';
        
        if (typeof (data) == "string")
            data = JSON.parse(data);

        if (this.isAppUser)
            data.userToken = this.writeKey;
        else
            data.writeKey = this.writeKey;

        if (typeof(data) == "object")
            data = JSON.stringify(data);
       

        this._httpPost(this.createSearchUrl(tag), data, function (err, data) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                /*try {*/

                    if (data == null)
                        callback(null, null);
                    else if (typeof(data) == "string")
                        callback(null, bfUtils.tryParseJSON(data));
                    else
                        callback(null, data);
                /*}
                catch (e) {
                    callback('cannot parse data: ' + data);
                }*/
            }

        });
        return this;
    }
  
    , dataDump: function (callback) {
        if (this.isAppUser)
            this.writeKey = authAPI.getCurrentUser()? authAPI.getCurrentUser()._id:null;
        
        if (!this.writeKey) {
            console.error ("no write key has been provided");
            if(callback) callback('no logged in user found', null);
            return;
        }
        var t = this;
        this._httpget(this.createDataDumpUrl(), function (err, response) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                /*try {*/
                    callback(null, bfUtils.tryParseJSON(response));
                /*}
                catch (e) {
                    callback('cannot parse data: ' + response);
                }*/
                t.triggerOnUpdate(obj);
            }

        });
        return this;
    }
    
};

"use strict";

function PublicDatastoreAPI(appId, pluginId, instanceId) {

    if (!window.appContext || !window.appContext.currentApp) {
        console.error("invalid appCOntext in publicdata");
        return;
    }

    this.enableCache = true;// window.location.protocol.indexOf('http') < 0; // enable for non web only
    this.dataStoreUrl = window.siteConfig.endPoints.datastoreHost;

    if (typeof(appId) == "object") {
        var config = appId;
        this.appId = config.appId;
        this.pluginId = config.pluginId;
        this.instanceId = config.instanceId;

        this.writeKey = "public";
    }
    else {
        this.appId = appId;
        this.pluginId = pluginId;
        this.instanceId = instanceId;

        this.writeKey = "public";
    }

    if (typeof(CustomEvent) == "undefined")
        console.warn("Browser doesnt support CustomEvent");
}


PublicDatastoreAPI.prototype = {
    onUpdate: function (callback) {
        document.addEventListener('publicDataOnUpdate', callback, false);
    }
    , triggerOnUpdate: function (data) {
        if (this.onUpdate) this.onUpdate(data);
        var onUpdateEvent = new CustomEvent('publicDataOnUpdate', {'detail': data});
        document.dispatchEvent(onUpdateEvent);
    }
    , onRefresh: function (callback) {
        document.addEventListener('publicDataOnRefresh', callback, false);
    }
    , triggerOnRefresh: function (data) {
        var onUpdateEvent = new CustomEvent('publicDataOnRefresh', {'detail': data});
        document.dispatchEvent(onUpdateEvent);
    }
    , onDisableRefresh: function (callback) {
        document.addEventListener('publicDatastoreOnDisableRefresh', callback, false);
    }
    , disableRefresh: function () {
        document.dispatchEvent(new CustomEvent('publicDatastoreOnDisableRefresh'));
    }
    , resolveTag: function (tag) {
        if (tag == null || tag == undefined || tag == "") return 'primary';
        return tag;
    }
    , createReadUrl: function (tag, id) {
        return this.dataStoreUrl + "/user/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/" + id;
    }
    , createSearchUrl: function (tag) {
        return this.dataStoreUrl + "/user/search/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    }
    , createWriteUrl: function (tag) {
        return this.dataStoreUrl + "/user/insert/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/";
    }
    , createSearchAndUpdateUrl: function (tag) {
        return this.dataStoreUrl + "/user/searchAndUpdate/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/";
    }
    , createDeleteUrl: function (tag, id) {
        return this.dataStoreUrl + "/user/delete/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/" + id;
    }
    , createSaveUrl: function (tag) {
        return this.dataStoreUrl + "/user/save/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/";
    }
    , createBulkInsertUrl: function (tag) {
        return this.dataStoreUrl + "/user/bulkInsert/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/";
    }

    , _httpGet: function (url, context, callback) {
        if (typeof(context) == 'function' && !callback) {
            callback = context;
            context = this;
        }
        bfUtils.http.get(url).success(
            function (data) {
                callback.apply(context, [null, data]);
            }
        ).error(
            function (err) {
                callback.apply(context, [err]);
                console.error('public datastore GET Error: ', url, err);
            }
        );

    }
    , _httpPost: function (url, data, callback) {

        bfUtils.http.post(url, data).success(
            function (result) {
                callback(null, result);
            }
        ).error(
            function (err) {
                callback(err);
                console.error('public datastore POST Result: ', url, err);
            }
        );
    }
    , _httpPut: function (url, data, callback) {
        bfUtils.http.put(url, data).success(
            function (result) {
                callback(null, result);
            }
        ).error(
            function (err) {
                callback(err);
                console.error('public datastore PUT Result: ', url, err);
            }
        );
    }
    , get: function (obj, callback) {
        console.log('public datastore: get ' + JSON.stringify(obj));
        if (typeof(callback) != "function") return; // don't bother

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag;
        var id = '';
        var withDynamicData = false;
        if (typeof(obj) == "object") {
            if (typeof(obj.tag) == "string")
                tag = obj.tag;
            else
                tag = '';
            if (typeof(obj.id) == "string")
                id = obj.id;
            else
                id = '';
        }
        else if (typeof(obj) == "string")
            tag = obj;
        else if (tag == null || tag == undefined)
            tag = '';

        if (typeof(tag) != "string") tag = '';

        //check if the dataDump record exist
        //if true : return cached record in callback ,continue with http call (without callback) ,update local cache , trigger on update
        //else : continue with http normally

        var isCallBackDone = false;
        var cachedData = null;
        //check local storage
        try {
            if (this.enableCache && typeof userDataDumpAPI !== 'undefined') {
                console.log('data cache: check for cache');
                cachedData = userDataDumpAPI.getData(this.appId, this.pluginId, this.instanceId, this.resolveTag(tag), obj.id);
                if (cachedData) {
                    console.log('data cache: found cache');
                    var result = cachedData;
                    result.tag = obj.tag;
                    result.obj = obj.obj;
                    callback(null, result);
                    isCallBackDone = true;
                }
            }
        } catch (ex) {
            debugger;
            console.error('dataDump error: ' + ex);
        }

        //var t = this;
        var requestTime = Date.now();
        this._httpGet(this.createReadUrl(tag, id, withDynamicData)
            , {
                ds: this
                , isCallBackDone: isCallBackDone
                , obj: obj
                , userDataDumpAPI: window.userDataDumpAPI
            }
            , function (err, data) {
                var context = this;
                var responseTime = Date.now() - requestTime;
                console.log('public datastore: response time ' + responseTime);
                if (err) {
                    if (!context.isCallBackDone) callback(err);
                }
                else if (err == 404) {
                    if (!context.isCallBackDone) callback(null, null);
                }
                else {
                    try {
                        if (data == null) {
                            if (!context.isCallBackDone) callback(null, null);
                        }
                        else {
                            if (context.ds.enableCache && typeof context.userDataDumpAPI !== 'undefined')
                                context.userDataDumpAPI.setData(context.ds.appId, context.ds.pluginId, context.ds.instanceId, context.ds.resolveTag(context.obj.tag), context.obj.id, data);

                            data.tag = context.obj.tag;
                            if (!context.isCallBackDone)
                                callback(null, data);
                            else if (cachedData && cachedData.lastUpdated != data.lastUpdated) {
                                console.log('data cache: send updated object onUpdate');
                                // needs some time to load before sending the update
                                //setTimeout(function(){context.ds.triggerOnUpdate(data);},3000);
                                context.ds.triggerOnUpdate(data);
                            }
                        }
                    }
                    catch (e) {
                        if (!isCallBackDone) callback(e);
                    }
                }
            });
        return this;
    }
    , save: function (obj, callback) {
        if (window.toast) window.toast('saving...');

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = obj.tag, data = obj.obj;

        if (typeof (data) == "object") {
            if (typeof (angular) != "undefined") {
                data = angular.toJson({data: data, userToken: this.writeKey, id: obj.id});
            }
            else {
                data = JSON.stringify({data: data, userToken: this.writeKey, id: obj.id});
            }
        }

        var t = this;
        this._httpPost(this.createSaveUrl(tag), data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404', 'danger');
                callback(null, null);
            }
            else if (err) {
                if (window.toast) window.toast('error saving', 'danger');
                callback(err);
            }
            else {
                //if (window.toast)window.toast('saved');
                var result = {
                    id: obj.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    }
    , insert: function (obj, callback) {

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = obj.tag, data = obj.obj, checkDuplicate = obj.checkDuplicate;

        if (typeof(data) == "object") {

            data = {data: data, userToken: this.writeKey};

            if (checkDuplicate)
                data.checkDuplicate = checkDuplicate;
            data = JSON.stringify(data);
        }

        var t = this;
        this._httpPost(this.createWriteUrl(tag), data, function (err, response) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                obj.id = response.id;
                var result = {
                    id: response.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    }
    , bulkInsert: function (obj, callback) {

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }

        var tag = obj.tag, data = obj.obj;

        if (typeof(data) == "object") {
            data = JSON.stringify({data: data, userToken: this.writeKey, checkDuplicate: false});
        }

        var t = this;
        this._httpPost(this.createBulkInsertUrl(tag), data, function (err, response) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                var result = {
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    }
    , update: function (args, callback) {
        if (window.toast) window.toast('saving...');

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = args.tag, data = args.obj;

        if (typeof(data) == "object") {
            data = JSON.stringify({id: args.id, data: data, userToken: this.writeKey});
        }

        var t = this;
        this._httpPut(this.createWriteUrl(tag), data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404');
                callback(null, null);
            }
            else if (err) {
                if (window.toast) window.toast('error updating');
                callback(err);
            }
            else {
                //if (window.toast)window.toast('saved.');
                response.record.tag = args.tag;
                callback(null, response.record);
                t.triggerOnUpdate(response.record);
            }
        });
        return this;
    }
    , searchAndUpdate: function (args, callback) {
        if (window.toast) window.toast('saving...');

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = args.tag, data = args.obj;

        if (typeof(data) == "object") {
            data = JSON.stringify({search: args.search, data: data, userToken: this.writeKey});
        }

        var t = this;
        this._httpPost(this.createSearchAndUpdateUrl(tag), data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404');
                callback(null, null);
            }
            else if (err) {
                if (window.toast) window.toast('error updating');
                callback(err);
            }
            else {
                //if (window.toast)window.toast('saved.');
                callback(null, response);
                t.triggerOnUpdate(response);
            }
        });
        return this;
    }
    , delete: function (args, callback) {
        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = args.tag;
        var data = JSON.stringify({userToken: this.writeKey});

        var t = this;
        this._httpPost(this.createDeleteUrl(tag, args.id), data, function (err, response) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                callback(null, response);
                t.triggerOnUpdate(args);
            }

        });
        return this;
    }
    , search: function (packet, callback) {

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = packet.tag;
        var data = packet.obj;
        if (typeof(callback) != "function") return; // dont bother

        //if(typeof(data) != "object")debugger;

        if (typeof(tag) != "string")
            tag = '';

        if (typeof (data) == "string")
            data = JSON.parse(data);

        data.userToken = this.writeKey;

        if (typeof(data) == "object")
            data = JSON.stringify(data);

        this._httpPost(this.createSearchUrl(tag), data, function (err, data) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                /*try {*/

                if (data == null)
                    callback(null, null);
                else if (typeof(data) == "string")
                    callback(null, bfUtils.tryParseJSON(data));
                else
                    callback(null, data);
                /*}
                 catch (e) {
                 callback('cannot parse data: ' + data);
                 }*/
            }

        });
        return this;
    }

    , dataDump: function (callback) {
        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var t = this;
        this._httpget(this.createDataDumpUrl(), function (err, response) {
            if (err == 404)
                callback(null, null);
            else if (err)
                callback(err);
            else {
                /*try {*/
                callback(null, bfUtils.tryParseJSON(response));
                /*}
                 catch (e) {
                 callback('cannot parse data: ' + response);
                 }*/
                t.triggerOnUpdate(obj);
            }

        });
        return this;
    }
};
'use strict';

function AppDatastoreAPI(appId) {
	if (!window.appContext || !window.appContext.currentApp) {
		console.error('invalid appCOntext in publicdata');
		return;
	}

	this.enableCache = true; // window.location.protocol.indexOf('http') < 0; // enable for non web only
	this.dataStoreUrl = window.siteConfig.endPoints.datastoreHost;

	if (typeof appId == 'object') {
		var config = appId;
		this.appId = config.appId;
		this.pluginId = 'public';
		this.instanceId = 'public';

		this.writeKey = 'public';
	} else {
		this.appId = appId;
		this.pluginId = 'public';
		this.instanceId = 'public';

		this.writeKey = 'public';
	}

	if (typeof CustomEvent == 'undefined') console.warn('Browser doesnt support CustomEvent');
}

AppDatastoreAPI.prototype = {
	onUpdate: function(callback) {
		document.addEventListener('appDataOnUpdate', callback, false);
	},
	triggerOnUpdate: function(data) {
		if (this.onUpdate) this.onUpdate(data);
		var onUpdateEvent = new CustomEvent('appDataOnUpdate', { detail: data });
		document.dispatchEvent(onUpdateEvent);
	},
	onRefresh: function(callback) {
		document.addEventListener('appDataOnRefresh', callback, false);
	},
	triggerOnRefresh: function(data) {
		var onUpdateEvent = new CustomEvent('appDataOnRefresh', { detail: data });
		document.dispatchEvent(onUpdateEvent);
	},
	onDisableRefresh: function(callback) {
		document.addEventListener('appDatastoreOnDisableRefresh', callback, false);
	},
	disableRefresh: function() {
		document.dispatchEvent(new CustomEvent('appDatastoreOnDisableRefresh'));
	},
	resolveTag: function(tag) {
		if (tag == null || tag == undefined || tag == '') return 'primary';
		return tag;
	},
	createReadUrl: function(tag, id) {
		return this.dataStoreUrl + '/user/' + this.appId + '/' + this.pluginId + '/' + this.instanceId + '/' + this.resolveTag(tag) + '/public/' + id;
	},
	createSearchUrl: function(tag) {
		return this.dataStoreUrl + '/user/search/' + this.appId + '/' + this.pluginId + '/' + this.instanceId + '/' + this.resolveTag(tag) + '/';
	},
	createWriteUrl: function(tag) {
		return this.dataStoreUrl + '/user/insert/' + this.appId + '/' + this.pluginId + '/' + this.instanceId + '/' + this.resolveTag(tag) + '/public/';
	},
	createSearchAndUpdateUrl: function(tag) {
		return this.dataStoreUrl + '/user/searchAndUpdate/' + this.appId + '/' + this.pluginId + '/' + this.instanceId + '/' + this.resolveTag(tag) + '/public/';
	},
	createDeleteUrl: function(tag, id) {
		return this.dataStoreUrl + '/user/delete/' + this.appId + '/' + this.pluginId + '/' + this.instanceId + '/' + this.resolveTag(tag) + '/public/' + id;
	},
	createSaveUrl: function(tag) {
		return this.dataStoreUrl + '/user/save/' + this.appId + '/' + this.pluginId + '/' + this.instanceId + '/' + this.resolveTag(tag) + '/public/';
	},
	createBulkInsertUrl: function(tag) {
		return this.dataStoreUrl + '/user/bulkInsert/' + this.appId + '/' + this.pluginId + '/' + this.instanceId + '/' + this.resolveTag(tag) + '/public/';
	},

	_httpGet: function(url, context, callback) {
		if (typeof context == 'function' && !callback) {
			callback = context;
			context = this;
		}
		bfUtils.http
			.get(url)
			.success(function(data) {
				callback.apply(context, [null, data]);
			})
			.error(function(err) {
				callback.apply(context, [err]);
				console.error('appDatastore GET Error: ', url, err);
			});
	},
	_httpPost: function(url, data, callback) {
		bfUtils.http
			.post(url, data)
			.success(function(result) {
				callback(null, result);
			})
			.error(function(err) {
				callback(err);
				console.error('appDatastore POST Result: ', url, err);
			});
	},
	_httpPut: function(url, data, callback) {
		bfUtils.http
			.put(url, data)
			.success(function(result) {
				callback(null, result);
			})
			.error(function(err) {
				callback(err);
				console.error('appDatastore PUT Result: ', url, err);
			});
	},
	get: function(obj, callback) {
		console.log('appDatastore: get ' + JSON.stringify(obj));
		if (typeof callback != 'function') return; // don't bother

		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}
		var tag;
		var id = '';
		var withDynamicData = false;
		if (typeof obj == 'object') {
			if (typeof obj.tag == 'string') tag = obj.tag;
			else tag = '';
			if (typeof obj.id == 'string') id = obj.id;
			else id = '';
		} else if (typeof obj == 'string') tag = obj;

		if (typeof tag != 'string' || !tag) {
			return callback(new Error('tag is required for appData'), null);
		}

		//check if the dataDump record exist
		//if true : return cached record in callback ,continue with http call (without callback) ,update local cache , trigger on update
		//else : continue with http normally

		var isCallBackDone = false;
		var cachedData = null;
		//check local storage
		try {
			if (this.enableCache && typeof userDataDumpAPI !== 'undefined') {
				console.log('data cache: check for cache');
				cachedData = userDataDumpAPI.getData(this.appId, this.pluginId, this.instanceId, this.resolveTag(tag), obj.id);
				if (cachedData) {
					console.log('data cache: found cache');
					var result = cachedData;
					result.tag = obj.tag;
					result.obj = obj.obj;
					callback(null, result);
					isCallBackDone = true;
				}
			}
		} catch (ex) {
			debugger;
			console.error('dataDump error: ' + ex);
		}

		var requestTime = Date.now();
		this._httpGet(
			this.createReadUrl(tag, id, withDynamicData),
			{
				ds: this,
				isCallBackDone: isCallBackDone,
				obj: obj,
				userDataDumpAPI: window.userDataDumpAPI
			},
			function(err, data) {
				var context = this;
				var responseTime = Date.now() - requestTime;
				console.log('appDatastore: response time ' + responseTime);
				if (err) {
					if (!context.isCallBackDone) callback(err);
				} else if (err == 404) {
					if (!context.isCallBackDone) callback(null, null);
				} else {
					try {
						if (data == null) {
							if (!context.isCallBackDone) callback(null, null);
						} else {
							if (context.ds.enableCache && typeof context.userDataDumpAPI !== 'undefined') context.userDataDumpAPI.setData(context.ds.appId, context.ds.pluginId, context.ds.instanceId, context.ds.resolveTag(context.obj.tag), context.obj.id, data);

							data.tag = context.obj.tag;
							if (!context.isCallBackDone) callback(null, data);
							else if (cachedData && cachedData.lastUpdated != data.lastUpdated) {
								console.log('data cache: send updated object onUpdate');
								context.ds.triggerOnUpdate(data);
							}
						}
					} catch (e) {
						if (!isCallBackDone) callback(e);
					}
				}
			}
		);
		return this;
	},
	save: function(obj, callback) {
		if (window.toast) window.toast('saving...');

		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}
		var tag = obj.tag,
			data = obj.obj;

		if (typeof tag != 'string' || !tag) {
			return callback(new Error('tag is required for appData'), null);
		}

		if (typeof data == 'object') {
			if (typeof angular != 'undefined') {
				data = angular.toJson({ data: data, userToken: this.writeKey, id: obj.id });
			} else {
				data = JSON.stringify({ data: data, userToken: this.writeKey, id: obj.id });
			}
		}

		var t = this;
		this._httpPost(this.createSaveUrl(tag), data, function(err, response) {
			if (err == 404) {
				if (window.toast) window.toast('404', 'danger');
				callback(null, null);
			} else if (err) {
				if (window.toast) window.toast('error saving', 'danger');
				callback(err);
			} else {
				var result = {
					id: obj.id,
					data: obj.obj,
					tag: tag
				};
				callback(null, result);
				t.triggerOnUpdate(result);
			}
		});
		return this;
	},
	insert: function(obj, callback) {
		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}
		var tag = obj.tag,
			data = obj.obj,
			checkDuplicate = obj.checkDuplicate;

		if (typeof tag != 'string' || !tag) {
			return callback(new Error('tag is required for appData'), null);
		}

		if (typeof data == 'object') {
			data = { data: data, userToken: this.writeKey };

			if (checkDuplicate) data.checkDuplicate = checkDuplicate;
			data = JSON.stringify(data);
		}

		var t = this;
		this._httpPost(this.createWriteUrl(tag), data, function(err, response) {
			if (err == 404) callback(null, null);
			else if (err) callback(err);
			else {
				obj.id = response.id;
				var result = {
					id: response.id,
					data: obj.obj,
					tag: tag
				};
				callback(null, result);
				t.triggerOnUpdate(result);
			}
		});
		return this;
	},
	bulkInsert: function(obj, callback) {
		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}

		var tag = obj.tag,
			data = obj.obj;

		if (typeof tag != 'string' || !tag) {
			return callback(new Error('tag is required for appData'), null);
		}

		if (typeof data == 'object') {
			data = JSON.stringify({ data: data, userToken: this.writeKey, checkDuplicate: false });
		}

		var t = this;
		this._httpPost(this.createBulkInsertUrl(tag), data, function(err, response) {
			if (err == 404) callback(null, null);
			else if (err) callback(err);
			else {
				var result = {
					data: obj.obj,
					tag: tag
				};
				callback(null, result);
				t.triggerOnUpdate(result);
			}
		});
		return this;
	},
	update: function(args, callback) {
		if (window.toast) window.toast('saving...');

		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}
		var tag = args.tag,
			data = args.obj;

		if (typeof tag != 'string' || !tag) {
			return callback(new Error('tag is required for appData'), null);
		}

		if (typeof data == 'object') {
			data = JSON.stringify({ id: args.id, data: data, userToken: this.writeKey });
		}

		var t = this;
		this._httpPut(this.createWriteUrl(tag), data, function(err, response) {
			if (err == 404) {
				if (window.toast) window.toast('404');
				callback(null, null);
			} else if (err) {
				if (window.toast) window.toast('error updating');
				callback(err);
			} else {
				response.record.tag = args.tag;
				callback(null, response.record);
				t.triggerOnUpdate(response.record);
			}
		});
		return this;
	},
	searchAndUpdate: function(args, callback) {
		if (window.toast) window.toast('saving...');

		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}
		var tag = args.tag,
			data = args.obj;

		if (typeof tag != 'string' || !tag) {
			return callback(new Error('tag is required for appData'), null);
		}

		if (typeof data == 'object') {
			data = JSON.stringify({ search: args.search, data: data, userToken: this.writeKey });
		}

		var t = this;
		this._httpPost(this.createSearchAndUpdateUrl(tag), data, function(err, response) {
			if (err == 404) {
				if (window.toast) window.toast('404');
				callback(null, null);
			} else if (err) {
				if (window.toast) window.toast('error updating');
				callback(err);
			} else {
				callback(null, response);
				t.triggerOnUpdate(response);
			}
		});
		return this;
	},
	delete: function(args, callback) {
		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}
		var tag = args.tag;
		var data = JSON.stringify({ userToken: this.writeKey });

		if (typeof tag != 'string' || !tag) {
			return callback(new Error('tag is required for appData'), null);
		}

		var t = this;
		this._httpPost(this.createDeleteUrl(tag, args.id), data, function(err, response) {
			if (err == 404) callback(null, null);
			else if (err) callback(err);
			else {
				callback(null, response);
				t.triggerOnUpdate(args);
			}
		});
		return this;
	},
	search: function(packet, callback) {
		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}
		var tag = packet.tag;
		var data = packet.obj;
		if (typeof callback != 'function') return; // dont bother

		if (typeof tag != 'string' || !tag) {
			return callback(new Error('tag is required for appData'), null);
		}

		if (typeof data == 'string') data = JSON.parse(data);

		data.userToken = this.writeKey;

		if (typeof data == 'object') data = JSON.stringify(data);

		this._httpPost(this.createSearchUrl(tag), data, function(err, data) {
			if (err == 404) callback(null, null);
			else if (err) callback(err);
			else {
				/*try {*/

				if (data == null) callback(null, null);
				else if (typeof data == 'string') callback(null, bfUtils.tryParseJSON(data));
				else callback(null, data);
				/*}
                 catch (e) {
                 callback('cannot parse data: ' + data);
                 }*/
			}
		});
		return this;
	},

	dataDump: function(callback) {
		if (!this.writeKey) {
			console.error('no write key has been provided');
			return;
		}
		var t = this;
		this._httpget(this.createDataDumpUrl(), function(err, response) {
			if (err == 404) callback(null, null);
			else if (err) callback(err);
			else {
				/*try {*/
				callback(null, bfUtils.tryParseJSON(response));
				/*}
                 catch (e) {
                 callback('cannot parse data: ' + response);
                 }*/
				t.triggerOnUpdate(obj);
			}
		});
		return this;
	}
};

"use strict";

/**
 * Created by Daniel on 3/30/2015.
 * only allow reads without secure api key
 * cache data here so that we dont hit the server for the same info over and over
 */

function AnalyticsAPI(appId, pluginId, instanceId, liveMode, developerId) {
    this.analyticsHostUrl = siteConfig.endPoints.analyticsHost;
    if (typeof (appId) == "object") {
        var config = appId;
        this.appId = config.appId;
        this.pluginId = config.pluginId;
        this.instanceId = config.instanceId;
        this.liveMode = config.liveMode;
        this.developerId = config.developerId;
    } else {
        this.appId = appId;
        this.pluginId = pluginId;
        this.instanceId = instanceId;
        this.liveMode = liveMode;
        this.developerId = developerId;
    }
    this.source = window.siteConfig && window.siteConfig.scope === "app" ? "app" : "web";

    this.secondLevelEmailVerificationEnabled = false;
    if (window.whitelabelContext && window.whitelabelContext.whitelabelId) {
        this.whitelabelId = window.whitelabelContext.whitelabelId;
        if (window.whitelabelContext.selfProvSettings)
            this.secondLevelEmailVerificationEnabled = window.whitelabelContext.selfProvSettings.secondLevelEmailVerificationEnabled;
    }

    this._user = this._getUser();

    //trackInstall in app and in pwa
    if (window.appContext && window.appContext.liveMode && this.appId) {
        this._trackInstall();
    }
}

AnalyticsAPI.prototype = {
    _getIpInfo: function (callback) {
        var _this = this;

        function _daysDiff(date1, date2) {
            //Get 1 day in milliseconds
            var one_day = 1000 * 60 * 60 * 24;

            // Convert both dates to milliseconds
            var date1_ms = date1.getTime();
            var date2_ms = date2.getTime();

            // Calculate the difference in milliseconds
            var difference_ms = Math.abs(date2_ms - date1_ms);

            // Convert back to days and return
            return Math.round(difference_ms / one_day);
        }

        function getNewIPInfo() {
            var request = new XMLHttpRequest();
            request.open('GET', window.siteConfig.endPoints.crmHost + '/ipinfo', true);
            request.onreadystatechange = function () {
                if (request.readyState == 4) {
                    if (request.status >= 200 && request.status < 400) {
                        if (request.responseText) {
                            var data = {};
                            try {
                                data = JSON.parse(request.responseText);
                            } catch (e) {
                                data = {};
                            }
                        }
                        saveGeoLocation(data, true);
                    }
                    AnalyticsAPI.IPInfoCalled = false;
                }
            };
            request.send(null);
        }

        function saveGeoLocation(data, isNewData) {
            if (isNewData) {
                var _localData = {
                    data: data,
                    lastSyncDate: new Date()
                };
                localStorage.setItem("analyticsUserIpInfo", JSON.stringify(_localData));
            }
        }

        var analyticsUserIpInfo = localStorage.getItem('analyticsUserIpInfo');
        if (analyticsUserIpInfo) {
            try {
                analyticsUserIpInfo = JSON.parse(analyticsUserIpInfo);
            } catch (err) {
                analyticsUserIpInfo = null;
            }

            var _today = new Date();
            var _lastSyncDate = (analyticsUserIpInfo && analyticsUserIpInfo.lastSyncDate) ? new Date(analyticsUserIpInfo.lastSyncDate) : new Date();
            if (_daysDiff(_lastSyncDate, _today) <= 30 && analyticsUserIpInfo && analyticsUserIpInfo.data) {
                if (callback) {
                    callback(analyticsUserIpInfo.data);
                }
            } else {
                if (callback) {
                    callback(analyticsUserIpInfo ? analyticsUserIpInfo.data : null);
                }
                if (!AnalyticsAPI.IPInfoCalled) {
                    AnalyticsAPI.IPInfoCalled = true;
                    getNewIPInfo();
                }
            }
        } else {
            if (callback) {
                callback();
            }
            if (!AnalyticsAPI.IPInfoCalled) {
                AnalyticsAPI.IPInfoCalled = true;
                getNewIPInfo();
            }
        }
    },
    _updateMetadata: function (metadata) {
        var _loggedUser = null;
        var _userObject = localStorage.user || localStorage.AUTH_CURRENT_USER;
        if (_userObject) {
            try {
                _userObject = JSON.parse(_userObject);
                if (localStorage.user) {
                    _loggedUser = {
                        userId: _userObject.userToken,
                        username: _userObject.username,
                        email: _userObject.email || _userObject.username,
                        displayName: _userObject.displayName,
                        firstName: _userObject.firstName,
                        lastName: _userObject.lastName
                    };
                } else {
                    _loggedUser = {
                        userId: _userObject._id,
                        username: _userObject.username,
                        email: _userObject.email || _userObject.username,
                        displayName: _userObject.displayName,
                        firstName: _userObject.firstName,
                        lastName: _userObject.lastName
                    };
                }
            } catch (e) {
                console.warn("could not load analytics user");
                _loggedUser = null;
            }
        }
        metadata.user = _loggedUser;
        if (typeof (push) != "undefined" && push.deviceId != null) {
            metadata.deviceId = push.deviceId;
        }
    },
    _getUser: function () {
        if (localStorage.user) {
            try {
                var loggedInUser = JSON.parse(localStorage.user);
                if (loggedInUser) {
                    return {
                        userId: loggedInUser.username,
                        isValidEmail: (this.secondLevelEmailVerificationEnabled ? loggedInUser.isValidEmail : 1)
                    };
                }
            } catch (e) {
                console.warn("could not load analytics user");
                return this._getAnonymousUser();
            }
        } else if (localStorage.AUTH_CURRENT_USER) {
            try {
                var loggedInUser = JSON.parse(localStorage.AUTH_CURRENT_USER);
                if (loggedInUser) {
                    return {userId: loggedInUser.username};
                } else if (typeof (push) != "undefined" && push.deviceId != null) {
                    return {userId: push.deviceId};
                } else
                    return this._getAnonymousUser();
            } catch (e) {
                console.warn("could not load analytics user");
                if (typeof (push) != "undefined" && push.deviceId != null) {
                    return {userId: push.deviceId};
                } else {
                    return this._getAnonymousUser();
                }
            }
        } else if (typeof (push) != "undefined" && push.deviceId != null) {
            return {userId: push.deviceId};
        } else {
            return this._getAnonymousUser();
        }
    },
    _getAnonymousUser: function () {
        var localAnalyticsUser = localStorage.getItem('analyticsUser');
        var user;
        if (localAnalyticsUser) {
            try {
                user = JSON.parse(localAnalyticsUser);
            } catch (err) {
                console.log(err);
            }
        }
        if (!user) {
            var segmentClientId = this._getCookie("ajs_anonymous_id");
            if (segmentClientId) {
                user = {anonymousId: segmentClientId.replace('%22', '').replace('%22', '')}; // remove quotes embedded in id
            } else {
                var c = 1;
                var cuniq = function () {
                    var d = new Date(),
                        m = d.getMilliseconds() + "",
                        u = ++d + m + (++c === 10000 ? (c = 1) : c);

                    return u;
                };
                user = {anonymousId: cuniq()};
                try {
                    localStorage.setItem('analyticsUser', JSON.stringify(user));
                } catch (err) {
                    console.log(err);
                }
            }
        }
        return user;
    },
    _getBrowserInfo: function () {
        var browserInfo = {
            path: document.location.pathname,
            referrer: document.referrer,
            url: document.location.href,
            title: document.title,
            platform: window.device && window.device.platform ? window.device.platform.toLowerCase() : ''
        };
        return browserInfo;
    },
    _getCookie: function (cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') c = c.substring(1);
            if (c.indexOf(name) == 0) return c.substring(name.length, c.length);
        }
        return "";
    },
    _trackInstall: function () {
        var installTrackedItem = localStorage.getItem('INSTALL_TRACKED');
        if (!installTrackedItem) {
            this.trackAction('app/installed', {appId: this.appId});
            localStorage.setItem('INSTALL_TRACKED', 'true');
        }
    },
    trackAction: function (actionName, properties, callback) {
        var _this = this;
        if (properties) {
            var originalProperties = this._getBrowserInfo();
            for (var originalPropertyName in originalProperties) {
                properties[originalPropertyName] = originalProperties[originalPropertyName]; // keep original properties
            }
        }
        var properties = properties || this._getBrowserInfo();
        properties.source = this.source;
        this._updateMetadata(properties);
        if (this.analyticsHostUrl && actionName) {
            var forceSync = properties ? properties.forceSync : false;
            if (properties) {
                delete properties.forceSync;
            }
            this._getIpInfo(function (userIpInfo) {
                if (userIpInfo && userIpInfo.country) {
                    properties.ipInfo = userIpInfo;
                }
                _this._httpPost(_this.analyticsHostUrl + "/event", {
                    type: 'action',
                    value: actionName,
                    metadata: properties,
                    context: {
                        whitelabelId: _this.whitelabelId,
                        appId: _this.appId,
                        pluginId: _this.pluginId,
                        instanceId: _this.instanceId,
                        liveMode: _this.liveMode,
                        developerId: _this.developerId ? _this.developerId : undefined
                    },
                    user: _this._user
                }, !forceSync, function (err, response) {
                    if (callback) {
                        callback();
                    }
                });
            });
        }
        return this;
    },
    trackView: function (viewName, properties, callback) {
        var _this = this;
        if (properties) {
            var originalProperties = this._getBrowserInfo();
            for (var originalPropertyName in originalProperties) {
                properties[originalPropertyName] = originalProperties[originalPropertyName]; // keep original properties
            }
        }
        var properties = properties || this._getBrowserInfo();
        properties.source = this.source;
        this._updateMetadata(properties);
        if (this.analyticsHostUrl && viewName) {
            var ga = this._getCookie('_ga');
            if (ga) {
                var gaContext;
                // send GA on view events only
                gaContext = {};
                gaContext.clientId = ga.substr(6); // remove GAX.X. part from the universal id
            }

            this._getIpInfo(function (userIpInfo) {
                if (userIpInfo) {
                    properties.ipInfo = userIpInfo;
                }
                _this._httpPost(_this.analyticsHostUrl + "/event", {
                    type: 'view',
                    value: viewName,
                    metadata: properties,
                    context: {
                        whitelabelId: _this.whitelabelId,
                        appId: _this.appId,
                        pluginId: _this.pluginId,
                        instanceId: _this.instanceId,
                        liveMode: _this.liveMode,
                        developerId: _this.developerId ? _this.developerId : undefined
                    },
                    segmentContext: {
                        'Google Analytics': gaContext
                    },
                    user: _this._user
                }, true, function (err, response) {
                    if (callback) {
                        callback();
                    }
                });
            });
        }
        return this;
    },
    registerPluginEvent: function (event, callback) {
        if (window.siteConfig.scope != 'cp') {
            if (callback)
                callback("This method works only on Control Side", null);
            return;
        }
        if (!event) {
            if (callback)
                callback("invalid params", null);
            return;
        }
        if (!event.data)
            event.data = {};
        if (!event.options)
            event.options = {};

        var data = event.data;
        if (!data.key) {
            if (callback)
                callback("Missing event key", null);
            return;
        }

        if (!data.title) {
            if (callback)
                callback("Missing event title", null);
            return;
        }

        data._titleLowerCase = data.title.toLowerCase();

        var _noAccesskey = this.instanceId + "_pluginEvents";
        var datastore = new DatastoreAPI(this.appId, this.pluginId, _noAccesskey, this.liveMode);

        datastore.searchAndUpdate({
            tag: "events",
            obj: {$set: data},
            search: {
                key: data.key
            }
        }, function (err, result) {
            if (err == null && result && result.nModified == 0) {
                //no event found, then add
                datastore.insert({
                    tag: "events",
                    obj: data,
                    checkDuplicate: false
                }, function (err, result) {
                    //dispatch new register event
                    var onRegisterPluginEvent = new CustomEvent('pluginAnalyticsRegisterEvent', {
                        detail: {
                            data: event.data,
                            options: event.options
                        }
                    });
                    document.dispatchEvent(onRegisterPluginEvent);
                    //#

                    if (callback)
                        callback(err, result);
                });
            } else {
                if (callback)
                    callback(err, result);
            }
        });
    },
    unregisterPluginEvent: function (event, callback) {
        if (!event || !event.key) {
            if (callback)
                callback("Missing event key", null);
            return;
        }

        var _noAccesskey = this.instanceId + "_pluginEvents";
        var datastore = new DatastoreAPI(this.appId, this.pluginId, _noAccesskey, this.liveMode);

        datastore.search({
            tag: "events",
            obj: {filter: {"$json.key": event.key}}
        }, function (err, events) {
            if (!err && events && events.length > 0) {
                for (var i = 0; i < events.length; i++) {
                    datastore.delete({tag: "events", id: events[i].id}, function (err, data) {
                        if (callback)
                            callback(err, data);
                    });
                }
            } else {
                if (callback)
                    callback(err, events);
            }
        });
    },
    getPluginEvents: function (options, callback) {
        var _noAccesskey = this.instanceId + "_pluginEvents";
        var datastore = new DatastoreAPI(this.appId, this.pluginId, _noAccesskey, this.liveMode);
        if (!options) {
            options = {};
        }

        options.skip = options.skip || 0;
        options.limit = options.limit || 50;

        datastore.search({
            tag: "events",
            obj: options
        }, function (err, data) {
            if (callback)
                callback(err, data);
        });
    },
    setUsername: function (username) {
        this._user.userId = username;
        if (this._user.anonymousId) {
            this._user.updateIdentity = true; // next request to bridge anonymousId with userId
        }
    },
    setUserProperties: function (properties) {
        this._user.properties = properties;
        this._user.updateIdentity = true;  // next request to update user properties
    },
    _httpPost: function (url, data, isAsync, callback) {
        if (window.__$haultEvents) return;
        var xhr = new XMLHttpRequest();
        xhr.open('POST', url, isAsync);
        xhr.setRequestHeader('Content-type', 'application/JSON');
        var t = this;

        //fix nested userId issue
        function _getLastUserIdObject(user) {
            if (user && typeof user.userId == "object") {
                return _getLastUserIdObject(user.userId);
            } else {
                return user;
            }
        }

        if (data.user && data.user.userId && data.user.userId.userId) {
            data.user = _getLastUserIdObject(data.user);
            //override local storage
            localStorage.setItem('analyticsUser', JSON.stringify(data.user));
        }
        //#
        xhr.onreadystatechange = function () {//Call a function when the state changes.
            if (xhr.readyState == 4) {
                if (xhr.status >= 200 && xhr.status < 400) {
                    if (t._user && t._user.userId && t._user.userId.userId) {
                        t._user = _getLastUserIdObject(t._user);
                    }

                    if (t._user.updateIdentity) {
                        delete t._user.updateIdentity;
                        delete t._user.properties;
                        delete t._user.anonymousId;
                    }
                    localStorage.setItem('analyticsUser', JSON.stringify(t._user));
                    callback(null, xhr.responseText);
                } else if (xhr.status == 0)
                    window.__$haultEvents = true; //if analytics server is down then stop trying
                else
                    callback(xhr.status);
            }
        };
        var dataString = null;
        try {
            dataString = JSON.stringify(data);
        } catch (err) {
            console.error('error stringifying analytics data', data.context, data.type + ":" + data.value, data.metadata, data, err);
        }
        if (dataString) {
            try {
                xhr.send(dataString);
            } catch (err) {
                if (err.code) {
                    console.error('error sending analytics', err, data, data.context, data.type + ":" + data.value, data.metadata, dataString, err);
                }
            }
        }
    }
};
"use strict";
/**
 * Created by Daniel on 3/30/2015.
 */
function AppearanceAPI (pluginAPI){
    this.pluginAPI=pluginAPI;
}

AppearanceAPI.prototype = {
    getCSSFiles: function (data,callback) {
        callback(null,['https://bootswatch.com/cerulean/bootstrap.css']);
        return this;
    }
    ,autosizeContainer: function(data,callback){
        //debugger;
        this.autosizeContainerHandler(data.height);
        callback(null,null);
    }
    ,autosizeContainerHandler: function(){}
    ,setHeaderVisibility:function(value){
        var e = document.getElementById('pluginControlHeader');
        var tabs = document.getElementById('pluginControlHeaderTabs');
        if(e){
            if(value)
                e.classList.remove('hidden');
            else
                e.classList.add('hidden');
        }
        if(tabs){
            if(value)
                tabs.classList.remove('hidden');
            else
                tabs.classList.add('hidden');
        }

    }
    , beforeUpdate: function (callback) {
        document.addEventListener('appearanceBeforeUpdate', callback, false);
    }
    , triggerBeforeUpdate: function (data) {
        var beforeUpdateEvent = new CustomEvent('appearanceBeforeUpdate');
        document.dispatchEvent(beforeUpdateEvent);
    }
    , onUpdate: function (callback) {
        document.addEventListener('appearanceOnUpdate', callback, false);
    }
    , triggerOnUpdate: function (data) {
        var onUpdateEvent = new CustomEvent('appearanceOnUpdate');
        document.dispatchEvent(onUpdateEvent);
    }
    , applyToScope: function (element, property, value) {
        let scope = undefined;
        scope = angular.element(element).scope();
        scope[property] = value;
        if (!scope.$$phase) {
            scope.$apply();
        }
    }, getFooterMenu: function (data, callback) {
        if (typeof(data) == 'function') {
			callback = data;
		}
        var footerMenu = localStorage.getItem('footerMenu');
        var result = {};
        if (footerMenu) {
            result = JSON.parse(footerMenu);
        }
        callback(null, result);
    }
    , titlebar: {
        show: function() {
            AppearanceAPI.prototype.titlebar.toggleVisibility(true);
        },
        hide: function() {
            AppearanceAPI.prototype.titlebar.toggleVisibility(false);
        },
        toggleVisibility: function(visible) {
            var pluginIFrame = document.getElementsByClassName('pluginFrame');
            let isLauncher = pluginIFrame.length ? false : true;

            if (isLauncher) {
                let launcherPlugin = document.getElementById('launcherPlugin');
                AppearanceAPI.prototype.applyToScope(launcherPlugin, "disableAutomaticNavigationBar", true);
                AppearanceAPI.prototype.applyToScope(launcherPlugin, "showNavigationBar", visible);     
            } else {
                for (let i = 0; i < pluginIFrame.length; i++) {
                    AppearanceAPI.prototype.applyToScope(pluginIFrame[i], "disableAutomaticNavigationBar", true);
                    AppearanceAPI.prototype.applyToScope(pluginIFrame[i], "showNavigationBar", visible);
                }
            }
        }
    },
    ready: function() {
        var pluginIFrame = document.getElementsByClassName('pluginFrame');
        let isLauncher = pluginIFrame.length ? false : true;

        if (isLauncher) {
            let launcherPlugin = document.getElementById('launcherPlugin');
            AppearanceAPI.prototype.applyToScope(launcherPlugin, "readyToShow", true);
        } else {
            for (let i = 0; i < pluginIFrame.length; i++) {
                AppearanceAPI.prototype.applyToScope(pluginIFrame[i], "readyToShow", true);
            }
        }
        if (window.spinner) {
            window.spinner.hide();
        }
    }
};

/**
 * Created by Daniel on 8/25/2015.
 */

function Track(title, url, image, album, artist) {
    this.title = title;
    this.url = url;
    this.image = image;
    this.album = album;
    this.artist = artist;
    this.startAt = 0;
    this.lastPosition = 0;
}

var audioPlayer = {
    _audio : null,
    _allowPlay: true,
    _interval: {
        time: 5000,
        id: null
    }
    , get audio() {
        if(this._audio == null) {
            if(typeof(Audio) != "undefined")//Fix phantomJs when calling the screenshot API , The audio object will be undefined
                this._audio = new Audio();
            else
                this._audio = {};
        }

        return  this._audio ;
    }
    , _currentTrack: null
    , settings: {
        autoPlayNext: false
        , loopPlaylist: false
        , autoJumpToLastPosition: false
        , shufflePlaylist: false
        , volume: 1
    }
    , getSettings: function (d, callback) {
        callback(null, this.settings);
    }
    , setSettings: function (settings) {
        console.log('setSettings called');

        if(!settings)return;
        if(this.audio && this.settings)
            this.audio.volume = this.settings.volume;
        angular.extend(this.settings, settings);
        this.save();
    }
    , resetSettingsToDefault: function(){
        audioPlayer.settings={
            autoPlayNext: false
            , loopPlaylist: false
            , autoJumpToLastPosition: false
            , shufflePlaylist: false
            , volume: 1
        };
    }
    , isStream: function(){
        //Streams have an infinite time
        return !isFinite(audioPlayer.audio.duration)
    }
    , isAndroid: function(){
        var isAndroid = false;

        if(window.device && window.device.platform  && window.device.platform.toLowerCase() === "android"){
            isAndroid = true;
        }

        return isAndroid;
    }

    , retryAllowed: function(){
        var allowRetry = true;

        //Stalled seems to be called even when audio is working on Android, and we don't support background audio for Android
        //Only retry streams
        if(!audioPlayer.isStream()) {
            allowRetry = false;
        }

        return allowRetry;
    }
    , retryAudio: function(){
        console.warn('retryAudio');

        if(audioPlayer._interval.id == null){
            audioPlayer._interval.id = setInterval(function(){ audioPlayer.resumePlay();}, audioPlayer._interval.time);
        }
    }
    , cancelRetry: function(){
        if(audioPlayer._interval.id != null){
            clearInterval(audioPlayer._interval.id);
            audioPlayer._interval.id = null;
        }
    }
    , resumePlay: function(){
        if(!audioPlayer.audio.paused){
            console.warn('restart audio', new Date());
            audioPlayer._allowPlay = true;
            audioPlayer.play(audioPlayer._currentTrack);
        }
    }
    , init: function () {
        var t = this;
        try {
            if (this.audio && this.audio.addEventListener){
                this.audio.addEventListener('ended', function () {
                    t.triggerOnEvent('audioEnded', t._currentTrack);
                    if (t.settings.autoPlayNext)t.next();
                });
            }

            //Audio stopped playing midstream, possibly due to network loss
            if (this.audio && this.audio.addEventListener){
                this.audio.addEventListener('stalled', function () {
                    console.warn('audio stalled', new Date());

                    if(audioPlayer.retryAllowed()){
                        audioPlayer.retryAudio();
                    }
                });
            }

            //Error, such as a fail to play
            if (this.audio && this.audio.addEventListener){
                this.audio.addEventListener('error', function () {
                    console.warn('audio error', new Date());

                    if(audioPlayer.retryAllowed()) {
                        audioPlayer.retryAudio();
                    }
                });
            }

            if (this.audio && this.audio.addEventListener){
                this.audio.addEventListener('playing', function () {
                    console.warn('playing', new Date());
                    audioPlayer.cancelRetry();
                });
            }
        }
        catch(e){
            console.warn('error', e);
        }

        var lastSavedTime = 0;
        if(this.audio && this.audio.addEventListener) this.audio.addEventListener('timeupdate', function () {
            if (t._currentTrack)
                t._currentTrack.lastPosition = t.audio.currentTime;

            if (Math.abs(lastSavedTime - t.audio.currentTime) > 5) {
                t.save();
                lastSavedTime = t.audio.currentTime
            }

            t.triggerOnEvent('timeUpdate', {
                currentTime: t.audio.currentTime, duration: t.audio.duration
                , buffer: {
                    start: t.audio.buffered.length ? t.audio.buffered.start(0) : 0
                    , end: t.audio.buffered.length ? t.audio.buffered.end(0) : 0
                }
            });
        });

        if(this.audio && this.audio.addEventListener) this.audio.addEventListener('error', function (e) {
            t.triggerOnEvent('error', e);
        });

        var appContext = window.appContext;

        if (appContext != null &&  typeof(appContext) != 'undefined' && typeof(appContext.currentApp) != "undefined" && typeof(appContext.currentApp.appId) != "undefined") {
            /// get previously saved data
            var json = window.localStorage.getItem('audioPlayer');

            if(json != '{}'){
                try{
                    var rec = JSON.parse(json);

                    t.settings = rec.settings;
                    t.playlist = rec.playlist;
                    t._currentTrack = rec._currentTrack;
                    t.audio.volume = t.settings.volume;
                }
                catch(e){
                    console.warn('audioPlayer localStorage error', e);
                }
            }

        }
        else
            console.warn("no app found for audioPlayer");


    }
    , getCurrentTrack: function (d, callback) {// maintain PluginAPI format
        if (callback)
            callback(this._currentTrack);
        return this._currentTrack;
    }
    , onEvent: function (callback) {
        var handler = function (e) {
            if (callback)callback(e.detail);
        };
        document.addEventListener('audioPlayer.onEvent', handler, false);
        return {
            clear: function () {
                document.removeEventListener('audioPlayer.onEvent', handler, false);
            }
        };
    }
    , triggerOnEvent: function (event, data) {
        var event = new CustomEvent('audioPlayer.onEvent', {'detail': {event: event, data: data}});
        document.dispatchEvent(event);
    }
    , _tmrSave: null
    , save: function () {

        /// save date with a delay
        if (this._tmrSave) clearTimeout(this._tmrSave);
        this._tmrSave = setTimeout(function () {
            try{
                var t = {
                    settings: audioPlayer.settings,
                    playlist: audioPlayer.playlist,
                    _currentTrack: audioPlayer._currentTrack
                };

                window.localStorage.setItem('audioPlayer', JSON.stringify(t));
            }
            catch(err){
                var message = err.message ? err.message : '';

                console.error('Error with JSON.stringify. ', message);
            }

        }, 500);
    }
    , play: function (track) {
        //if the track is empty or has changed, allow play
        if((!audioPlayer._currentTrack) || (track &&(audioPlayer._currentTrack.url != track.url))){
            audioPlayer._allowPlay = true;
        }

        if(!audioPlayer._allowPlay){
            return;
        }

        var trackType = typeof(track);
        if (trackType == "string")
            track = {url: track};
        else if (trackType == "number") {

            var lookup = this.playlist.tracks[track];
            if (lookup) {
                this.playlist.lastIndex = track;
                track = lookup;
                this.save();
            } else
                return;

        }
        else if (!track) {
            if (this.audio.paused) {
                this.audio.play();
                this.triggerOnEvent('resume', {track: this._currentTrack});
            }
            return;
        }

        this.audio.src = track.url;
        this.audio.preload = 'auto';
        this._currentTrack = track;

        //played	Returns a TimeRanges object representing the played parts of the audio/video
        console.warn('this.audio.play()', new Date());
        this.audio.play();
        this.triggerOnEvent('play', {track: track});

        if (this.settings && this.settings.autoJumpToLastPosition && track.lastPosition)
            this.skip(track.lastPosition);

        if (track.startAt)
            this.skip(track.startAt);


        audioPlayer._allowPlay = false;
    }
    , skip: function (value) {
        if (!this.audio) return;

        if (this.audio.currentTime + value < 0)
            this.audio.currentTime = 0;
        else if (this.audio.currentTime + value > this.audio.duration)
            this.audio.currentTime = this.audio.duration;
        else
            this.audio.currentTime += value;
        this.triggerOnEvent('skip', value);
    }
    , pause: function () {
        audioPlayer.audio.pause();
        audioPlayer._allowPlay = true;
        audioPlayer.triggerOnEvent('pause');
    }
    , isPaused: function (args,callback) {
        if(callback)callback(null, audioPlayer.audio.paused);
    }
    , loopTrack: function (val) {
        if (audioPlayer.audio)audioPlayer.audio.loop = val;
    }
    , next: function () {
        var track;
        if (audioPlayer.settings.shufflePlaylist)
            audioPlayer.playlist.lastIndex = Math.round((audioPlayer.playlist.tracks.length - 1) * Math.random());
        else
            audioPlayer.playlist.lastIndex++;

        if (audioPlayer.playlist.lastIndex >= audioPlayer.playlist.tracks.length) {
            if (audioPlayer.settings.loopPlaylist && audioPlayer.playlist.tracks.length)
                audioPlayer.playlist.lastIndex = 0;
            else {
                audioPlayer.playlist.lastIndex = audioPlayer.playlist.tracks.length - 1;
                return null;
            }
        }

        track = audioPlayer.playlist.tracks[audioPlayer.playlist.lastIndex];

        audioPlayer.save();

        audioPlayer.triggerOnEvent('next', {index: audioPlayer.playlist.lastIndex, track: track});
        if (track)audioPlayer.play(track);
        return track;
    }
    , previous: function () {
        var track;
        if (audioPlayer.settings.shufflePlaylist)
            audioPlayer.playlist.lastIndex = Math.round((audioPlayer.playlist.tracks.length - 1) * Math.random());
        else
            audioPlayer.playlist.lastIndex--;

        if (audioPlayer.playlist.lastIndex < 0) {
            if (audioPlayer.settings.loopPlaylist && audioPlayer.playlist.tracks.length)
                audioPlayer.playlist.lastIndex = audioPlayer.playlist.tracks.length - 1;
            else {
                audioPlayer.playlist.lastIndex = 0;
                return null;
            }
        }

        track = audioPlayer.playlist.tracks[audioPlayer.playlist.lastIndex];

        audioPlayer.save();

        audioPlayer.triggerOnEvent('previous', {index: audioPlayer.playlist.lastIndex, track: track});
        if (track)audioPlayer.play(track);
        return track;
    }
    , removeFromPlaylist: function (index) {
        if (index < 0 || index >= audioPlayer.playlist.tracks.length)
            return;

        var track = audioPlayer.playlist.tracks.splice(index, 1);

        if (index == audioPlayer.playlist.lastIndex)
            audioPlayer.playlist.lastIndex = -1;
        else if (index < audioPlayer.playlist.lastIndex)
            audioPlayer.playlist.lastIndex--;

        audioPlayer.triggerOnEvent('removeFromPlaylist', {index: index, track: track, newPlaylist: audioPlayer.playlist});
    }
	, addToPlaylist: function (track) {
		audioPlayer.playlist.tracks.push(track);
		audioPlayer.save();

        audioPlayer.triggerOnEvent('addToPlaylist', {track: track, newPlaylist: audioPlayer.playlist});
	}
    , setTime: function (sec) {
        audioPlayer.audio.currentTime = sec;
        audioPlayer._currentTrack.lastPosition = audioPlayer.audio.currentTime;
        audioPlayer.save();
        audioPlayer.triggerOnEvent('timeUpdate', {
            currentTime: audioPlayer.audio.currentTime, duration: audioPlayer.audio.duration
            , buffer: {
                start: audioPlayer.audio.buffered.length ? audioPlayer.audio.buffered.start(0) : 0
                , end: audioPlayer.audio.buffered.length ? audioPlayer.audio.buffered.end(0) : 0
            }
        });
    }
    , setVolume: function (percent) {
        if (percent < 0) percent = 0;
        else if (percent > 1 && percent <= 100) percent = percent / 100;

        if(audioPlayer.settings) audioPlayer.settings.volume = percent;
        if(audioPlayer.audio) audioPlayer.audio.volume = percent;
        audioPlayer.triggerOnEvent('volumeChange', {volume: percent});
        audioPlayer.save();
    }
    , playlist: {
        tracks: []
        , lastIndex: -1
    }
    , getPlaylist: function (d, callback) {
        callback(null, audioPlayer.playlist);
    }

};

if (typeof(PluginAPI) != "undefined" && !PluginAPI.prototype.mediaAPI)
    PluginAPI.prototype.mediaAPI = {
        audioPlayer: window.audioPlayer
    };

window.addEventListener('load', function () {
    audioPlayer.init();

    if(typeof cordova !== 'undefined' && cordova.plugins && cordova.plugins.backgroundMode){
        cordova.plugins.backgroundMode.setDefaults({
            text: 'Background mode enabled',
        });

        cordova.plugins.backgroundMode.enable();
        if(audioPlayer.isAndroid())
            cordova.plugins.backgroundMode.disableWebViewOptimizations();
    }
});
"use strict";
/**
 * Created by Ayman on 7/30/2015.
 */

function NotificationsAPI(context) {
	this.context = context;
}

NotificationsAPI.prototype = {
    /*options:{
              title:
              message:
              okButton:{text:,type:}
    }*/
	alert: function (options, callback) {
        if (!options) {
            options = {};
        }
        if (!options.message) {
            callback("invalid parameter, messing message");
            return;
        }
        if (!options.okButton) {
            options.okButton = {text: "OK"};
        }
        if (!options.okButton.text) {
            options.okButton.text = "OK";
        }
		if (window.device && window.device.platform != "web" && typeof(navigator) != 'undefined' && navigator.notification && navigator.notification.alert) {
			navigator.notification.alert(
				options.message,  // message
				callback,         // callback
				options.title,            // title
                options.okButton.text // buttonName
			);
		}
		else {
			alert(options.message);
			if (callback)callback();
		}
	}
	,
    /*options:{
                  title:
                  message:
                  confirmButton:{text:,type:},
                  cancelButton:{text:,type:}
    }*/
	confirm: function (options, callback) {
        if (!options) {
            options = {};
        }
        if (!options.message) {
            callback("invalid parameter, missing message", null);
            return;
        }

        if (!options.confirmButton) {
            options.confirmButton = {text: "Confirm"};
        }
        if (!options.confirmButton.text) {
            options.confirmButton.text = "Confirm";
        }
        if (!options.cancelButton) {
            options.cancelButton = {text: "Cancel"};
        }
        if (!options.cancelButton.text) {
            options.cancelButton.text = "Cancel";
        }
        options.buttonLabels = [options.confirmButton.text, options.cancelButton.text];

		if (window.device && window.device.platform != "web" && typeof(navigator) != 'undefined' && navigator.notification && navigator.notification.confirm) {
			navigator.notification.confirm(
				options.message, // message
				callback,   // callback to invoke with index of button pressed
				options.title,  // title
				options.buttonLabels // buttonLabels
			);
		}
		else {
			var val = confirm(options.message);
			if (callback)callback(val);
		}
	}
	,
	prompt: function (options, callback) {
		if (window.device && window.device.platform != "web" && typeof(navigator) != 'undefined' && navigator.notification && navigator.notification.prompt) {
			navigator.notification.prompt(
				options.message,  // message
				callback,                  // callback to invoke
				options.title,            // title
				options.buttonLabels,             // buttonLabels
				options.defaultText                 // defaultText
			);
		}
		else {
			var val = prompt(options.message);
			if (callback)callback(val);
		}
	}
	,
	beep: function (options, callback) {
        console.log("calling NotificationsAPI.beep ...");
		if (window.device && window.device.platform != "web" && typeof(navigator) != 'undefined' && navigator.notification && navigator.notification.beep) {
			navigator.notification.beep(options.times);
			if (callback)callback();
		}
		else {
			if (callback)callback();
		}
	}
	,
	vibrate: function (options, callback) {
        console.log("calling NotificationsAPI.vibrate ...");
		if (window.device && window.device.platform != "web" && typeof(navigator) != 'undefined' && navigator.notification && navigator.notification.vibrate) {
			navigator.notification.vibrate(options.milliseconds);
			if (callback)callback();
		}
		else {
			if (callback)callback();
		}
	}
};

/**
 * Created by Daniel on 3/30/2015.
 * only allow reads without secure api key
 * cache data here so that we dont hit the server for the same info over and over
 */
function appAPI(context) {
    this.appId = context.appId;
    this.liveMode = context.liveMode;
    this.appHost = context.endPoints.appHost;
    if (typeof(CustomEvent) == "undefined")
        console.warn("Browser doesnt support CustomEvent");
};


appAPI.prototype = {
    getPluginInstances: function (data, callback) {
        var ds = new DatastoreAPI(this.appId, "pluginInstances", 1, this.liveMode, null);
        if(!data)
            data = {};

        //if(!data.pageSize)           data.pageSize = 10;

        if(!data.pageIndex)            data.pageIndex = 1;

        var packet = {
            obj: {
                filter: {"$json.title": {"$regex": data.title != null ? data.title  : '' }},
                page: data.pageIndex - 1
                , pageSize: data.pageSize  // the plus one is to check if there are any more
                , withDynamicData: true
                , recordCount: true
            },
            tag: ''
        };

        ds.search(packet, function (err, results) {
            
            if (!err) {
                callback (null,{data:results.result,totals:results.totalRecord});
            }
        });
    }
};
if (typeof(ActionItemsAPI) == 'undefined') {

    window.ActionItemsAPI = function (context) {
        this.templateUrl = 'pages/share/actionBuilder.html';
        this.listTemplateUrl = window._appRoot + 'pages/templates/actionItemsListDialog.html';
        this.controller = 'actionItemsCtrl';
        this.context = context;
        this.init();
    }
}


ActionItemsAPI.prototype.init = function () {

};

ActionItemsAPI.prototype.list = function (data, callback) {
    var openDialogOptions = {
        templateUrl: this.listTemplateUrl,
        controller: 'actionItemsListDialogCtrl',
        size: 'lg',
        data: data
    };

    window.openDialog(openDialogOptions, function (result) {
        if (callback)
            callback(null, result);
    });
};
ActionItemsAPI.prototype.openWebLink  = function (url , openIn, callback) {
    if(url){
        const isInAppBrowser = (openIn === '_blank');
        let windowReference = window.open(url, openIn,'location=no');
        let timeout;

        //If the in app pop-up fails, fall back the system's browser
        if(isInAppBrowser){
            timeout = setTimeout(()=>{
                ActionItemsAPI.prototype.openWebLink(url, '_system', callback);
                windowReference && windowReference.close();
            },1000);
        }

        //If this event fires then the window is being opened
        windowReference && windowReference.addEventListener('loadstart', () =>{
            if(timeout)
                clearTimeout(timeout);
        });

        if(callback){
            callback(!windowReference ? "failed to open window" : null);
        }

        if (!windowReference) {
            ActionItemsAPI.prototype.popUpCtrlScope.show(url);
        }
    }
};

ActionItemsAPI.prototype.sendEmail = function(email , subject , body){
        var url="mailto:"+ (email != null && email != '' ? email : '' ) +"?" + (subject != null && subject != '' ? 'subject=' + subject : '' ) + "&"  + (body != null && body != '' ? 'body=' + body : '' );
        window.open(url, "_system");
};

ActionItemsAPI.prototype.navigateToAddress = function(lat , lng ){
    if(lat && lng){
        var url = "https://maps.google.com/?q=";
        if (window.device && window.device.platform != null ) {
            if (window.device.platform.toLowerCase() == "android") {
                url = 'geo:?q=';
            } else if (window.device.platform.toLowerCase() == "ios") {
                url = 'maps://maps.apple.com?q=' ;
            }
        }

        window.open(url + lat + "," + lng,'_system','location=no,menubar=no,titlebar=no,toolbar=no')
    }
};

ActionItemsAPI.prototype.callNumber = function(phoneNumber){
    if (phoneNumber) {
        phoneNumber = phoneNumber.replace(/ /, '');
        window.open('tel:'+phoneNumber+'','_system','location=no,menubar=no,titlebar=no,toolbar=no');
    }
};

ActionItemsAPI.prototype.sendSms = function(phoneNumber){
    if (phoneNumber) {
        phoneNumber = phoneNumber.replace(/ /, '');

        if ((navigator.platform.indexOf("Android") != -1) || (navigator.platform.indexOf("Linux") != -1) || navigator.platform == null) {
            var url = "sms:" + phoneNumber;
            window.open(url, "_system");
        }
        else if ((navigator.platform.indexOf("iPhone") != -1) || (navigator.platform.indexOf("iPad") != -1)) {
            var url = "sms:" + phoneNumber;
            window.open(url, "_system");
        }
        else {
            console.error("This action can't be used on browser , it should be used on actual device");
        }
    }
};

ActionItemsAPI.prototype.linkToAppContent = function (instanceId, params) {
    var dsPluginInstance = new DatastoreAPI(appContext.currentApp.appId, "pluginInstances", 1,  appContext.liveMode);

    var options = {};
    options.obj = {
        filter: {"$json.instanceId": instanceId},
        pageSize: 1,
        withDynamicData: true
    };
    dsPluginInstance.search(options, function (err, result) {
        if(result && result.length ){
            var instanceId = result[0].data.instanceId;
            var token = result[0].data._buildfire.pluginType.result[0].token;
            var folderName = result[0].data._buildfire.pluginType.result[0].folderName;
            var title = result[0].data.title;
            var pluginAPI =  window.appContext.currentPlugin  ? window.appContext.currentPlugin.pluginAPI :window.postMaster.launcherPluginAPI ;
            if(pluginAPI) {
                pluginAPI.navigation.navigateTo({
                    pluginId: token
                    , instanceId: instanceId
                    , title: title
                    , folderName: folderName
                    , pushToHistory: true
                    , queryString: params ? params.queryString : null
                }, null);
            }
            else
                console.warn("Plugin API is empty");
        }
    });
};

ActionItemsAPI.prototype.navigateToPage = function (pageName, options) {
    if (!options) {
        options = {}
    }

    if (!pageName) {
        console.error("Action Items", 'navigateToPage', 'Please specify Page Name!');
        return;
    }

    if (pageName == "login") {
        if (window.authAPI && window.authAPI.login) {
            window.authAPI.login();
        }
        return;
    }

    if (pageName == "appSearch" && window.appContext.currentApp.config.type != "enterprise") {
        console.info("Action Items", "Search page only available for Enterprise Plan");
        return;
    }


    if (options.queryString) {
        let esc = encodeURIComponent;
        let queryString = Object.keys(options.queryString)
            .map(k => esc(k) + '=' + esc(options.queryString[k]))
            .join('&');

        pageName = pageName + "?" + queryString;
    }

    window.location.hash = pageName;
};

ActionItemsAPI.prototype.purchase = function(purchaseType, prodObj, successMessage, errorMessage, navigateToPluginInstanceId, callback){
    if (!bfUtils.isMobileDevice) {
        // alert("This action can't be used on browser , it should be used on actual device");
        return;
    }
    if (typeof inAppPurchaseAPI == 'undefined') {
        console.error('inAppPurchaseAPI is undefined');
        return;
    }
    var purchaseResultCallback = function (err, purchase) {
        if(!err) {
            if(purchase && purchase.isApproved) {
                if (!bfUtils.isIOS) {
                    var options = {
                        data: {
                            title: ' ',
                            body: successMessage,
                            disableCancel: true
                        }
                    };

                    window.openDialog(options, function(){});

                    if(navigateToPluginInstanceId) {
                        ActionItemsAPI.prototype.linkToAppContent(navigateToPluginInstanceId);
                    }
                }
            }
        }
        else {
            var options = {
                data: {
                    title: ' ',
                    body: errorMessage,
                    disableCancel: true
                }
            };

            window.openDialog(options, function(){});
        }
        callback(err, purchase);
    };
    inAppPurchaseAPI.checkAccess(prodObj, function(err, product) {
        if (err) {
            console.error("error while checking product", err);
        }
        if (product && product.owned) {
            if(navigateToPluginInstanceId) {
                ActionItemsAPI.prototype.linkToAppContent(navigateToPluginInstanceId);
            }
            callback(null, { product: product, isApproved: true });
        } else {
            var productId = prodObj.productId;
            if (prodObj.purchaseType === "subscriptions" && prodObj.subscription) {
                productId = prodObj.subscription.subscriptionId;
            }
            inAppPurchaseAPI.purchase({productId: productId, purchaseType: purchaseType}, purchaseResultCallback);
        }
    });
};

ActionItemsAPI.prototype.execute = function (actionItem, callback) {

    var actionSupportsCallback = false;
    switch (actionItem.action) {
        case 'linkToApp' :
            this.linkToAppContent(actionItem.instanceId, {queryString: actionItem.queryString});
            break;
        case 'linkToWeb' :
            actionSupportsCallback = true;
            this.openWebLink(actionItem.url , actionItem.openIn, callback);
            break;
        case 'sendEmail' :
           this.sendEmail(actionItem.email,actionItem.subject,actionItem.body);
            break;
        case 'callNumber' :
            this.callNumber(actionItem.phoneNumber);
            break;
        case 'sendSms' :
            this.sendSms(actionItem.phoneNumber);
            break;
        case 'navigateToAddress' :
            this.navigateToAddress(actionItem.lat,actionItem.lng);
            break;
        case 'navigateToAppSettings' :
            this.navigateToPage('appSettings');
            break;
        case 'navigateToNotifications' :
            this.navigateToPage("pushGroups");
            break;
        case 'navigateToBookmarks' :
            this.navigateToPage("bookmarks");
            break;
        case 'navigateToSearch' :
            let options = {};
            if (actionItem.searchAppValue) {
                options.queryString = {
                    searchTerm: actionItem.searchAppValue
                }
            }

            this.navigateToPage("appSearch", options);
            break;
        case 'navigateToLogin' :
            this.navigateToPage("login");
            break;
        case 'navigateToNotes' :
            window.notesAPI.openDialog();
            break;
        case 'linkToSocialGoogle' :
            this.openWebLink(actionItem.url , "_system");
            break;
        case 'linkToSocialFacebook' :
            this.openWebLink(actionItem.url , "_system");
            break;
        case 'linkToSocialInstagram' :
            this.openWebLink(actionItem.url , "_system");
            break;
        case 'linkToSocialTwitter' :
            this.openWebLink(actionItem.url , "_system");
            break;
        case 'linkToSocialLinkedIn' :
            this.openWebLink(actionItem.url , "_system");
            break;
        case 'purchase':
            actionSupportsCallback = true;
            var prodObj = {
                productId: actionItem.productId,
                subscriptions: actionItem.subscriptions,
                subscription: actionItem.subscription,
                purchaseType: actionItem.purchaseType
            };
            this.purchase(actionItem.purchaseType, prodObj, actionItem.successMessage, actionItem.errorMessage, actionItem.instanceId, callback);
            break;
    }
    if (!actionSupportsCallback) {
        callback(null,true);
    }

};

if(typeof($app) != "undefined")
    $app.controller('actionItemsListDialogCtrl',['$scope','$data','$dialog',function($scope,$data,$dialog){
        $scope.actionItems=$data.actionItems;
        $scope.executeItem = true;
        $scope.close = function(){
            $dialog.close(null);
        };
        if($data.options && $data.options.executeItem  )
            $scope.executeItem = $data.options.executeItem;
        $scope.openActionItem = function(actionItem){
            if($scope.executeItem){
                var pluginAPI =  window.appContext.currentPlugin  ? window.appContext.currentPlugin.pluginAPI :window.postMaster.launcherPluginAPI ;
                pluginAPI.actionItems.execute(actionItem,function(err,result){
                    $dialog.close(actionItem);
                });
            }
            else
                $dialog.close(actionItem);
        }

    }]);

function PluginInstanceAPI(context) {
    this.templateUrl = 'pages/plugins/pluginInstanceDialog/pluginInstanceDialog.html';
    this.controller = 'pluginInstanceDialog';
    this.appId = context.appId;
    this.liveMode = context.liveMode;
    this.appHost = window.siteConfig.endPoints.appHost;
    var dContext = JSON.parse(JSON.stringify(context)); // make a copy
    dContext.pluginId = "pluginInstances";
    dContext.instanceId = 1;
    this.ds = new DatastoreAPI(dContext);
};

PluginInstanceAPI.prototype = {
    showDialog: function (data, callback) {

        if(!window.openDialog){
            console.error("openDialog isnt defined");
            return;
        }

        var openDialogOptions = {
            templateUrl: this.templateUrl,
            controller: this.controller,
            size: 'lg',
            data: data
        };

        window.openDialog(openDialogOptions, function (result) {
            if (callback)
                callback(null, result);
        });
    }
    , get: function (instanceId, callback) {
        /*var params = {};
         if (ids instanceof Array) {
         params.ids = ids.join(", ")
         } else
         params.ids = ids;

         var url = this._createReadUrl();

         this._httpGet(url, params, function (err, result) {
         if (err)
         callback(err, null);
         else
         callback(null, result);
         });*/


        var options = {};
        options.obj = {
            filter: {"$json.instanceId": instanceId},
            pageSize: 1,
            withDynamicData: true
        };


        this.ds.search(options, function (err, result) {
            if (!err) {
                if (result && result.length) {
                    callback(null, result[0].data);
                } else
                    callback(null);
            } else
                callback(err, null);

        });
    }
    , _createReadUrl: function () {
        return this.appHost + "/api/appPluginInstances/getByIds/" + this.appId;
    }
    , _httpGet: function (url, params, callback) {
        bfUtils.http.get(url, {params: params}).success(
            function (data) {
                callback(null, data);
            }
        ).error(
            function (err) {
                callback(err);
            }
        );
    }
    , search: function (options, callback) {


        var filter;
        if (options.title) filter = {"$json.title": {"$regex": options.title,"$options" : "-i"}};
        var packet = {
            obj: {
                filter: filter,
                page: options.pageIndex
                , pageSize: options.pageSize  // the plus one is to check if there are any more
                , withDynamicData: true
                , recordCount: true
            },
            tag: ''
        };

        this.ds.search(packet, callback);


    }
};
"use strict";

var deviceAPI = {
    calendar:{
        /*
        * event {
        * title
        * ,location
        * ,notes
        * ,startDate
        * ,endDate
        * ,options: {
        *    ,firstReminderMinutes = 120; // default is 60, pass in null for no reminder (alarm)
             ,secondReminderMinutes = 5;
             ,recurrence = "monthly"; // supported are: daily, weekly, monthly, yearly
             ,recurrenceEndDate = new Date(2015,6,1,0,0,0,0,0); // leave null to add events into infinity and beyond
        *   }
        * }
        * */
        addEvent: function(event,callback){
            var cal;

            if(window.plugins && window.plugins.calendar)
                cal= window.plugins.calendar;

            if(!cal){
                console.warn("cannot complete action add event to calendar. so fake it");
                if(window.location.protocol.indexOf('http') >= 0 )
                    alert('Adding to calendar requires native app.');
                else
                    console.error('Calendar feature not installed');
                return;
            }

            if(!(event.startDate instanceof Date))
                event.startDate = new Date(event.startDate); // beware: month 0 = january, 11 = december

            if(!(event.endDate instanceof Date))
                event.endDate = new Date(event.endDate); // beware: month 0 = january, 11 = december

            var success = function (message) {
                callback(null,message);
            };
            var error = function (message) {
               callback(message);
            };

            /*
            var calOptions = cal.getCalendarOptions(); // grab the defaults
            calOptions.firstReminderMinutes = 120; // default is 60, pass in null for no reminder (alarm)
            calOptions.secondReminderMinutes = 5;
            calOptions.recurrence = "daily"; // supported are: daily, weekly, monthly, yearly
            calOptions.recurrenceEndDate = new Date(2025, 4, 15, 19, 30, 0, 0, 0); //
*/


            if( event.options) {
                var calOptions;
                calOptions = cal.getCalendarOptions();
                calOptions.firstReminderMinutes = event.options.firstReminderMinutes || calOptions.firstReminderMinutes;
                calOptions.secondReminderMinutes = event.options.secondReminderMinutes || calOptions.secondReminderMinutes;
                calOptions.recurrence = event.options.recurrence || calOptions.recurrence;
                if(event.options.recurrenceEndDate)
                calOptions.recurrenceEndDate = new Date(event.options.recurrenceEndDate);
                cal.createEventWithOptions(event.title, event.location, event.notes, event.startDate, event.endDate, calOptions, success, error);
            }
            else {

                cal.createEvent(event.title, event.location, event.notes, event.startDate, event.endDate, success, error);
            }

        }
    },
    share: function(messageObj, callback){
        if(window.plugins && window.plugins.socialsharing) {
            window.plugins.socialsharing.share(messageObj.text, messageObj.subject, messageObj.image, messageObj.link)
            callback(null, true);
        } else {
            console.warn("device sharing plugin not found. defaulting to email sending");
            window.location = 'mailto:?subject=' + encodeURIComponent(messageObj.subject) + '&body=' + encodeURIComponent(messageObj.text + ' ' + messageObj.link);
            callback(null, true);
        }
    },
    onAppBackgrounded: function (callback) {
        document.addEventListener('deviceAppBackgrounded', callback, false);
    },
    onAppResumed: function (callback) {
        document.addEventListener('deviceAppResumed', callback, false);
    }
};
"use strict";
/**
 * Created by Daniel on 3/30/2015.
 * only allow reads without secure api key
 * cache data here so that we dont hit the server for the same info over and over
 */

function HistoryAPI(appId, pluginId, instanceId, liveMode) {
    if (typeof(appId) == "object") {
        var config=appId;
        this.appId = config.appId;
        this.pluginId = config.pluginId;
        this.instanceId = config.instanceId;
        this.liveMode = config.liveMode;
    }
    else {
        this.appId = appId;
        this.pluginId = pluginId;
        this.instanceId = instanceId;
        this.liveMode = liveMode;
    }
}

HistoryAPI.prototype =  {
    historyItems: [],
    push: function (pushedItem, callback) {
        if(typeof emulatorSync === 'undefined') { // we are on the correct side
            if(pushedItem.source != "plugin") { // remove all breadcrumbs added by the current plugin when pushing history for a new plugin
                var pluginBreadcrumbIndex = -1;
                if(this.historyItems.length > 1) {
                    for(var i = 1; i < this.historyItems.length; i++) {
                        if(this.historyItems[i].source == "plugin") { // keep launcher own breadcrumbs, remove only other plugin breadcrumbs
                            if(this.historyItems[i - 1].source == "control") {
                                pluginBreadcrumbIndex = i;
                                break;
                            }
                        }
                    }
                    if(pluginBreadcrumbIndex >= 0) {
                        this.historyItems.splice(pluginBreadcrumbIndex);
                    }
                }
            }
            pushedItem.uid = new Date().getTime();
            this.historyItems.push(pushedItem);
            var onPushEvent = new CustomEvent('historyOnPush', { detail: { pushedItem: pushedItem }});
            document.dispatchEvent(onPushEvent);
            var onUpdateEvent = new CustomEvent('historyOnUpdate', { detail: { historyItems: this.historyItems }});
            document.dispatchEvent(onUpdateEvent);
        } else {  // no history items here. delegate call to the app side
            var packet = new Packet(null, 'history.pushAppHistory', pushedItem);
            emulatorSync.sendMessage(packet);
        }

        if(callback) {
            callback(null, true);
        }
        return this;
    },
    get: function(options, callback) {
        if(options && options.pluginBreadcrumbsOnly) {
            var pluginBreadcrumbs = [];
            for(var i = 0; i < this.historyItems.length; i++) {
                if(this.historyItems[i].source == "plugin") {
                    pluginBreadcrumbs.push(this.historyItems[i]);
                }
            }
            callback(null, pluginBreadcrumbs);
        }
        else {
            callback(null, this.historyItems);
        }
        return this;
    },
    getNext: function(breadcrumb) {
        var nextBreadcrumb = null;
        if (this.historyItems) {
            for(var i = 0; i < this.historyItems.length; i++) {
                if(this.historyItems[i] == breadcrumb || this.historyItems[i].uid == breadcrumb.uid) {
                    if(i < this.historyItems.length) {
                        nextBreadcrumb = this.historyItems[i + 1];
                    }
                    break;
                }
            }
        }
        return nextBreadcrumb;
    },
    pop: function(breadcrumb, callback) {
        if(typeof emulatorSync === 'undefined') { // we are on the correct side
            if(!breadcrumb && this.historyItems) {
                if(this.historyItems.length > 1) {
                    var lastBreadcrumb = this.historyItems[this.historyItems.length - 1];
                    if(lastBreadcrumb && lastBreadcrumb.source == "plugin") {
                        breadcrumb = this.historyItems[this.historyItems.length - 2]; // pop to the previous one
                    }
                }
                else {
                    if(this.historyItems[0] && this.historyItems[0].source == "plugin") {
                        breadcrumb =  this.historyItems[0];
                    }
                }
            }
            if(breadcrumb) {
                var breadcrumbIndex = -1;
                var isPluginTopBreadcrumb = false; // if this is the top level breadcrumb within the same plugin instance
                for(var i = 0; i < this.historyItems.length; i++) {
                    if(this.historyItems[i] == breadcrumb || this.historyItems[i].uid == breadcrumb.uid) {
                        breadcrumbIndex = i;
                        if( i + 1  < this.historyItems.length && this.historyItems[i + 1].source == "plugin") {
                            isPluginTopBreadcrumb = true;
                        }
                        break;
                    }
                }
                if(breadcrumbIndex >= 0 && breadcrumbIndex <= this.historyItems.length) {
                    this.historyItems.splice(breadcrumbIndex + 1);
                }
                var onPopEvent = new CustomEvent('historyOnPop', { detail: { poppedItem: breadcrumb }});
                document.dispatchEvent(onPopEvent);
                var onUpdateEvent = new CustomEvent('historyOnUpdate', { detail: { historyItems: this.historyItems }});
                document.dispatchEvent(onUpdateEvent);
                if((isPluginTopBreadcrumb || breadcrumb.source == "plugin") && postMaster ) {
                    var packet = new Packet(null, "history.triggerOnPop", breadcrumb);
                    if(postMaster.widgetPluginAPI) {
                        postMaster.widgetPluginAPI.sendMessage(null, packet);
                    }
                    else if(postMaster.launcherPluginAPI) {
                        postMaster.launcherPluginAPI.sendMessage(null, packet);
                    }
                }
            } else{
                if(callback) {
                    callback("breadcrumb not found");
                    return this;
                }
            }
        }
        else { // no history items here. delegate call to the app side
            var packet = new Packet(null, 'history.popAppHistory', breadcrumb);
            emulatorSync.sendMessage(packet);
        }
        if(callback) {
            callback(null, true);
        }
        return this;
    },
    popToHome: function() {
        if (this.historyItems && this.historyItems.length > 1) {
            for(var i = 1; i < this.historyItems.length; i++) {
                if(this.historyItems[i].source == 'control' ) {
                    this.pop(this.historyItems[i - 1]);
                }
            }
        }
    },
    popToPlugin: function() {
        if (this.historyItems && this.historyItems.length > 1) {
            for(var i = this.historyItems.length - 1; i > 1; i--) {
                if(this.historyItems[i].source == 'plugin' ) {
                    this.pop(this.historyItems[i - 1]);
                }
                else {
                    break;
                }
            }
        }
    },
    clear: function(options, callback) {
        var poppedItem = this.historyItems[0];
        this.historyItems.splice(0);
        if(callback) {
            callback(null);
        }
        var onUpdateEvent = new CustomEvent('historyOnUpdate', { detail: { historyItems: this.historyItems }});
        document.dispatchEvent(onUpdateEvent);
        if(poppedItem) {
            var onPopEvent = new CustomEvent('historyOnPop', { detail: { poppedItem: poppedItem }});
            document.dispatchEvent(onPopEvent);
        }
        return this;
    },
    triggerOnPop: function (poppedItem) {
        var onPopEvent = new CustomEvent('historyOnPop', { detail: { poppedItem: poppedItem }});
        document.dispatchEvent(onPopEvent);
        return this;
    },
    triggerOnUpdate: function (historyItems) {
        this.historyItems = historyItems;
        var onUpdateEvent = new CustomEvent('historyOnUpdate', { detail: { historyItems: historyItems }});
        document.dispatchEvent(onUpdateEvent);
        return this;
    },
    onUpdate: function (callback) {
        var handler = function (e) { if (callback)
            callback({ historyItems: e.detail.historyItems });
        };
        document.addEventListener('historyOnUpdate', handler, false);
        return {
            clear:function () {document.removeEventListener('historyOnUpdate', handler, false); }
        };
    },
    onPop: function (callback) {
        var handler = function (e) { if (callback)
            callback(e.detail);
        };
        document.addEventListener('historyOnPop', handler, false);
        return {
            clear:function () {document.removeEventListener('historyOnPop', handler, false); }
        };
    },
    onPush: function (callback) {
        var handler = function (e) { if (callback)
            callback({ historyItems: e.detail.historyItems, pushedItem: e.detail.pushedItem });
        };
        document.addEventListener('historyOnPush', handler, false);
        return {
            clear:function () {document.removeEventListener('historyOnPush', handler, false); }
        };
    }
};

"use strict";
/**
 * Created by Daniel on 3/30/2015.
 * this class is whats used for the plugin frame to communicate with he parent app shell
 * this only allows certain interactions to occur for security purposes
 * all functionality should return *this* and accept a callback
 * *** this also handel's messages sent from the CP
 */

function Packet(id, cmd, data, error) {
	this.id = id;
	this.cmd = cmd;
	this.data = data;
	this.error = error;
	this.instanceId;
}
var pluginCount = 0;

if (typeof(logger) == "undefined")
	var logger = {
		log: function () {
		}
	}; //fail safe

function PluginAPI(iFrameId, appId, pluginId, instanceId, liveMode, datastoreWriteKey, type, title) {
	pluginCount++;
	this.datastore = this.analytics = this.appearance = null;
	this.iFrameId = iFrameId;
	this.iFrame = document.getElementById(iFrameId);
	this.init(appId, pluginId, instanceId, liveMode, datastoreWriteKey, type, title);
}

PluginAPI.prototype = {
	getContentWindow: function () {
		//if(!this.iFrame)return null;

		//if(this.iFrame && !this.iFrame.contentWindow)
		this.iFrame = document.getElementById(this.iFrameId);

		if (this.iFrame)
			return this.iFrame.contentWindow;
		else
			return null;
	}
	, debugTag: null
	, init: function (appId, pluginId, instanceId, liveMode, datastoreWriteKey, type, title) {

		if (!window.appContext || !window.appContext.currentApp ){
			console.error('invalid appContext cant create pluginAPI');
			return;
		}

		var cpDomain = (window.appContext
			&& window.appContext.currentApp && window.appContext.currentApp.config
			&& window.appContext.currentApp.config.cpDomain
		) ?
            window.appContext.currentApp.config.cpDomain :
            window.siteConfig.endPoints.appHost;

		this.context = {
			appId: appId
			, pluginId: pluginId
			, instanceId: instanceId
			, liveMode: liveMode || 0
			, endPoints: window.siteConfig.endPoints
			, cpDomain: cpDomain
			, device: window.device
            , deviceId: typeof(push) != "undefined" ? push.deviceId : null
			, debugTag: this.debugTag
			, datastoreWriteKey: datastoreWriteKey || undefined
			, type: type
			, appTheme : PluginAPI.appTheme
            , configType : PluginAPI.configType
			, title: title
		};

		var currentAppManifestString = localStorage.getItem("currentAppManifest");
		if(currentAppManifestString) {
			var currentAppManifest = null;
			try {
				currentAppManifest = JSON.parse(currentAppManifestString);
			}
			catch(err) {
				console.error("bad currentAppManifest", err);
			}
			this.context.offlineModeEnabled = currentAppManifest.offlineModeEnabled;
		}

		if (!this.context.device) {
			this.context.device = {
				platform: 'web'
			};
		}

		if (typeof(AppearanceAPI) != "undefined") this.appearance = new AppearanceAPI(this.context);
		if (typeof (DatastoreAPI) != "undefined") this.datastore = new DatastoreAPI(this.context);
		if (typeof (UserDatastoreAPI) != "undefined") this.userData = new UserDatastoreAPI(this.context);
        if (typeof(AnalyticsAPI) != "undefined") {
            this.analytics = new AnalyticsAPI(this.context);
        }
		if (typeof(ImageLibAPI) != "undefined") this.imageLib = new ImageLibAPI(this.context);
        if (typeof(ColorLibAPI) != "undefined") {
            this.colorLib = new ColorLibAPI(this.context);
            this.colorLib.onChange(function (data) {
                t.sendMessage(null, new Packet(null, 'colorLib._triggerOnChange', data));
            });
		}
		if (typeof(appAPI) != "undefined") this.appAPI = new appAPI(this.context);
		if (typeof(ActionItemsAPI) != "undefined") this.actionItems = new ActionItemsAPI(this.context);
		if (typeof(NotificationsAPI) != "undefined") this.notificationsAPI = new NotificationsAPI(this.context);
        if (typeof(PopupLibAPI) != "undefined") this.notificationsAPI = PopupLibAPI;
		if (typeof(HistoryAPI) != "undefined") this.history = new HistoryAPI(this.context);
		if (typeof(PluginInstanceAPI) != "undefined") this.pluginInstances = new PluginInstanceAPI(this.context);
		if (typeof(inAppPurchaseAPI) != "undefined") {this.inAppPurchase = inAppPurchaseAPI;}
        if (typeof(barcodeScannerAPI) != "undefined") {this.barcodeScanner = barcodeScannerAPI;}

        if (typeof (PublicDatastoreAPI) != "undefined") this.publicData = new PublicDatastoreAPI(this.context);
        if (typeof (AppDatastoreAPI) != "undefined") this.appData = new AppDatastoreAPI(this.context);

		if (typeof(localStorageAPI) != "undefined") this.localStorage = localStorageAPI;

		if (typeof(LocalNotificationsAPI) != "undefined"){
			this.localNotifications = new LocalNotificationsAPI(this.context);
		}

		if (typeof(deviceAPI) != "undefined") {
			this.device = deviceAPI;
			this.device.onAppBackgrounded(function (data) {
				t.sendMessage(null, new Packet(null, 'device.triggerOnAppBackgrounded', data.detail));
			});
			this.device.onAppResumed(function (data) {
				t.sendMessage(null, new Packet(null, 'device.triggerOnAppResumed', data.detail));
			});
		}
		if (typeof(geoAPI) != "undefined") this.geo = geoAPI;
		if (typeof(inputAPI) != "undefined") this.input = inputAPI;
		if (typeof(notesAPI) != "undefined") this.notes = notesAPI;
		if (typeof(bookmarkAPI) != "undefined") this.bookmarkAPI = bookmarkAPI;
		if (typeof(deepLinkAPI) != "undefined") this.deepLink = deepLinkAPI;
		if (typeof(imagePreviewerAPI) != "undefined") this.imagePreviewer = imagePreviewerAPI;

		if (typeof(bluetoothAPI) != "undefined") this.bluetooth = bluetoothAPI;
		if (typeof(BleCentralAPI) != "undefined") this.bleCentral = new BleCentralAPI();
		if (typeof (iBeaconAPI) != "undefined") this.iBeacon = iBeaconAPI;

        if (typeof(CameraAPI) != "undefined")             this.camera = new CameraAPI(this.context);
        if (typeof(fileManagerAPI) != "undefined")  this.fileManager = fileManagerAPI;
        if (typeof(imageCacheAPI) != "undefined")  this.imageCache = imageCacheAPI;

        if (typeof(PushNotificationsAPI) != "undefined") this.pushNotifications = new PushNotificationsAPI(this.context);

        if (typeof(FirebaseAPI) != "undefined") this.firebase = new FirebaseAPI(this.context);

		if (typeof(ComponentUIAPI) != "undefined") this.componentUI = new ComponentUIAPI(this.context);

        if (typeof(authAPI) != "undefined") {
			this.auth = authAPI;
			this.auth.init(this.context);
			var t = this;
			this.auth.onLogin(function (data) {
				t.sendMessage(null, new Packet(null, 'auth.triggerOnLogin', data.detail));
			});
			this.auth.onLogout(function () {
				t.sendMessage(null, new Packet(null, 'auth.triggerOnLogout'));
			});
		}

		if (typeof (richModal) != "undefined") {
			this.popup = richModal;
		}

		var t = this;
		this.mediaAPI = new Object();
		if (typeof(audioPlayer) != "undefined") {
			this.mediaAPI.audioPlayer = audioPlayer;

			this.mediaAPI.audioPlayer.onEvent(function (e) {
				t.sendMessage(null, new Packet(null, 'services.media.audioPlayer.triggerOnEvent', e));
			});
		}


		/*****************************************************/
		///should be placed somewhere else
		this.analytics.trackActionCommand = function (obj, callback) {
			if (!obj) {
				return false;
			}
			return t.analytics.trackAction(obj.value, obj.metadata, callback);
		};
		this.analytics.trackViewCommand = function (obj, callback) {
			if (!obj) {
				return false;
			}
			return t.analytics.trackView(obj.value, obj.metadata, callback);
		};
		/*****************************************************/


		this.navigation.pluginAPI = this;

        if(typeof(PublicFilesAPI) != "undefined") {
            this.publicFiles = new PublicFilesAPI(this.context);
            this.publicFiles.onProgress(function (files) {
                t.sendMessage(null, new Packet(null, 'services.publicFiles._triggerOnProgress', { file : files }));
            });

            this.publicFiles.onComplete(function (files) {
                t.sendMessage(null, new Packet(null, 'services.publicFiles._triggerOnComplete', { file : files }));
            });
        }

        if(typeof(searchEngineAPI) != "undefined") {
            this.searchEngine = new searchEngineAPI(this.context);
        }

        if(typeof(CreditsAPI) != "undefined") {
            this.credits = new CreditsAPI(this.context);
        }

        if(typeof(StripeAPI) != "undefined") {
            this.stripe = new StripeAPI(this.context);
        }
	}
	, postMessageHandler: function (e) {

		if (!this.iFrameId) return false;

		var req = undefined;

		try {
			req = e.packet || JSON.parse(e.data);
		}
		catch (err) {
			console.warn('error parsing post message data.');
			return;
		}

		if(!req
			|| !req.cmd
			|| !req.cmd.split)
			return;

		if (e.source != this.getContentWindow() && req.fid != this.iFrameId ///dont catch your own //e.source != window.parent && if buidfire.js sends back your id then its ok
			&& this.context.instanceId != req.instanceId) {
			return;
		} //none of hour business, ignore


		//console.log(this.tag, ' received << ', e.data, window.location.href);

		var t = this;
		var callback = function (err, result) {
			if (err) console.warn(e.data,err);
			var packet = new Packet(req.id, req.cmd, result, err);
			t.sendMessage(null, packet);
		};

		/// prone to error but thats ok
		var sequence = req.cmd.split('.');
		var obj = this;
		var parent = this;
		for (var i = 0; i < sequence.length; i++) {
			if (i > 0)parent = obj;
			if (obj[sequence[i]])
				obj = obj[sequence[i]];
			else {
				return true; // cant handle request but request was for me
			}

		}
		//console.log("PluginAPI", this.tag, "execute command", req.cmd);
		obj.apply(parent, [req.data, callback]);
		return true;
	}
	, sendMessage: function (destination, packet) {
		//if(!destination)
		destination = this.getContentWindow();

		if (destination && destination.postMessage) {
			//if (typeof(packet) != "string")	packet = JSON.stringify(packet);
			//console.log(this.tag, ' sent >> ', packet, window.location.href);
			packet = JSON.parse(JSON.stringify(packet)); // avoid 'object could not be cloned'
			destination.postMessage(packet, '*');
		}
	}
	, getContext: function (data, callback) {
        let context = Object.assign({}, this.context); // shallow copy
		if (typeof appApiKeys != 'undefined') {
			//app
            appApiKeys.get(function(err, keys) {
                context.apiKeys = keys || {}; // attach to the copy only to discourage using context.apiKeys since it might be null initially
                if(callback)callback(null, context);
            });
		} else {
			// cp
            if (window.appContext &&  window.appContext.currentApp && window.appContext.currentApp.apiKeys) {
                context.apiKeys = window.appContext.currentApp.apiKeys || {};
            }
            if(callback)callback(null, context);
		}
        return this;
	}
	, navigation: {
		displayPopUpInstructions : function(){
            window.location.hash = '/popUp';
		}
		, _navigateTo: function (pluginData, callback) {
			if (!(pluginData.pushToHistory === false)) {
				pluginData.pushToHistory = true;
			}
			var samePluginNavigation = false;
			var hash = '/pluginContainer/' + pluginData.pluginId + '/' + pluginData.instanceId + '/' + encodeURIComponent(pluginData.title) + '/'
				+ pluginData.folderName + '/' + pluginData.pushToHistory; // + (pluginData.query  ? ('?' + pluginData.query) : '' );
			var historyAPI = new HistoryAPI();
			if (!pluginData.pushToHistory) {
				historyAPI.popToHome(); // clear to start new breadcrumbs
			}
			if (historyAPI.historyItems.length == 0) {
				historyAPI.push({label: "Home", options: {pluginData: undefined}, source: "home"});
			}
			if (historyAPI.historyItems.length == 1 && postMaster.launcherPluginAPI
				&& pluginData.instanceId == postMaster.launcherPluginAPI.context.instanceId
				&& pluginData.pluginId == postMaster.launcherPluginAPI.context.pluginId) {
				// already on home
			}
			else {
				var currentBreadcrumb = historyAPI.historyItems[historyAPI.historyItems.length - 1];
				if (currentBreadcrumb.source == 'control') {
					if (pluginData.instanceId != currentBreadcrumb.options.pluginData.instanceId ||
						pluginData.pluginId != currentBreadcrumb.options.pluginData.pluginId)
						historyAPI.push({
							label: decodeURIComponent(pluginData.title),
							options: {pluginData: pluginData, context: window.location.href},
							source: "control"
						});
					else {
						samePluginNavigation = true;
					}
				} else {

					var label ;
					try {
						label = decodeURIComponent(pluginData.title);
					}
					catch(e){
						console.error('BAD Title',pluginData.title,e);
						label = 'TITLE';
					}

					historyAPI.push({
						label: label,
						options: {pluginData: pluginData, context: window.location.href},
						source: "control"
					});
				}

			}

			/// push any data that the user wants to send to the next plugin in here
			/// the pluginCtrl will pop it and pass it along to the next plugin
			if(pluginData && pluginData.queryString)
                window.pluginControllerHelper.pluginPassThroughqueryString  =pluginData.queryString;

			if (pluginData && (pluginData.dontTriggerHashChangeEvent || samePluginNavigation))
				cpSync.navigation.silentNavigation(hash);
			else
				window.location.hash = hash;
			if (callback)callback(null, {status: 'completed'});
		}
		, navigateTo: function (pluginData, callback) {

            if(pluginData && pluginData.pluginId && pluginData.instanceId && pluginData.title && pluginData.folderName) {
            	// we have everything we need
            	this._navigateTo(pluginData, callback);
            	return;
			}

            if(!pluginData || (!pluginData.pluginId && !pluginData.instanceId && !pluginData.folderName)) {
                callback('either pluginId, instanceId or folderName must be specified', false);
                return;
            }

            var that = this;

            var dsPluginInstance = new DatastoreAPI(appContext.currentApp.appId, "pluginInstances", 1, appContext.liveMode);
            var options = {};
            options.obj = {
                filter: {},
                pageSize: 1,
                withDynamicData: true
            };

            if(pluginData.instanceId) {
                options.obj.filter["$json.instanceId"] = pluginData.instanceId;
            }
            if (pluginData.pluginId) {
                options.obj.filter["$json.token"] = pluginData.pluginId;
            }

            dsPluginInstance.search(options, function (err, result) {
                if (err) {
                    callback('error fetching pluginInstance', false);
                } else if(result && result.length ){
                    var instanceId = result[0].data.instanceId;
                    var token = result[0].data._buildfire.pluginType.result[0].token;
                    var folderName = result[0].data._buildfire.pluginType.result[0].folderName;
                    var title = result[0].data.title;
                    that._navigateTo({
                        pluginId: token
                        , instanceId: instanceId
                        , title: pluginData.title || title
                        , folderName: folderName
                        , pushToHistory: pluginData.pushToHistory
                        , queryString : pluginData.queryString
                    }, callback);
                } else {
                    if(callback)
                        callback('pluginInstance not found', false);
                }
            });
        }
		,
		// params:
		// .instanceId
		// .data (optional)
		navigateToPluginInstance: function(params, callback){
			var that = this;

			if(! params || ! params.instanceId){
				callback("Invalid parameters. Need to pass instanceId.");
				return;
			}

			var dsPluginInstance = new DatastoreAPI(appContext.currentApp.appId, "pluginInstances", 1, appContext.liveMode);
			var options = {};
			options.obj = {
				filter: {"$json.instanceId": params.instanceId},
				pageSize: 1,
				withDynamicData: true
			};
			dsPluginInstance.search(options, function (err, result) {
				if (err) {
					callback('error fetching pluginInstance', false);
				} else if(result && result.length ){
					var token = result[0].data._buildfire.pluginType.result[0].token;
					var folderName = result[0].data._buildfire.pluginType.result[0].folderName;
					var title = result[0].data.title;
					//var pluginAPI =  window.appContext.currentPlugin  ? window.appContext.currentPlugin.pluginAPI :window.postMaster.launcherPluginAPI ;
					//if(pluginAPI) {
						that._navigateTo({
							pluginId: token
							, instanceId: params.instanceId
							, title: title
							, folderName: folderName
							, pushToHistory: false
							, queryString : params.queryString
						}, callback);
					//}
				} else {
					if(callback)
						callback('pluginInstance not found', false);
				}
			});
		}
		, navigateToAppearance: function (options) {
			if (options && options.dontTriggerHashChangeEvent)
				cpSync.navigation.silentNavigation('/appearanceSample');
			else
				window.location.hash = '/appearanceSample';

		}
		, navigateHome: function (options, callback) {
			if (options && options.dontTriggerHashChangeEvent)
				cpSync.navigation.silentNavigation('/');
			else
				window.location.hash = '/';
			var historyAPI = new HistoryAPI();
			historyAPI.clear(); // clear to start new breadcrumbs
			historyAPI.push({label: "Home", options: {pluginData: undefined}, source: "home"});
			if (callback) callback();
		}
		, navigateBack: function () {
			var historyAPI = new HistoryAPI();
			var me = this;
			if (historyAPI.historyItems && historyAPI.historyItems.length > 1) {
				var poppedBreadcrumb = historyAPI.historyItems[historyAPI.historyItems.length - 1];
				var previousBreadcrumb = historyAPI.historyItems[historyAPI.historyItems.length - 2];
				if (previousBreadcrumb && previousBreadcrumb.options) {
					switch (previousBreadcrumb.source) {
						case 'control':
							var pluginData = null;
							if(poppedBreadcrumb.source == 'plugin') {
								historyAPI.pop(previousBreadcrumb);
								if (previousBreadcrumb.options.pluginData) {
									pluginData = JSON.parse(JSON.stringify(previousBreadcrumb.options.pluginData)); // clone pluginData
									me._navigateTo(pluginData);
								}
							}
							else {
								// navigate then pop when navigating from a plugin to another to compare that plugin has changed
								if(previousBreadcrumb.options.pluginData) {
									pluginData = JSON.parse(JSON.stringify(previousBreadcrumb.options.pluginData)); // clone pluginData
									me._navigateTo(pluginData);
								}
								historyAPI.pop(previousBreadcrumb);
							}
							break;
						case 'plugin':
							if (poppedBreadcrumb.source == 'control') {
								// must be launcher breadcrumbs
								if(window.location.protocol.indexOf('http') < 0) {
									// on device just bring the user back to the launcher plugin as is
									historyAPI.pop(previousBreadcrumb);
									window.location.hash = '/';
								}
								else {
									// if your on CP reset the launcher plugin so that the emulator is in sync with the reloaded content area
									historyAPI.clear(); // clear to start new breadcrumbs
									historyAPI.push({label: "Home", options: {pluginData: undefined}, source: "home"});
									window.location.hash = '/';
								}
							} else {
								historyAPI.pop(previousBreadcrumb);
							}
							break;
						case 'home':
							if(poppedBreadcrumb.source == 'plugin'){
								// still on home
								historyAPI.pop(previousBreadcrumb);
								break;
							}
						// continue to default
						default:
							historyAPI.clear(); // clear to start new breadcrumbs
							historyAPI.push({label: "Home", options: {pluginData: undefined}, source: "home"});
							window.location.hash = '/';
					}
				}
			} else {
				historyAPI.clear(); // clear to start new breadcrumbs
				historyAPI.push({label: "Home", options: {pluginData: undefined}, source: "home"});
				window.location.hash = '/';
			}
		}
		, scrollTop: function (val, callback) {
			document.body.scrollTop = val ? val : 0;
			if (callback)callback();
		}
		, navigateEmulator: function () {
			if(!cordova ||
				!cordova.file
				|| !cordova.file.applicationDirectory) {
                console.log("Cant load emulator bc cordova.file.applicationDirectory is undefined");
                return;
            }

            if( !window.appContext
                || !window.appContext.environment) {
                console.log("Cant load emulator bc window.appContext.environment is undefined");
                return;
            }


			if (window.location.href.indexOf('http://') < 0)
				window.location.href = cordova.file.applicationDirectory + 'www/emulator/login.html?env=' + window.appContext.environment + '&lastUrl=' + encodeURIComponent(window.location.href);

		}
		, navigateToApp: function (options) {
			/// dont expose. used internally
			window.location.search = '?env=' + window.appContext.environment + '&appId=' + options.appId + '&mode=' + window.appContext.currentApp.liveMode + '&lastUrl=' + encodeURIComponent(window.location.href);
		}
	}
	, messaging: {
		triggerOnNewControlMessage: function (message) {
			console.warn('unhandled message [onNewControlMessage]');
		}
		, triggerOnNewWidgetMessage: function (message) {
			/*console.warn('unhandled message [onNewWidgetMessage]');*/
			var packet = new Packet(null, 'messaging.onReceivedMessage', message);
			if (postMaster.widgetPluginAPI)postMaster.widgetPluginAPI.sendMessage(null, packet);
			else postMaster.launcherPluginAPI.sendMessage(null, packet);
		}
		//send message from widget to current widget service
		, sendMessageToService: function (message, callback) {
            var currentPlugin = postMaster.widgetPluginAPI;
            if (!currentPlugin) {
                currentPlugin = postMaster.launcherPluginAPI;
            }
            if (currentPlugin && currentPlugin.context && postMaster.servicePluginAPIs) {
                var servicePluginAPI = postMaster.servicePluginAPIs[currentPlugin.context.instanceId];
                if (servicePluginAPI && servicePluginAPI.sendMessage) {
                    var packet = new Packet(null, "messaging.onReceivedMessage", message);
                    servicePluginAPI.sendMessage(null, packet);

                    if (callback) {
                        callback(null, true);
                    }
                }
            }
            if (callback) {
                callback('no service available for current widget', null);
            }
		}
	}
	, spinner: {
		show: function (data,callback) {

			if(window.spinner)window.spinner.show();
			if(callback)callback();
		}
		, hide: function (data,callback) {
			if(window.spinner)window.spinner.hide();
			if(callback)callback();
		}
	}

};



"use strict";
/**
 * Created by Daniel on 3/30/2015.
 */


var geoAPI = {
    currentPosition: null,
    convertPosition: function(position){
        var p = {
            coords: {
                latitude: position.coords.latitude
                , longitude: position.coords.longitude
                , altitude: position.coords.altitude
                , accuracy: position.coords.accuracy
                , altitudeAccuracy: position.coords.altitudeAccuracy
                , heading: position.coords.heading
                , speed: position.coords.speed

            }
            , timestamp: position.timestamp
            , isBackground: (position.isBackground) ? position.isBackground : false
        };
        return p;
    }
    , convertBackGroundPosition : function(position){
        var p = {
            coords: {
                latitude: position.latitude
                , longitude: position.longitude
                , altitude: position.altitude
                , accuracy: position.accuracy
                , speed: position.speed

            }
            , timestamp: position.time
            , isBackground: true
        };
        return p;
    }
    ,getCurrentPosition: function (options,callback) {

        if(navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(function(position) {
                    callback(null, geoAPI.convertPosition(position));
                }
                ,onError
                ,options
            );
        }
        else {
            console.error("navigator.geolocation is undefined");
        }

        return this;

        function onError(error) {
            /**
             * If getCurrentPosition failed, but a position
             * was already fetched by watchPosition
             * use the cached position
             */
            if (useCache()) {
                callback(null, geoAPI.currentPosition)
            } else {
                callback(error, null);
            }
        }

        function useCache() {
            /**
             * if no cached position, return false
             * if maximum age is not specified, or
             * the age of the cache is under the
             * maximum age, return true
             * */ 
            if (!geoAPI.currentPosition) return false;
            else if (!options.maximumAge) return true;
            else if (Date.now() - geoAPI.currentPosition.timestamp < options.maximumAge) return true;
        }
    }
    ,isAndroid : false
    ,watchPosition: function(options,callback){
        function gotPosition(p) {
            p = geoAPI.convertPosition(p);
            p.watchId = watchId;
            // cache the fetched position
            geoAPI.currentPosition = p;

            var debugInfo = 'location: ' + p.coords.latitude + ',' + p.coords.longitude
                + ' ,isBackground: ' + p.isBackground + ' ' + new Date();
            console.log(debugInfo);

            var packet = new Packet(null,'geo.onPositionChange',p);
            postMaster.broadcast(packet);
        }

        function onError(error) {
            console.log('Geo watchPosition: ', error.message);
            error.watchId = watchId;
            callback(error);
        }

        var watchId;

        if(navigator.geolocation && navigator.geolocation.watchPosition) {
             watchId = navigator.geolocation.watchPosition(
                gotPosition,
                onError,
                options);

             var bgSuccess = function(location){
                 gotPosition(geoAPI.convertBackGroundPosition(location));

                 //backgroundGeolocation.finish();
             };

             var bgFailure = function(error){
                 console.error('Background geo error', error);
             };

            var onDeviceReadyBGLocation  = function() {
                // var isAndroid = (navigator.platform.indexOf("Android") != -1
                //     || navigator.platform.indexOf("Linux") != -1
                //     || navigator.platform == null);

                //Only run custom background logic for Android
                // if(!isAndroid){
                //     return;
                // }

                // as of mauron85/cordova-plugin-background-geolocation v 3.x it was changed from
                // backgroundGeolocation to BackgroundGeolocation
                if(typeof BackgroundGeolocation === 'undefined' && typeof backgroundGeolocation === 'undefined'){
                    return;
                }

                if(typeof cordova !== 'undefined' && cordova.plugins && cordova.plugins.backgroundMode) {
                    if(cordova.plugins.backgroundMode.enable) {
                        cordova.plugins.backgroundMode.enable();
                    }
                    cordova.plugins.backgroundMode.on('activate', function () {
                        cordova.plugins.backgroundMode.disableWebViewOptimizations();
                    });
                }

                if(typeof backgroundGeolocation === 'undefined'){
                    // use >= 3.x implementation

                    BackgroundGeolocation.configure({
                        locationProvider: BackgroundGeolocation.ACTIVITY_PROVIDER,
                        desiredAccuracy: BackgroundGeolocation.HIGH_ACCURACY,
                        stationaryRadius: 1,
                        distanceFilter: 1,
                        debug: false,
                        interval: 10000,
                        fastestInterval: 5000,
                        activitiesInterval: 10000
                    });

                    BackgroundGeolocation.on('location', bgSuccess);
                    BackgroundGeolocation.on('error', bgFailure);
                    BackgroundGeolocation.on('authorization', function(status) {
                        console.log('[INFO] BackgroundGeolocation authorization status: ' + status);
                        if (status !== BackgroundGeolocation.AUTHORIZED) {
                            // we need to set delay or otherwise alert may not be shown
                            // setTimeout(function() {
                            //     var showSettings = confirm('App requires location tracking permission. Would you like to open app settings?');
                            //     if (showSettings) {
                            //         return BackgroundGeolocation.showAppSettings();
                            //     }
                            // }, 1000);
                        }
                    });
                    
                    BackgroundGeolocation.checkStatus(function(status) {
                        console.log('[INFO] BackgroundGeolocation service is running', status.isRunning);
                        console.log('[INFO] BackgroundGeolocation services enabled', status.locationServicesEnabled);
                        console.log('[INFO] BackgroundGeolocation auth status: ' + status.authorization);

                        // you don't need to check status before start (this is just the example)
                        if (!status.isRunning) {
                            BackgroundGeolocation.start(); //triggers start on start event
                        }
                    });

                } else {
                    backgroundGeolocation.configure(bgSuccess, bgFailure, {
                        desiredAccuracy: 0,
                        stationaryRadius: 1,
                        distanceFilter: 1,
                        interval: 1000,
                        locationProvider: backgroundGeolocation.provider.ANDROID_ACTIVITY_PROVIDER
                        //ANDROID_DISTANCE_FILTER_PROVIDER
                    });
                    backgroundGeolocation.start();
                }
            };

            if (bfUtils.isMobileDevice) {
                appState.subscribe({state: appState.RUNNING}, onDeviceReadyBGLocation);
            }
        }
        else{
            console.log('HTML5 position');
            watchId = setInterval(function(){geoAPI.getCurrentPosition(options,function(e,p){
                if(e)onError(e);
                else gotPosition(p);
            })}
                , options && options.timeout?options.timeout:5000);
        }
        callback();

    }
    ,clearWatch: function(watchId,callback){
        if(navigator.geolocation && navigator.geolocation.watchPosition)
            navigator.geolocation.clearWatch(watchId);
        else
            clearInterval(watchId);

        if(callback)callback();
    }
};


var inputAPI = {

  /**
   * Know if the api has been initialized already or not
   * @type {Boolean}
   */
  initialized: false,

  timer: null,
  currentStepData: null,
  currentStepOptions: null,

  /**
   * Initialize the api by creating the dialog we are going to be using
   * @return {[type]} [description]
   */
  init: function () {

    if (this.inputDialog) {
      this.inputDialog.innerHTML = '';
    } else {
      this.inputDialog = document.createElement('div');
      this.inputDialog.style.display = 'none';
    }

    if (this.listDialog) {
      this.listDialog.innerHTML = '';
    } else {
      this.listDialog = document.createElement('div');
      this.listDialog.style.display = 'none';
    }

    if (this.backdrop) {
      this.backdrop.className = '';
    } else {
      this.backdrop = document.createElement('div');
      this.backdrop.id = 'input-backdrop';
    }

    if (window.location.pathname.indexOf('pluginTester') >= 0) {
      this.inputDialog.style.height = document.getElementById('app').offsetHeight + 'px';
      this.inputDialog.style.position = 'absolute';

      this.listDialog.style.height = document.getElementById('app').offsetHeight + 'px';
      this.listDialog.style.position = 'absolute';
    } else {
      this.inputDialog.style.height = '100vh';
      this.inputDialog.style.maxHeight = '100vh';

      this.listDialog.style.height = '100vh';
      this.listDialog.style.maxHeight = '100vh';
    }

    //----------------// DIALOG BODY, NAV, USER AND TEXT AREA //----------------//
    const footerMenu = localStorage.getItem('footerMenu');

    this.inputDialog.id = 'inputDialog';
    this.inputDialog.className = footerMenu ? 'has-footer-menu' : '';

    const wrapper = document.createElement('div');
    wrapper.className = 'input-dialog-container backgroundColorTheme';
    this.inputDialog.appendChild(wrapper);

    this.dialogNav = document.createElement('div');
    this.dialogNav.className = 'inputapi-nav titleBarBackgroundTheme';
    wrapper.appendChild(this.dialogNav);
    
    this.dialogNavFlex = document.createElement('div');
    this.dialogNavFlex.className = 'inputapi-nav-flex';
    this.dialogNav.appendChild(this.dialogNavFlex);

    this.dialogNavSecondary = document.createElement('div');
    this.dialogNavSecondary.className = 'inputapi-nav secondary titleBarBackgroundTheme';
    wrapper.appendChild(this.dialogNavSecondary);

    this.dialogNavFlexSecondary = document.createElement('div');
    this.dialogNavFlexSecondary.className = 'inputapi-nav-flex secondary';
    this.dialogNavSecondary.appendChild(this.dialogNavFlexSecondary);

    this.currentUserContainer = document.createElement('div');
    this.currentUserContainer.className = 'inputapi-user-container';
    wrapper.appendChild(this.currentUserContainer);

    this.textarea = document.createElement('textarea');
    this.textarea.className = 'inputapi-textarea needsfocus';
    this.textarea.addEventListener('touchend', (e) => {
      e.target.click();
    });
    this.textarea.addEventListener('focus', ({ target }) => {
      target.style.webkitTransform = 'translate3d(0px,-10000px,0)';
      requestAnimationFrame(() => target.style.webkitTransform = '');
    });
    this.textarea.addEventListener('input', (e) => {
      this.currentStepData.textValue = e.target.value;
      if (this.currentStepData.textValue.length > this.currentStepOptions.maxLength) {
        this.currentStepData.textValue = this.currentStepData.textValue.substring(0, this.currentStepOptions.maxLength);
        e.target.value = this.currentStepData.textValue;
      }

      this.doneButton.disabled = !this.validate();
    });
    wrapper.appendChild(this.textarea);

    //------------------------// IMAGE GALLERY AND GEO //-----------------------//
    this.imageGallery = document.createElement('div');
    this.imageGallery.id = 'imageGallery';

    this.geoContainer = document.createElement('div');
    this.geoContainer.id = 'geo-container';
    this.geoContainer.classList = 'img-gallery-container';
    this.geoContainer.style.display = 'none';

    this.geoImage = document.createElement('img');
    this.geoImage.id = 'geo-img';
    this.geoContainer.appendChild(this.geoImage);
    
    this.geoDeleteBtn = document.createElement('span');
    this.geoDeleteBtn.className = 'galery-delete glyphicon glyphicon-minus-sign';
    this.geoDeleteBtn.onclick = () => this.setLocation();

    this.geoContainer.appendChild(this.geoDeleteBtn);
    this.imageGallery.appendChild(this.geoContainer);
    wrapper.appendChild(this.imageGallery); 

    //------------------------// NAV BUTTONS AND TITLE //------------------------//
    this.cancelButton = document.createElement('button')
    this.cancelButton.className = 'inputapi-cancel titleBarTextAndIcons';
    this.dialogNavFlex.appendChild(this.cancelButton);

    this.title = document.createElement('h1');
    this.title.className = 'inputapi-nav-title primary titleBarTextAndIcons ellipsis';
    this.title.style.whiteSpace = 'nowrap';
    this.dialogNavFlex.appendChild(this.title);

    this.titleSecondary = document.createElement('h1');
    this.titleSecondary.className = 'inputapi-nav-title secondary titleBarTextAndIcons ellipsis';
    this.titleSecondary.style.whiteSpace = 'nowrap';
    this.dialogNavFlexSecondary.appendChild(this.titleSecondary);

    this.doneButton = document.createElement('button')
    this.doneButton.className = 'inputapi-done titleBarTextAndIcons';
    this.dialogNavFlex.appendChild(this.doneButton);

    //--------------------------------// FOOTER //-------------------------------//
    this.actionFooter = document.createElement('div');
    this.actionFooter.className = 'inputapi-footer';
    wrapper.appendChild(this.actionFooter);

    //--------------------------------// CAMERA //-------------------------------//
    this.cameraBtn = document.createElement('span');
    this.cameraBtn.className = 'icon icon-camera2 needsclick';
    this.cameraBtn.onclick = e => this.showFileDialog();
    this.actionFooter.appendChild(this.cameraBtn);

    //-------------------------------// GEO PIN //-------------------------------//
    this.geoPin = document.createElement('span');
    this.geoPin.id = 'goc-pin';
    this.geoPin.className = 'icon icon-map-marker';
    this.geoPin.onclick = e => this.showLocationModal();
    this.actionFooter.appendChild(this.geoPin);

    //-------------------------------// GIF ICON //-------------------------------//
    this.gifBtn = document.createElement('span');
    this.gifBtn.className = 'icon icon-gif';
    this.gifBtn.id = 'gif-btn';
    this.gifBtn.onclick = e => this.showGifDialog();
    this.actionFooter.appendChild(this.gifBtn);

    //------------------------------// LIST DIALOG //-----------------------------//

    this.listDialog.id = 'listDialog';

    const listDialogBody = document.createElement('div');
    listDialogBody.className = 'body';
    this.listDialog.appendChild(listDialogBody);

    this.listDialogHeader = document.createElement('div');
    this.listDialogHeader.className = 'list-header';
    listDialogBody.appendChild(this.listDialogHeader);

    this.listDialogItems = document.createElement('form');
    this.listDialogItems.className = 'list-items';
    listDialogBody.appendChild(this.listDialogItems);

    const listDialogBtnRow = document.createElement('div');
    listDialogBtnRow.className = 'btn-row';
    listDialogBody.appendChild(listDialogBtnRow);

    this.listDialogCancelBtn = document.createElement('button');
    this.listDialogCancelBtn.className = 'cancel';
    listDialogBtnRow.appendChild(this.listDialogCancelBtn);

    this.listDialogConfirmBtn = document.createElement('button');
    this.listDialogConfirmBtn.className = 'confirm';
    listDialogBtnRow.appendChild(this.listDialogConfirmBtn);

    if (window.location.pathname.indexOf('pluginTester') >= 0) {
      document.getElementById('app').appendChild(this.inputDialog);
      document.getElementById('app').appendChild(this.listDialog);
      document.getElementById('app').appendChild(this.backdrop);
    } else {
      document.body.appendChild(this.inputDialog);
      document.body.appendChild(this.listDialog);
      document.body.appendChild(this.backdrop);
    }

    this.initialized = true;
  },

  /**
   * @method showLocationModal
   * calls @method getLocation and
   * constructs mapUrl and displays
   * a modal. Modal confirm calls
   * @method setLocation to save location
   */
  showLocationModal: function () {
    window.spinner && window.spinner.show();
    this.getLocation((err, result) => {
      try {
        if (err) throw err;
        const { latitude, longitude } = result.coords;
        const { mapUrl, thumbnail } = this.getMapUrl(result);

        if (this.currentStepOptions.attachments.location.required) {
          window.spinner && window.spinner.hide();
          this.geoDeleteBtn.style.display = 'none';
          return this.setLocation({ latitude, longitude }, thumbnail);
        }

        const title = 'Send My Current Location';
        const richContent = `
          <img style="height: 90vw !important; width: 90vw !important" src="${mapUrl}" />
        `;
        const action = {
          title: 'Confirm',
          handler: () => this.setLocation({ latitude, longitude }, thumbnail)
        };

        const modalOptions = { title, richContent, action };

        window.spinner && window.spinner.hide();
        richModal.display(modalOptions);

      } catch (error) {
        console.error('inputAPI location error', error);

        let title = 'Could not determine location';
        let richContent = 'Failed to determine location. Please try again later.';

        if (error.code) {
          switch (error.code) {
            case 1: {
              richContent = 'App does not have location access.';
              break;
            }
            case 2: {
              richContent = 'Location information is not availible to this device.';
              break;
            }
            case 3: {
              richContent = 'Location request timed out. Try again.';
              break;
            }
            case 4: {
              richContent = 'Failed to determine location. Please try again later (code 4)';
              break;
            }
            case 5: {
              richContent = 'This app does not have access to this feature.';
              break;
            }
            default: {
              break;
            }
          }
        }

        const modalOptions = { title, richContent };
        richModal.display(modalOptions);
        window.spinner && window.spinner.hide();
      }
    });
  },

  /**
   * @method getLocation
   * calls geoAPI to get location
   * @param {Function} callback (err, result)
   * @throws {Error} if geoAPI is not defined
   */
  getLocation: callback => {
    let error = null;
    let googleMapKey = null;

      appApiKeys.get(function(err, keys){
          googleMapKey = keys.googleMapKey;

          if (!googleMapKey) {
              error = new Error('no google API key');
              error.code = 5;
          }
          if (!error && typeof geoAPI != 'object') {
              error = new Error('geoAPI not defined');
              error.code = 4;
          }
          if (error) {
              callback(error, null);
          } else {
              const options = { timeout: 10000 };
              geoAPI.getCurrentPosition(options, (err, result) => {
                  if (result) result.googleMapKey = googleMapKey;
                  callback(err, result);
              });
          }
      });
  },

  /**
  * @method setLocation
  * Sets or resets the location.
  * If either parameter is omitted
  * resets the location.
  * @param {object} loc geo response
  * @param {string} thumbnail map thumbnail url
  */
  setLocation: function (loc, thumbnail) {
    if (loc && thumbnail) {
      this.currentStepData.location = loc;
      this.geoContainer.style.display = 'block';
      this.geoImage.src = thumbnail;
    } else {
      this.currentStepData.location = {};
      this.geoContainer.style.display = 'none';
      this.geoImage.removeAttribute('src');
    }
    this.doneButton.disabled = !this.validate();
  },

  getMapUrl: data => {
    const { latitude, longitude } = data.coords;
    const { googleMapKey } = data;

    const baseUrl = 'https://maps.googleapis.com/maps/api/staticmap';
    const size = `size=${window.innerWidth}x${window.innerWidth}`;
    const mapOptions = `zoom=15&${size}&maptype=roadmap&key=${googleMapKey}`;
    const center = `center=${latitude},${longitude}`;
    const marker = `markers=color:blue|size:large|${latitude},${longitude}`;

    const mapUrl = `${baseUrl}?${center}&${marker}&${mapOptions}`;

    let thumbnail = mapUrl
      .replace(/size:large/g, 'size:mid')
      .replace(/size=\d{1,4}x\d{1,4}/g, 'size=100x100')
      .replace(/zoom=15/g, 'zoom=12');
    
    return { mapUrl, thumbnail };
  },

  /**
   * @method showGifDialog
   * opens the gif dialog and
   * returns the results
   */
  showGifDialog: function () {
    if (typeof gifAPI != 'object') return;
    const { multiple, rating } = this.currentStepOptions.attachments.gifs;

    const _add = gif => {
      const imagesLength = this.currentStepData.images.length;
      const gifsLength = this.currentStepData.gifs.length;

      if (imagesLength + gifsLength >= 6) return;
      
      this.currentStepData.gifs.push(gif);

      let image = '';
      
      if (!bfUtils.isIOS) {
        image = gif.images.downsized_medium.url || gif.images.original.url;
      } else {
        image = gif.images.preview.mp4 || gif.images.gif.downsized_small.mp4;
      }
      this.addToGallery(image, 'gifs');
    }

    const handleGifResponse = (error, response) => {
      if (error || !response) return;
      const { cancelled, results } = response;

      if (cancelled || !results || !results.length) return;
      
      if (multiple) {
        response.results.forEach(gif => _add(gif));
      } else {
        this.currentStepData.gifs = [];

        const element = document.getElementById(`gifs_0`);
        if (element) {
          this.imageGallery.removeChild(element);
        }

        const gif = response.results[0];
        _add(gif);
      }
    };

    gifAPI.showGifDialog({ multiple, rating }, handleGifResponse);
  },

  showFileDialog() {
    let fileApi = new PublicFilesAPI(window.appContext.currentApp);

    // Monkeypatch fileApi instance
    fileApi._onComplete = (resultFile) => {
      if (resultFile.status === 'success') {
        const { images, gifs } = this.currentStepData;

        const imagesLength = images ? images.length : 0;
        const gifsLength = gifs ? gifs.length : 0;

        if (gifsLength + imagesLength >= 6) return;

        this.currentStepData.images.push(resultFile.url);
        this.addToGallery(resultFile.url, 'images');
      } else {
        console.error('Image upload failed - inputAPI', resultFile);
      }
    }

    fileApi._onProgress = () => {
      if (window.spinner) window.spinner.show();
      this.doneButton.disabled = true;
    };

    const { multiple } = this.currentStepOptions.attachments.images;
    const allowMultipleFilesUpload = multiple || false;

    fileApi.showDialog({ allowMultipleFilesUpload }, () => {
      if (window.spinner) setTimeout(window.spinner.hide.bind(null, true), 300);

      this.doneButton.disabled = this.currentStepOptions.required
        && (this.currentStepData.textValue && !this.currentStepData.textValue.length)
        ? true : false;
    });
  },

  addToGallery(url, type) {
    const index = this.currentStepData[type].length - 1;

    const itemContainer = document.createElement('div');
    itemContainer.className = `img-gallery-container animated fadeInUp ${type}`;
    itemContainer.id = `${type}_${index}`;

    const deleteBtn = document.createElement('span');
    deleteBtn.className = 'galery-delete glyphicon glyphicon-minus-sign';
    deleteBtn.onclick = () => {
      this.removeFromGallery(index, type);
    }
    itemContainer.appendChild(deleteBtn);

    if (type === 'images' && typeof (imageTools) != 'undefined') {
      var options = {
        size: 's',
        aspect: '1:1',
        compression: 50
      };
      url = imageTools.cropImage(url, options);
    }

    const item = document.createElement('img');
    item.setAttribute('src', url);
    
    item.className = `img-gallery-item ${type}`;
    itemContainer.appendChild(item);
    this.imageGallery.appendChild(itemContainer);

    const { images, gifs } = this.currentStepData;
    const imagesLength = images ? images.length : 0;
    const gifsLength = gifs ? gifs.length : 0;

    if (gifsLength + imagesLength > 5) {
      this.cameraBtn.classList.add('disabled');
      this.gifBtn.classList.add('disabled');
    };
  },

  removeFromGallery(index, type) {
    this.currentStepData[type].splice(index, 1);

    const element = document.getElementById(`${type}_${index}`);
    if (element) {
      this.imageGallery.removeChild(element);
    }

    const { images, gifs } = this.currentStepData;
    const imagesLength = images ? images.length : 0;
    const gifsLength = gifs ? gifs.length : 0;

    if (gifsLength + imagesLength < 6) {
      this.cameraBtn.classList.remove('disabled');
      this.gifBtn.classList.remove('disabled');
    };
  },

  renderStep(stepOptions, handleCancel, handleNext) {
    //------------------ reset step data ------------------//
    this.currentStepData = {
      textValue: stepOptions.defaultValue || '',
      images: [],
      location: {},
      gifs: []
    };
    stepOptions.maxLength = stepOptions.maxLength || 2000;
    this.currentStepOptions = stepOptions;

    //-------------------  reset nav bar -------------------//
    this.title.innerHTML = stepOptions.title || '';
    this.titleSecondary.innerHTML = stepOptions.title || '';
    
    //-------------- reset attachment buttons ---------------//
    const { location, images, gifs } = this.currentStepOptions.attachments;

    var hasAttachments = false;
    
    ['images', 'gifs', 'location'].forEach(key => {
      if (stepOptions.attachments[key] && stepOptions.attachments[key].enable) {
        if (!stepOptions.attachments[key].required) hasAttachments = true;
      }
    });

    this.actionFooter.style.display = hasAttachments
      ? 'flex' : 'none';

    this.cameraBtn.style.display = images.enable && this.currentStepData.images.length < 6
      ? 'block' : 'none';

    this.geoPin.style.display = location.enable && !location.required
      ? 'block' : 'none';

    this.gifBtn.style.display = gifs.enable
      ? 'block' : 'none';

    //----------------- reset user container -----------------//
    this.currentUserContainer.innerHTML = '';
    var user = authAPI.getCurrentUser();
    console.log('Renering inputAPI for user', user);
    this.userImage = document.createElement('img');
    if (user && user.imageUrl) {
      if (typeof (imageTools) != 'undefined') {
        var options = {
          size: 'xs',
          aspect: '1:1',
          compression: 70
        };
        this.userImage.src = imageTools.cropImage(user.imageUrl, options);
      } else {
        this.userImage.src = user.imageUrl;
      }
    } else {
      this.userImage.src = 'https://pluginserver.buildfire.com/styles/media/avatar-placeholder.png';
    }
    this.userImage.className = 'inputapi-user-image';
    this.currentUserContainer.appendChild(this.userImage);
    this.userTitle = document.createElement('h1');
    this.userTitle.className = 'inputapi-user-title';
    if (user && user.displayName) {
      this.userTitle.innerHTML = user.displayName;
    }
    this.currentUserContainer.appendChild(this.userTitle);

    //------------------- reset text area -------------------//
    this.textarea.placeholder = stepOptions.placeholder || 'Type something...';
    this.textarea.maxLength = stepOptions.maxLength || 2000;
    this.textarea.value = stepOptions.defaultValue
      ? stepOptions.defaultValue.substring(0, this.textarea.maxLength) : '';

    //---------- build button texts for app to web ----------//
    const doneButtonText = document.createElement('div');
    doneButtonText.className = "btn-txt primary";
    doneButtonText.innerHTML = stepOptions.saveText ? stepOptions.saveText :
    (stepOptions._buffer.length ? 'Next' : 'Done');

    const doneButtonTextSecondary = document.createElement('div');
    doneButtonTextSecondary.className = "btn-txt secondary iconsTheme";
    doneButtonTextSecondary.innerHTML = stepOptions.saveText ? stepOptions.saveText :
    (stepOptions._buffer.length ? 'Next' : 'Done');

    const cancelButtonText = document.createElement('div');
    cancelButtonText.className = "btn-txt primary";
    cancelButtonText.innerHTML = stepOptions.cancelText || 'Cancel';

    const cancelButtonTextSecondary = document.createElement('div');
    cancelButtonTextSecondary.className = "btn-txt secondary iconsTheme";
    cancelButtonTextSecondary.innerHTML = stepOptions.cancelText || 'Cancel';

    this.doneButton.innerHTML = '';
    this.cancelButton.innerHTML = '';

    this.doneButton.appendChild(doneButtonText);
    this.doneButton.appendChild(doneButtonTextSecondary);

    this.cancelButton.appendChild(cancelButtonText);
    this.cancelButton.appendChild(cancelButtonTextSecondary);

    this.doneButton.onclick = e => handleNext(this.currentStepData);
    this.cancelButton.onclick = e => handleCancel();
    this.backdrop.onclick = e => handleCancel();
    if (stepOptions.prefill) this.textarea.value = stepOptions.prefill;

    this.doneButton.disabled = !this.validate();

    //------------------ reset attachments ------------------//

    while (this.imageGallery.childNodes[1]) {
      this.imageGallery.removeChild(this.imageGallery.childNodes[1]);
    }
    if (location.required) {
      this.showLocationModal();
    } else {
      this.setLocation();
    }
  },

  /**
   * Show the input box
   * @param  {[Object]}   options  Array of settings for each input step
   * @param  {Function} callback Results callback
   */
  showTextDialog: function(options, callback)  {
    if (!options || !callback) return;

    if (this.currentStepOptions && this.currentStepOptions._buffer) {
      return callback({ message: 'inputDialog is already active' });
    }

    if (!this.initialized) this.init();

    // options should always be an array
    var steps = Array.isArray(options) ? options : [options];
    var results = [];

    // Validate lengths
    var saveTooLong = false;
    var cancelTooLong = false;
    steps.forEach(function (step) {
      if (step.cancelText && step.cancelText.length > 9) cancelTooLong = true;
      if (step.saveText && step.saveText.length > 9) saveTooLong = true;
      if (!step.attachments) step.attachments = {};
      if (!step.attachments.images) step.attachments.images = {};
      if (!step.attachments.location) step.attachments.location = {};
      if (step.attachments.location.required) step.attachments.location.enable = true;
      if (!step.attachments.gifs) step.attachments.gifs = {};
    });

    if (saveTooLong) return callback(new Error('saveText too long, max 9 chars'));
    if (cancelTooLong) return callback(new Error('cancelText too long, max 9 chars'));
    if (options.hideUserData || !authAPI.getCurrentUser()) this.currentUserContainer.style.display = 'none';
    if (options.prefill) this.textarea.value = options.prefill;

    const handleClose = (cancelled) => {
      /**
       * Reset step data and options
       * Wait 150ms before closing the dialog
       * if textDialog is not called first,
       * hide and reset
       */
      callback(null, { cancelled, results });
      this.currentStepOptions = null;
      this.currentStepData = null;
      this.timer = setTimeout(() => {
        this.inputDialog.classList.remove('active');
        this.backdrop.classList.remove('active');
        setTimeout(() => {
          // return if showTextDialog was called after timeout executed
          if (this.inputDialog.classList.contains('active')) return;
          this.inputDialog.style.display = 'none';
          this.init();
        }, 500);
      }, 150);
    }

    const handleCancel = () => {
      handleClose(true);
    }

    const handleNext = (currentStepResults) => {
      results.push(currentStepResults);

      var nextStep = steps.shift();
      if (nextStep) {
        nextStep._buffer = steps;
        this.renderStep(nextStep, handleCancel, handleNext);
      } else {
        handleClose(false);
      }
    }

    var currentStep = steps.shift();
    currentStep._buffer = steps;
    this.renderStep(currentStep, handleCancel, handleNext);

    // if textDialog just executed its callback, clear the timer
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }

    this.inputDialog.style.display = 'flex';
    // set timeout to prevent animation while display is none
    setTimeout(() => {
      this.inputDialog.classList.add('active');
      this.backdrop.classList.add('active');
    }, 100);
  },

  showListDialog: function (options, callback) {
    if (!options || !callback) return;

    if (!options.title) {
      return callback(new Error('No title provided to showListDialog'), null);
    }
    if (!options.listItems || !options.listItems.length) {
      return callback(new Error('No listItems provided to showListDialog'), null);
    }
    if (options.listItems.some(item => !item.text || !item.value)) {
      return callback(new Error('All listItems must contain text and value'), null);
    }
    if (!options.cancelButton) {
      options.cancelButton = {
        text: 'Cancel',
        value: 'cancel'
      };
    }
    if (!options.confirmButton) {
      options.confirmButton = {
        text: 'Confirm',
        value: 'confirm'
      };
    }

    if (!this.initialized) this.init();

    this.listDialogItems.innerHTML = '';

    this.listDialogHeader.innerHTML = options.title;

    options.listItems.forEach(item => {

      const itemSelect = document.createElement('input');
      itemSelect.className = 'listItem-input';
      itemSelect.value = item.value;
      itemSelect.setAttribute('type', options.multiSelect ? 'checkbox' : 'radio');
      itemSelect.setAttribute('name', 'listDialogItem');
      itemSelect.setAttribute('id', item.value);
      this.listDialogItems.appendChild(itemSelect);

      const itemText = document.createElement('label');
      itemText.className = 'listItem-text';
      itemText.innerHTML = item.text;
      itemText.setAttribute('for', item.value);
      this.listDialogItems.appendChild(itemText);
    });

    let selected = [];

    this.listDialogItems.addEventListener('change', e => {

      const { value, type } = e.target;

      switch (type) {
        case 'checkbox':{

          if (e.target.checked) {
            selected.push({ value });
          } else {
            selected = selected.filter(item => item.value !== value);
          }

          break;
        }
        case 'radio':{
          
          selected = [{ value }];
          this.listDialogConfirmBtn.disabled = false;

          break;
        }
        default:
          break;
      }
    });

    this.listDialogCancelBtn.innerHTML = options.cancelButton.text;
    this.listDialogCancelBtn.value = options.cancelButton.value;

    this.listDialogConfirmBtn.innerHTML = options.confirmButton.text;
    this.listDialogConfirmBtn.value = options.confirmButton.value;

    if (!options.multiSelect) {
      this.listDialogConfirmBtn.disabled = true;
    }

    const closeDialog = () => {
      this.listDialog.classList.remove('active');

      this.listDialogItems.innerHTML = '';
      this.listDialogHeader.innerHTML = '';
    }

    this.listDialogCancelBtn.onclick = () => {
      closeDialog();
      return callback(null, { cancelled: true, selected });
    };

    this.listDialogConfirmBtnonclick = () => {
      closeDialog();
      return callback(null, { cancelled: false, selected });
    };

    this.listDialog.classList.add('active');
  },

  validate() {
    let isTextValid = false;
    let isLocationValid = false;

    const { required, attachments } = this.currentStepOptions;

    if (!required || (this.textarea.value && this.textarea.value.length > 0)) {
      isTextValid = true;
    }

    if (!attachments.location.required || this.currentStepData.location.latitude) {
      isLocationValid = true;
    }

    return isTextValid && isLocationValid;
  }

};

setTimeout(function() {
  if (!inputAPI.initialized) inputAPI.init();
}, 5000);

/**
 * @constant gifAPI
 * @summary gif dialog and api
 * @description Opens a dialog allowing users to search
 * and select gifs via an API such as Giphy.
 * Exposes a search method that can be
 * called without using any UI.
 * This API can be opened and operated
 * independently of other APIs.
 * @since v3.28.6 08/14/2019
 * @author Christopher Berger
 * @link documentation: https://github.com/BuildFire/app/wiki/gifAPI
 */

const gifAPI = {

	/**
	 * @property {Boolean} initialized
	 * determines if the dialog has been initialized
	 * used to avoid reinitialization of UI
	 */
	initialized: false,
	/**
	 * @property {String} apiKey
	 * key for target gif API.
	 */
	apiKey: '5yISc07frWLGwJJgXt7PKnsDMQP1or1H',
	/**
	 * @property {Array} results
	 * holds the selected gifs to return
	 */
	results: [],
	/**
	 * @property {Object} pages
	 * pages of gif results to be loaded later
	 */
	pages: [],
	/**
	 * @property {Object} options
	 * options passed to showGifDialog
	 */
	options: {},
	handleClose: null,
	/**
	 * @method init
	 * @summary initializes the gifDialog UI
	 * @description generates the gif dialog UI.
	 * If called after initialized,
	 * rebuilds the dialog.
	 * Called 5 seconds after the app loads,
	 * unless showGifDialog was called first
	 * @see showGifDialog
	 */
	init() {
		if (this.gifDialog) {
			this.gifDialog.innerHTML = '';
		} else {
			this.gifDialog = document.createElement('div');
			this.gifDialog.style.display = 'none';
		}

		if (this.backdrop) {
			this.backdrop.className = '';
		} else {
			this.backdrop = document.createElement('div');
			this.backdrop.id = 'gif-backdrop';
		}

		this.gifDialog.id = 'gifDialog';
		this.gifDialog.className = 'backgroundColorTheme';

		const gifDialogContainer = document.createElement('div');
		gifDialogContainer.className = 'gifDialog-container backgroundColorTheme';
		this.gifDialog.appendChild(gifDialogContainer);

		const gifToolBar = document.createElement('div');
		gifToolBar.className = 'gifapi-nav backgroundColorTheme';
		gifDialogContainer.appendChild(gifToolBar);

		const gifSearchBar = document.createElement('div');
		gifSearchBar.className = 'gifapi-nav-flex gifapi-search-bar';
		gifToolBar.appendChild(gifSearchBar);

		this.cancelButton = document.createElement('span');
		this.cancelButton.className = 'icon icon-cross2 gifapi-cancel bodyTextTheme';
		this.cancelButton.style.width = 'unset';

		gifSearchBar.appendChild(this.cancelButton);

		const formWrapper = document.createElement('form');
		formWrapper.action = '.';
		gifSearchBar.appendChild(formWrapper);

		this.gifSearchInput = document.createElement('input');
		this.gifSearchInput.className = 'gif-search-input form-control';
		this.gifSearchInput.placeholder = 'search GIPHY';
		this.gifSearchInput.type = 'search';
		this.gifSearchInput.onkeydown = ({ key, target }) => {
			if (key === 'Enter') {
				this.search();
				target.blur();
			}
		};
		this.gifSearchInput.oninput = ({ target }) => {
			this.clearSearch.style.display = target.value ? 'block' : 'none';
		};

		this.setSearchBarStyle();
		formWrapper.appendChild(this.gifSearchInput);

		const searchIcon = document.createElement('i');
		searchIcon.className = 'glyphicon glyphicon-search search-icon';
		formWrapper.appendChild(searchIcon);

		this.clearSearch = document.createElement('button');
		this.clearSearch.className = 'search-clear';
		this.clearSearch.style.display = 'none';
		this.clearSearch.onclick = ({ target }) => {
			this.gifSearchInput.value = '';
			target.style.display = 'none';
		};
		formWrapper.appendChild(this.clearSearch);

		const clearSearchIcon = document.createElement('i')
		clearSearchIcon.className = 'glyphicon glyphicon-minus-sign';
		this.clearSearch.appendChild(clearSearchIcon);

		this.gifResults = document.createElement('div');
		this.gifResults.className = 'gif-results';

		this.gifResults.addEventListener(
			'scroll',
			() => {
				this.lazyLoad.processLazyImages();
				this.loadPage();
			},
			false
		);
		gifDialogContainer.appendChild(this.gifResults);

		const poweredBy = document.createElement('div');
		poweredBy.className = 'powered-by';
		gifDialogContainer.appendChild(poweredBy);

		const poweredByLogo = document.createElement('img');
		poweredByLogo.src = `${window._appRoot}media/PoweredByGiphy.png`;;
		poweredBy.appendChild(poweredByLogo);

		if (window.location.pathname.indexOf('pluginTester') >= 0) {
			this.gifDialog.style.height = document.getElementById('app').offsetHeight + 'px';
			this.gifDialog.style.position = 'absolute';
			document.getElementById('app').appendChild(this.gifDialog);
			document.getElementById('app').appendChild(this.backdrop);
		} else {
			this.gifDialog.style.height = '100vh';
			this.gifDialog.style.maxHeight = '100vh';
			document.body.appendChild(this.gifDialog);
			document.body.appendChild(this.backdrop);
		}

		this.initialized = true;
	},
	setSearchBarStyle() {
		const callback = (err, result) => {
			if (err || !result || !result.data || !result.data.colors) return;

			const { backgroundColor, bodyText } = result.data.colors;

			const colorMethod = tinycolor(backgroundColor).isDark() ? 'lighten' : 'darken';

			const searchBarBackground = tinycolor(backgroundColor)[colorMethod](10).toString();
			const searchBarColor = tinycolor(bodyText)[colorMethod](10).toString();

			// cannot set psudo element styles via JS
			const searchBarStyle = document.createElement('style');
			searchBarStyle.innerHTML = `
				.gif-search-input::placeholder,
				.search-icon {
					color: ${searchBarColor} !important;
				}
				.gif-search-input {
					color: ${searchBarColor};
					background: ${searchBarBackground}
				}
			`;
			this.gifDialog.appendChild(searchBarStyle);
		}

		if (PluginAPI.appTheme) return callback(null, { data: PluginAPI.appTheme });

		const datastoreAPI = new DatastoreAPI(window.appContext.currentApp.appId, 'appearance', 'appearance', window.appContext.liveMode);
		datastoreAPI.get({ tag: 'appearance', withDynamicData: false }, callback);
	},
	/**
	 * @method showGifDialog
	 * @summary opens the gif dialog
	 * @description accepts options and a callback.
	 * opens the gif dialog and passes
	 * the callback to be handled via renderDialog.
	 * this method can be exposed via sdk
	 * to operate independantly of other APIs.
	 * Resets dialog and data, handles
	 * dialog close and submit, and
	 * loads trending gifs
	 * @param {Object} options
	 * options object (optional)
	 * @param {String} options.rating
	 * limits results to a given rating (optional)
	 * @param {Boolean} options.multiple
	 * determines if the user can select
	 * multiple gifs (optional)
	 * @param {Function} callback (required)
	 * @example
	 * gifAPI.showGifDialog({ rating: 'g', multiple: false }, (error, response) => {
	 * 	// consume gifs
	 * }));
	 */
	showGifDialog(options, callback) {
		if (!options) options = { multiple: false, rating: 'g' };
		this.options = options;

		if (!this.initialized) this.init();

		this.gifResults.innerHTML = '';
		this.gifSearchInput.value = '';

		const handleClose = cancelled => {
			callback(null, { cancelled, results: this.results });

			this.handleClose = null;
			this.pages = [];
			this.results = [];
			this.options = {};

			this.timer = setTimeout(() => {
				this.gifDialog.classList.remove('active');
				this.backdrop.classList.remove('active');

				// hide and reset, unless dialog was called first
				setTimeout(() => {
					if (this.gifDialog.classList.contains('active')) return;
					this.gifResults.innerHTML = '';
					this.gifSearchInput.value = '';
					this.gifDialog.style.display = 'none';
					this.init();
				}, 500);
			}, 150);
		};

		this.results = [];

		this.handleClose = handleClose;
		this.cancelButton.onclick = () => this.handleClose(true);
		this.backdrop.onclick = () => this.handleClose(true);

		if (this.timer) {
			clearTimeout(this.timer);
			this.timer = null;
		}
		this.gifDialog.style.display = 'flex';
		// request animation frame to prevent animation while display is none
		setTimeout(() => {
			this.gifDialog.classList.add('active');
			this.backdrop.classList.add('active');
		}, 100);

		// loading before the transition ends causes issues with lazy load
		this.gifDialog.addEventListener('transitionend', () => this.getTrending(), { once: true });
	},
	/**
	 * @method createRequestUrl
	 * @description takes an object of options and
	 * builds a request url
	 * @param {Object} options
	 * options object with the following properties
	 * @param {String} options.key
	 * API key
	 * @param {String} options.endpoint
	 * API endpoint
	 * @param {String} options.query
	 * search query
	 * @param {String} options.rating
	 * limits results to a given
	 * @param {Number} options.limit
	 * limits number of results
	 * @param {Number} options.offset
	 * skips results
	 * @returns {String}
	 */
	createRequestUrl(options) {
		if (!options) return;

		let { key, endpoint, query, limit, offset, rating } = options;

		let baseUrl = `https://api.giphy.com/v1/gifs/${endpoint}?api_key=${key}`;
		limit = `&limit=${limit || 120}`;
		offset = `&offset=${offset || 0}`;
		rating = `&rating=${rating || 'g'}`;
		query = query && endpoint === 'search' ? `&q=${query}` : '';

		return `${baseUrl}${limit}${offset}${rating}${query}`;
	},
	/**
	 * @method createProxyUrl
	 * @summary builds proxy url
	 * @description passes the request url to build
	 * a proxy url
	 * @returns {String}
	 * @see createRequestUrl
	 */
	createProxyUrl: url => `https://proxy.buildfire.com/hop?url=${encodeURIComponent(url)}`,
	/**
	 * @method get
	 * @summary Queries the gif API.
	 * @description Can be used to query the
	 * gif API independently of the gif dialog.
	 * Valid enpoints are defined here
	 *
	 * @param {String} endpoint
	 * gif API endpoint to query. Valid endpoints
	 * are defined in createRequestUrl,
	 * and must be updated if additional
	 * endpoints are added.
	 *
	 * @param {Object} options
	 * if callback is passed here,
	 * options are set to default.
	 * the following options are availible
	 * to this method:
	 * @param {String} options.query
	 * search query
	 * @param {String} options.rating
	 * limits results to a given rating
	 * @param {Number} options.limit
	 * limits number if results
	 * @param {Number} options.offset
	 * skips results
	 * @param {Function} callback
	 * can be passed as options parameter
	 */
	get(endpoint, options, callback) {
		const validEndpoints = ['trending', 'search', 'random'];

		if (!endpoint || !validEndpoints.includes(endpoint)) {
			return callback(new Error('invalid endpoint'), null);
		}
		if (typeof options == 'function') {
			if (!callback) callback = options;
			options = {};
		}

		const { limit, offset, rating, query } = options || {};

		const requestOptions = {
			key: this.apiKey,
			endpoint,
			limit,
			offset,
			rating,
			query
		};

		let url = this.createRequestUrl(requestOptions);
		url = this.createProxyUrl(url);

		fetch(url)
			.then(response => response.json())
			// standardize and return results
			.then(gifs => this.digest(gifs, callback))
			// catch errors
			.catch(error => {
				if (callback) callback(error, null);
				else console.error(error);
			});
	},
	/**
	 * @method digest
	 * @summary handles API response.
	 * @description standardizes and consumes the
	 * api response. If used internally, sorts gif responses
	 * into pages to be loaded later and loads the
	 * first page
	 * @param {Object} response
	 * raw response from the api
	 * @param {Function} callback
	 * if callback is passed, call
	 * with standardized results
	 * and return
	 */
	digest(response, callback) {
		const gifs = this.convertGifs(response.data);

		if (callback) {
			return callback(null, gifs);
		}

		this.gifResults.innerHTML = '';
		this.pages = [];

		const pages = [];

		while (gifs.length) {
			let page = [];

			if (gifs.length > 24) {
				page = gifs.splice(0, 24);
			} else {
				page = gifs.splice(0, gifs.length);
			}

			pages.push(page);
		}

		this.pages = pages;
		this.loadPage();
	},
	/**
	 * @method convertGifs
	 * @summary formats gif responses.
	 * @description takes an array of gifs and converts it
	 * to a common format. If provider(s) are
	 * added or changed, this method should
	 * be altered to conform to the standard.
	 * @param {Array} gifs
	 * array of gifs
	 * @returns {Array} of standardized gifs
	 */
	convertGifs(gifs) {
		if (!gifs) return [];
		if (gifs.id) gifs = [gifs];
		return gifs.map(gif => {
			const { id, title, rating, user } = gif;

			const { preview, preview_gif, original, downsized_large, downsized_medium, downsized_small, downsized_still, original_still, fixed_height } = gif.images;

			return {
				id,
				title,
				rating,
				user,
				images: {
					preview,
					preview_gif,
					original,
					downsized_large,
					downsized_medium,
					downsized_small,
					downsized_still,
					original_still,
					fixed_height
				}
			};
		});
	},
	/**
	 * @method loadPage
	 * @summary renders pages of gifs.
	 * @description checks if the next page should
	 * load. If so, consumes the next
	 * page and renders it
	 */
	loadPage() {
		if (this.pages.length < 1) return;

		const { scrollHeight, scrollTop, clientHeight } = this.gifResults;

		if (scrollHeight - scrollTop <= clientHeight * 1.75) {
			const page = this.pages.splice(0, 1)[0];

			this.renderPage(page);
		}
	},
	/**
	 * @method renderPage
	 * @summary renders the next page
	 * @description takes an array of gifs and renders
	 * them in the results
	 * @param {Array} gifs
	 */
	renderPage(gifs) {
		if (!gifs || !gifs.length) return;

		const isIOS = bfUtils.isIOS

		const getMP4 = gif => {
			if (!isIOS) {
				if (gif.images.downsized_medium && gif.images.downsized_medium.url) {
					return gif.images.downsized_medium.url;
				}
				if (gif.images.original && gif.images.original.url) {
					return gif.images.original.url;
				}
				return null;
			}

			if (gif.images.preview && gif.images.preview.mp4) {
				return gif.images.preview.mp4
			}
			if (gif.images.downsized_small && gif.images.downsized_small.mp4) {
				return gif.images.downsized_small.mp4
			}
			if (gif.images.original && gif.images.original.mp4) {
				return gif.images.original.mp4
			}
			return null;
		}

		gifs.forEach(gif => {
			const mp4 = getMP4(gif);
			if (!mp4) return;

			const container = document.createElement('div');
			container.className = 'gif-container lazy-img';
			container.id = `gif_${gif.id}`;
			container.setAttribute('data-src', mp4);
			container.onclick = e => this.selectGif(e, gif);

			const check = document.createElement('span');
			container.appendChild(check);

			const thumbnail = document.createElement('div');
			thumbnail.className = 'gif-thumbnail';
			container.appendChild(thumbnail);

			this.gifResults.appendChild(container);
		});

		this.lazyLoad.processLazyImages();
	},
	/**
	 * @method selectGif
	 * @summary selects a GIF
	 * @description selects or deselects a gif.
	 * Unless multiple gifs are
	 * allowed, deslects other gifs
	 * @param {Event} e click event
	 * @param {Object} gif gif object
	 */
	selectGif(e, gif) {
		e.target.classList.add('selected');

		this.results = [gif];
		if (this.handleClose) this.handleClose(false);
	},
	/**
	 * @method getTrending
	 * @summary loads trending gifs
	 * @description calls get on the trending
	 * endpoint and renders the results
	 * @see get
	 */
	getTrending() {
		this.get('trending', this.options);
	},
	/**
	 * @method search
	 * @summary handles search submits
	 * @description sets options.query and
	 * calls get on the search endpoint
	 * and renders the results. If there is no
	 * query, gets trending gifs.
	 * @see get
	 */
	search() {
		gifAPI.options.query = gifAPI.gifSearchInput.value || '';

		if (gifAPI.options.query) {
			gifAPI.get('search', gifAPI.options);
		} else {
			gifAPI.get('trending', gifAPI.options);
		}
	},
	lazyLoad: {
		process(element) {
			if (!element.hasAttribute('data-src')) return;

			const image = element.querySelectorAll('.gif-thumbnail')[0];
			if (!image) return;

			image.style.backgroundImage = this.isInViewport(element)
				? `url(${element.getAttribute('data-src')})`
				: 'unset';
		},
		isInViewport(element) {
			const { innerHeight } = window;
			const { top } = element.getBoundingClientRect();
			const ratio = 1.25;

			return (top > innerHeight * -Math.abs(ratio)) && ((innerHeight * ratio) > top);
		},
		/**
		 * @property {Function} lazyLoad.processLazyImages
		 * @summary lazyloads images
		 * @description queries the document for lazy images
		 * that haven't been loaded yet. Loops through results
		 * and inserts the image
		 */
		processLazyImages() {
			document.querySelectorAll('.lazy-img').forEach(img => this.process(img));
		}
	}
};

setTimeout(function () {
	if (!gifAPI.initialized) gifAPI.init();
}, 5000);

var bookmarkAPI = {

  /**
   * Add a bookmark
   * @param {Object}   options  Bookmark options
   * @param {Function} callback Results callback
   */
  add(options, callback) {
    const pluginInstanceId = (window.appContext && window.appContext.currentPlugin) ? window.appContext.currentPlugin.instanceId : window.postMaster.launcherPluginAPI.context.instanceId;
    const getCurrentUser = authAPI.getCurrentUser();
    const userId = getCurrentUser ? getCurrentUser._id : 'guest';

    const key = `${userId}.bookmarks`;
    const bookmarks = localStorage.getItem(key)
      ? JSON.parse(localStorage.getItem(key))
      : [];

    // set bookmark meta data
    options.id = options.id || options.title;
    options.pluginInstanceId = pluginInstanceId;

    // check if we already have an exisin item with that id
    const index = bookmarks.findIndex(n => {
      const sameId = n.id === options.id;
      const sameInstance = n.pluginInstanceId === options.pluginInstanceId;
      return sameId && sameInstance;
    });

    // Update or insert
    if (index >= 0) {
      bookmarks[index] = options;
    } else {
      bookmarks.push(options);
    }

    // Save the plugin list
    localStorage.setItem(key, JSON.stringify(bookmarks));
    callback(null, options);
  },

  /**
   * Delete a bookmark matching the id
   * @param  {Mixed}   key      The key to find in title or id
   * @param  {Function} callback Results callback
   */
  delete(id, callback) {
    const getCurrentUser = authAPI.getCurrentUser();
    const userId = getCurrentUser ? getCurrentUser._id : 'guest';

    const key = `${userId}.bookmarks`;
    const bookmarks = localStorage.getItem(key)
      ? JSON.parse(localStorage.getItem(key))
      : [];

    // Get index and splice if exists
    const index = bookmarks.findIndex((item) => item.id === id);
    if (index >= 0) bookmarks.splice(index, 1);

    localStorage.setItem(key, JSON.stringify(bookmarks));

    if(callback)
      callback(null, bookmarks);
  },

  /**
   * Delete a bookmark matching the key and plugin contex
   * @param  {[type]}   key      [description]
   * @param  {Function} callback [description]
   * @return {[type]}            [description]
   */
  deleteFromPlugin(id, callback) {
    const getCurrentUser = authAPI.getCurrentUser();
    const userId = getCurrentUser ? getCurrentUser._id : 'guest';

    const key = `${userId}.bookmarks`;
    const bookmarks = localStorage.getItem(key)
      ? JSON.parse(localStorage.getItem(key))
      : [];

    const index = bookmarks.findIndex((item) => item.id === id);
    // Get index and splice if exists
    if (index >= 0) bookmarks.splice(index, 1);

    localStorage.setItem(key, JSON.stringify(bookmarks));

    callback(null, null);
  },

  /**
   * Get the list of all bookmarks matching the user contet
   * @param  {Function} callback Results callback
   */
  getAll(callback) {
    const getCurrentUser = authAPI.getCurrentUser();
    const userId = getCurrentUser ? getCurrentUser._id : 'guest';

    const key = `${userId}.bookmarks`;
    const bookmarks = localStorage.getItem(key)
      ? JSON.parse(localStorage.getItem(key))
      : [];

    callback(null, bookmarks);
  },

  /**
   * Get the list of all bookmarks matching the user and plugin context
   * @param  {Function} callback Results callback
   */
  getAllFromPlugin(options, callback) {
    const getCurrentUser = authAPI.getCurrentUser();
    const userId = getCurrentUser ? getCurrentUser._id : 'guest';
    const pluginInstanceId = (window.appContext && window.appContext.currentPlugin) ? window.appContext.currentPlugin.instanceId : window.postMaster.launcherPluginAPI.context.instanceId;

    const key = `${userId}.bookmarks`;
    const bookmarks = localStorage.getItem(key)
      ? JSON.parse(localStorage.getItem(key))
      : [];

    // Filter out only the ones that belong to the plugin
    const pluginBookmarks = bookmarks.filter(item => {
      return item.pluginInstanceId === pluginInstanceId;
    });

    callback(null, pluginBookmarks);
  }

};


$app.controller('authCtrl', ['$rootScope', '$scope', 'Upload', '$sce',
    function ($rootScope, $scope, Upload, $sce) {

    $scope._appRoot = window._appRoot;

    $scope.registerClick = false;

    var userLoginDomainSettingsAccess = undefined;
    if (window.appContext.currentApp && window.appContext.currentApp.config){
        if(typeof window.appContext.currentApp.config.userLoginDomainSettings == 'undefined') {
            if (window.appContext.currentApp.config.type == "enterprise") {
                userLoginDomainSettingsAccess = 'enabled';
            }
        }
        else{
            userLoginDomainSettingsAccess = window.appContext.currentApp.config.userLoginDomainSettings;
        }
    }

    var domainSuffix;

    var passwordAtLeast8ComplexChars = 'Password must be at least 8 characters long, contains an upper case letter, a lower case letter, a number and a symbol.';
    $scope.loginTranslation = 'Log In';
    $scope.registerTranslation = 'Register';
    $scope.emailDoesNotExistTxt = "Email does not exist in system.";

    $scope.updateLoginTranslations = function(data){
        if(data['passwordAtLeast8ComplexChars'])
            passwordAtLeast8ComplexChars = data['passwordAtLeast8ComplexChars'];

        if(data['loginTranslation'])
            $scope.loginTranslation = data['loginTranslation'];

        if(data['registerTranslation'])
            $scope.registerTranslation = data['registerTranslation'];

        if(data['emailDoesNotExist'])
            $scope.emailDoesNotExistTxt = data['emailDoesNotExist'];
    };

    let getCustomRegistrationSettings = function () {
        let tagName = 'appearance',
            context = {
                appId: window.appContext.currentApp.appId
                , pluginId: tagName
                , instanceId: tagName
            };

        let dsAppearance = new window.DatastoreAPI(context);

        dsAppearance.get({tag: tagName, withDynamicData: true}, function(err, result){
            if(err){
                console.error(err);
                callback(err);
                return;
            }
            if (result && result.data && result.data.customRegistration) {
                buildCustomRegistration(result.data.customRegistration);
            }

            if (result && result.data && result.data) {
                $scope.setThemeType(result.data);
            }
        });
    };

    getCustomRegistrationSettings();

    let buildCustomRegistration = function (customRegistrationSettings, callback) {
        if(customRegistrationSettings && customRegistrationSettings.active && window.appContext.currentApp.config.type === "enterprise") {
            customRegistration.getFields(
                {
                    customRegistrationSettings: customRegistrationSettings,
                    refreshUI: function(){
                        if (!$scope.$$phase) $scope.$apply();
                    },
                    openGDPRContent: function(options) {
                        $scope.loadGDPR(options.key, options.defaultContentKey, options.defaultContentLabel);
                    }
                },
                function(err, result) {
                    if(result) {
                        $scope.showCustomRegistration = true;
                        $scope.showDefaultTermsAndConditions = true;
                        $scope.showDefaultPrivacyPolicy = true;
                        let customTermsAndConditionsKey = null;
                        let customPrivacyPolicyKey = null;
                        if(result.gdprLinks) {
                            result.gdprLinks.forEach(function(link){
                                if(link.name === "termsAndConditions") {
                                    $scope.showDefaultTermsAndConditions = false;
                                    customTermsAndConditionsKey = link.key;
                                } else if (link.name === "privacyPolicy") {
                                    $scope.showDefaultPrivacyPolicy = false;
                                    customPrivacyPolicyKey = link.key;
                                }
                            });
                        }
                        $scope.customRegistrationSubmit = function() {
                            result.fetch({
                                validateFields: true,
                                validateLinks: true
                            }, function (err, registration) {
                                if(!err) {
                                    registration.customTermsAndConditionsKey = customTermsAndConditionsKey;
                                    registration.customPrivacyPolicyKey = customPrivacyPolicyKey;
                                    $scope.register(registration);
                                }
                            })
                        };
                        $scope.customRegistrationFields = result.fields;
                        $scope.customRegistrationRules = result.rules;
                        $scope.customRegistrationGdprLinks = result.gdprLinks;
                        $scope.initCustomRegistration = function() {
                            result.initializers.forEach(function(initializer){
                                initializer();
                            });
                        };
                        if(callback) callback(null, null);
                        if (!$scope.$$phase) $scope.$apply();

                    }
                });
        } else {
            $scope.showCustomRegistration = false;
            if (!$scope.$$phase) $scope.$apply();
        }
    };



    var showMenu = true;

     function shouldShowAppTerms() {
        if (appContext.currentApp && appContext.currentApp.config && appContext.currentApp.config.TermsOfUse) {
            return appContext.currentApp.config.TermsOfUse.indexOf('appdocumentation.com') < 0 &&
                   appContext.currentApp.config.TermsOfUse.indexOf('buildfire.com') < 0 ;
        } else {
            return false;
        }
    }

    //set authAPI the Ctrl
    window.authAPI.authCtrlScope = $scope;
    $rootScope.allowCancel = typeof($rootScope.allowCancel) == 'undefined' ? true : $rootScope.allowCancel;
    $rootScope.authShown = false;

    $scope.secretCodeProvider = null;
    $scope.refWindow = null;
    $scope.errors = {};
    $scope.invalidCredentials = false;
    $scope.invalidReset = false;
    $scope.invalidRegister = false;
    $scope.msgError = null;
    $scope.msgSuccess = null;
    $scope.enableFacebook = true;
    $scope.enableTwitter = true;
    $scope.enableGoogle = true;
    $scope.enableApple = true;

    //$scope.email = '';
    $scope.password = '';
    $scope.userObj = {username:"",
                      email:""};

    $scope.loginCallback = null;
    var accessTokenAPI = "";
    var loginAPI = "";
    var resetPasswordAPI = "";
    var resetPasswordMessage = "";
    var registerUrl = "";
    var signOnStrategy = "";
    var clientId = "";
    var clientSecret = "";
    var contentType = "";
    var appId =  window.appContext.currentApp.appId;
    var datastoreKey = window.appContext.currentApp.keys.datastoreKey;

    var context = {
        appId: appId
        , pluginId: 'authSettings'
        , instanceId: 'authSettings'
        , liveMode: window.appContext.liveMode
        , writeKey: datastoreKey
    };

    $scope.updateLoginCss = function(){
        updateLoginCss();
    };

    function updateLoginCss(customUISettings) {
        if (customUISettings) {
            customUISettings = window.loginUI.convertToCss(customUISettings) ||'*{}';
            localStorage.loginUI = customUISettings;
        }

        var loginUI = customUISettings || localStorage.getItem('loginUI_' + appId);

        // Add custom css
        var styleTag = document.getElementById('custom-login-ui');

        // Create a new style tag if we don't  have it yet
        if (!styleTag) {
            var loginHolder = document.getElementsByClassName('login-holder')[0];
            styleTag = document.createElement('style');
            styleTag.id = 'custom-login-ui';
            loginHolder.appendChild(styleTag);
        }

        styleTag.innerHTML = loginUI;
    }

        $scope.updateSSORegistrationFormStatus = function (status) {
        if (!/htt(p|ps):\/\//g.test(frmExternalRegistrationForm.src)) return;
        if(window.spinner) {
            window.spinner.hide();
        }
        $scope.ssoRegistrationFormStatus = status;
        if (!$scope.$$phase)
            $scope.$apply();
    };

    updateLoginCss();

    var ds = new DatastoreAPI(context);

    function checkBoolDefaultTrue(value){
        var result = (typeof value === 'boolean') ? value : true;

        return result;
    }

    $scope.SSOLogin = false;
    ds.get({tag: 'authSettings'}, handleAuthSettings);
    function handleAuthSettings(err, result) {
        if (err) {
            console.error(err);
        } else {
            if (result && result.data) {
                if (result.data.signOnStrategy == "SSOLogin") {
                    $scope.SSOLogin = true;
                    contentType = result.data.contentType;
                    if (contentType == "application/x-www-form-urlencoded" || contentType == "multipart/form-data") { //put the hop in front to work around CORS
                        accessTokenAPI =  window.siteConfig.endPoints.hopHost + result.data.accessTokenAPI;
                        loginAPI = window.siteConfig.endPoints.hopHost + result.data.loginAPI;
                    } else {  //backwards compatible
                        accessTokenAPI = result.data.accessTokenAPI;
                        loginAPI = result.data.loginAPI;
                    }

                    //able to disable FB and twitter even if they don't have SSO enabled.
                    $scope.enableFacebook = result.data.enableFacebook;
                    $scope.enableTwitter = result.data.enableTwitter;
                    $scope.enableGoogle = result.data.enableGoogle;
                    //if the app owner disabled twitter and facebook, and did nothing for apple then we will assume that app owner don't apple as well.
                    if (!$scope.enableFacebook && !$scope.enableTwitter && typeof result.data.enableApple == "undefined") {
                        $scope.enableApple = false;
                    } else {
                        $scope.enableApple = result.data.enableApple;
                    }

                    $scope.signOnStrategy = signOnStrategy = result.data.signOnStrategy;
                    resetPasswordAPI = result.data.resetPasswordAPI;
                    resetPasswordMessage = result.data.resetPasswordMessage;
                    $scope.registerUrl = registerUrl = result.data.registerUrl;
                    clientId = result.data.clientId;
                    clientSecret = result.data.clientSecret;

                    setInterval(checkToken, 1000 * 60 * 15);   //check SSO 15 minutes - to make sure user token isn't expired or revoked.
                }
                //able to disable FB and twitter even if they don't have SSO enabled.
                $scope.enableFacebook = checkBoolDefaultTrue(result.data.enableFacebook);
                $scope.enableTwitter = checkBoolDefaultTrue(result.data.enableTwitter);
                $scope.enableGoogle = checkBoolDefaultTrue(result.data.enableGoogle);
                //if the app owner disabled twitter and facebook, and did nothing for apple then we will assume that app owner don't apple as well.
                if (!$scope.enableFacebook && !$scope.enableTwitter && typeof result.data.enableApple == "undefined") {
                    $scope.enableApple = false;
                } else {
                    $scope.enableApple = checkBoolDefaultTrue(result.data.enableApple);
                }
                signOnStrategy = result.data.signOnStrategy;

                if (userLoginDomainSettingsAccess == 'enabled') {
                    domainSuffix = result.data.domain;
                }
                $scope.emailInputType = (domainSuffix) ? 'text' : 'email';
            } else{
                $scope.enableFacebook = true;
                $scope.enableTwitter = true;
                $scope.enableGoogle = true;
                $scope.enableApple = true;
            }
        }
    }

    function checkToken() {
        var ssoUserObj = JSON.parse(window.localStorage.getItem("SSO_USER"));
        if (ssoUserObj) {
            var dateNow = new Date().getTime() / 1000;
            if (dateNow > ssoUserObj.ssoExpiresAt) {    // is the token expired?
                $scope.invalidCredentials = true;

                $rootScope.allowCancel = false;
                $rootScope.showMenu = false;
                //authAPI.login({}, null);
                $scope.showLogin(function(err, result) {
                  authAPI._setCurrentUser(result);

                  authAPI.triggerOnLogin(result);

                  $rootScope.allowCancel = true;
                  $rootScope.showMenu = true;
                  $scope.hideLogin();
                  if (!$scope.$$phase)
                    $scope.$apply();
                });
            }
            var testAPI = accessTokenAPI;
            if (contentType == "multipart/form-data" || contentType == "application/x-www-form-urlencoded") {
                var headerObj = {
                      headers:{
                        'Authorization': "Bearer " + ssoUserObj.ssoUserToken,
                        'Content-Type': 'application/json'
                      }
                };
            } else {
                var headerObj = {headers: {'Content-Type': 'application/x-www-form-urlencoded'}}
                testAPI = accessTokenAPI + "?access_token=" + ssoUserObj.ssoUserToken;
            }
            window.bfUtils.http.get(testAPI, headerObj)   //go to the profile to see if the token is still good.
                .success(function (result) {
                    console.log(result);
                }).error(function (data, status, headers, config) {
                    $scope.invalidCredentials = true;

                    $rootScope.allowCancel = false;
                    $rootScope.showMenu = false;
                    $scope.showLogin(function(err, result) {
                        authAPI._setCurrentUser(result);
                        authAPI.triggerOnLogin(result);
                        $rootScope.allowCancel = true;
                        $rootScope.showMenu = true;
                        $scope.hideLogin();
                        if (!$scope.$$phase)
                            $scope.$apply();
                    });
                });
        }

    }

    $scope.closeLogin = function () {
        if ($scope.loginCallback)
            $scope.loginCallback();
        if($rootScope.allowCancel)
            $scope.hideLogin();
        else resetLogin();
    };

    $scope.reset = function () {
        $scope.errors = {};
        $scope.showProgressMessage = false;
        $scope.invalidCredentials = false;
        $scope.invalidReset = false;
        $scope.invalidRegister = false;
        $scope.allowToRegister = false;
        $scope.uploadFile = null;

        $scope.userObj.email = null;
        $scope.userObj.username = null;
        $scope.password = null;
        $scope.secretCode = null;
        $scope.newPassword = null;
        $scope.confirmPassword = null;
        $scope.msgError = null;
        $scope.msgSuccess = null;
        $scope.uploadFile = null;
        $scope.firstName = null;
        $scope.lastName = null;

        $scope.secretCodeProvider = null;
        $scope.refWindow = null;

        $scope.acceptTOS = null;
        $scope.acceptPP = null;
        $scope.acceptedAppTerms = null;

        if($scope.customRegistrationGdprLinks) {
            $scope.customRegistrationGdprLinks.forEach(function(link){
                link.value = undefined;
                link.error = undefined;
            });
        }
        if($scope.customRegistrationFields) {
            $scope.customRegistrationFields.forEach(function(field){
                field.value = undefined;
                field.error = undefined;
            });
        }
    };

    var hideForms = function () {
        $scope.successShown = false;
        $scope.registrationShown = false;
        $scope.loginShown = false;
        $scope.forgetPasswordShown = false;
        $scope.resetPasswordShown = false;

        resetExternalRegisterForm();
    };
    hideForms();

    $scope.openTermsAndConditions = function () {
        window.open('https://support.appdocumentation.com/terms/', '_system');
        return false;
    };

    $scope.registerUser = function(){
        $scope.registerClick = true;

        if($scope.frmAuthRegister.$invalid) {
            return;
        }

        //Add logic here
        var isPasswordValid = window.validator.validatePassword($scope.password);

        if(!isPasswordValid){
            var options = {
                data: {
                    title: ' ',
                    body: passwordAtLeast8ComplexChars,
                    disableCancel: true
                }
            };

            window.openDialog(options, function(){});

            return;
        }

        $scope.register();
        $scope.registerClick = false;
    };

    $scope.hideLogin = function () {
        $scope.reset();

        hideForms();
        $rootScope.authShown = false;
        $scope.loginCallback = null;
    };
    var frmExternalRegistrationForm = document.getElementById('frmExternalRegistrationForm');
    function resetExternalRegisterForm(){
        frmExternalRegistrationForm = frmExternalRegistrationForm || document.getElementById('frmExternalRegistrationForm');
        frmExternalRegistrationForm.src = '';
        $scope.externalRegister = false;
        $scope.ssoRegistrationFormStatus = null;
    }

    $scope.showRegistration = function (obj, callback) {
        $scope.scrolling = bfUtils.isIOS ? 'no' : 'auto';
        if (signOnStrategy == "SSOLogin" && registerUrl) {
            window.spinner.show();
            $scope.externalRegister = true;
            $scope.ssoRegistrationFormStatus = 'loading';
            frmExternalRegistrationForm = frmExternalRegistrationForm || document.getElementById('frmExternalRegistrationForm');
            frmExternalRegistrationForm.src = registerUrl;

            function receiveMessage(event) {
                if (event && registerUrl.indexOf(event.origin) > -1) {
                    if (event.data) {
                        var response = null;
                        try {
                            response = JSON.parse(event.data);
                        } catch (e) {
                        }
                        if (response) {
                            if(response.status === 'success') {
                                if (response.user && response.user.username) {
                                    $scope.userObj.username = response.user.username;
                                }
                                if (window.spinner && window.spinner.show) {
                                    window.spinner.show(true);
                                }
                                authSSOLogin(response.user, function (err, result) {
                                    if (err) {
                                        console.error(err);

                                        var options = {
                                            data: {
                                                title: ' ',
                                                body: 'Invalid Login',
                                                disableCancel: true
                                            }
                                        };

                                        window.openDialog(options, function () {
                                        });

                                        if (callback)
                                            callback(err, null);
                                    } else {
                                        if (!callback)
                                            callback = $scope.loginCallback;
                                        if (callback)
                                            callback(null, result);
                                    }
                                    if (window.spinner && window.spinner.hide) {
                                        window.spinner.hide(true);
                                    }
                                });
                            }
                            window.removeEventListener("message", receiveMessage, false);
                            frmExternalRegistrationForm.src = '';
                            $scope.externalRegister = false;
                            $scope.ssoRegistrationFormStatus = null;
                            if (!$scope.$$phase)
                                $scope.$apply();
                        }
                    }
                }
            }
            window.addEventListener("message", receiveMessage, false);
        }
        else {
            $scope.reset();

            hideForms();
            $scope.registrationShown = true;
            $rootScope.authShown = true;
        }
    };

    $scope.showForgetPassword = function () {
        $scope.reset();

        hideForms();
        $scope.forgetPasswordShown = true;
        $rootScope.authShown = true;
    };

    $scope.showSuccess = function (msg) {
        hideForms();
        $scope.msgSuccess = msg;
        $scope.successShown = true;
    };

    $scope.showResetPassword = function (callback) {
        $scope.reset();

        hideForms();
        $scope.resetPasswordShown = true;
        $rootScope.authShown = true;
        $scope.loginCallback = callback;
    };

    function resetLogin(){
        $scope.reset();

        hideForms();
        $rootScope.allowCancel = !$scope.loginOptions || $scope.loginOptions.allowCancel !== false;
        $rootScope.showMenuOnAuth =  !$scope.loginOptions || $scope.loginOptions.showMenu !== false;
        $scope.loginShown = true;
        $rootScope.authShown = true;
        if (!$scope.$$phase) $scope.$apply();
    }

    $scope.updateLogin = function (loginUISettings){

        if (loginUISettings && loginUISettings != "SSOForgetPassword") {
            updateLoginCss(loginUISettings);
        }

        $scope.loginCallback = function(err, result) {
            if(result){
                window.authAPI._setCurrentUser(result);
                window.authAPI.triggerOnLogin(result);
            }
            else{
                console.error('authCtrl loginCallback error', err);
            }

            $rootScope.allowCancel = true;
            $rootScope.showMenu = true;
            $scope.hideLogin();
            if (!$scope.$$phase)
                $scope.$apply();
        };
        resetLogin();

        if (loginUISettings && loginUISettings == "SSOForgetPassword"){
            $scope.showForgetPassword();
            $scope.$apply();
        }

        //check if there is any changes on the appearance
        getCustomRegistrationSettings();
    };

    $scope.updateRegistration = function (customRegistrationSettings){
        $scope.reset();
        hideForms();
        $scope.registrationShown = true;
        $rootScope.authShown = true;
        if(customRegistrationSettings) {
            buildCustomRegistration(customRegistrationSettings, function() {
                $scope.initCustomRegistration();
            });
        }
        if (!$scope.$$phase) $scope.$apply();
    };

    $scope.updateLoginAuth = function (options){
        $scope.enableFacebook = checkBoolDefaultTrue(options.enableFacebook);
        $scope.enableTwitter = checkBoolDefaultTrue(options.enableTwitter);
        $scope.enableGoogle = checkBoolDefaultTrue(options.enableGoogle);
        $scope.enableApple = checkBoolDefaultTrue(options.enableApple);

        if(options.domain && userLoginDomainSettingsAccess == 'enabled'){
            domainSuffix = options.domain;
        }

        if (!$scope.$$phase) $scope.$apply();
    };

    $scope.returnToLogin = function () {
        $scope.showLogin($scope.loginCallback);
    };

    $scope.showLogin = function (callback) {
        $scope.loginCallback = callback;
        resetLogin();
    };

    $scope.resetPassword = function () {
        $scope.invalidReset = false;
        $scope.msgError = null;

        if ($scope.newPassword != $scope.confirmPassword) {
            $scope.invalidReset = false;
            $scope.msgError = 'Make sure new password and confirm password are equal';
            return;
        }

        var resetData = {
            email: $scope.email,
            "secretCode": $scope.secretCode,
            password: $scope.newPassword,
            passwordStrength: $scope.customRegistrationRules ? $scope.customRegistrationRules.passwordStrength : null,
            externalAppId: window.currentAppId,

        };

        var data = {
            "id": 1, "method": "users/changePassword",
            "params": resetData
        };

        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        window.bfUtils.http.jsonp(url, {bypassInterceptorForStatus: 404})
            .success(function (result) {
                if (result && result.result) {
                    $scope.showSuccess('Password reset successfully');
                    var options = {
                        data: {
                            title: ' ',
                            body: 'Password reset successfully',
                            disableCancel: true
                        }
                    };

                    window.openDialog(options, function(){});
                }
                else {
                    if (result && result.error) {
                        var options = {
                            data: {
                                title: ' ',
                                body: result.error.message,
                                disableCancel: true
                            }
                        };

                        window.openDialog(options, function(){});
                        console.error(result.error);
                    }
                }
            })
            .error(function (data, status, headers, config) {
                $scope.invalidCredentials = true;

                console.error(data);
                if (callback)
                    callback(data, null);
            });
    };

    $scope.forgotPassword = function (obj) {
        if (signOnStrategy != "SSOLogin") {
            $scope.invalidCredentials = false;

            var resetData = {
                email: $scope.email, "sendSecretCode": true, externalAppId: window.currentAppId
            };
            if (obj) {
                resetData.email = obj.email;
            }

            var data = {
                "id": 1, "method": "users/forgotPassword",
                "params": resetData
            };

            var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

            window.bfUtils.http.jsonp(url, {bypassInterceptorForStatus: 404})
                .success(function (result) {
                    if (result && result.result) {
                        $scope.showResetPassword();
                    }
                    else {
                        var options = {
                            data: {
                                title: ' ',
                                body: $scope.emailDoesNotExistTxt,
                                disableCancel: true
                            }
                        };

                        window.openDialog(options, function(){});

                        if (result)
                            console.warn(result);

                    }
                })
                .error(function (data, status, headers, config) {
                    $scope.invalidCredentials = true;

                    console.error(data);
                });
        } else {       //this is SSO forgot password

            var queryStringChar = resetPasswordAPI.indexOf('?') === -1 ? "?" : "&",
                myResetPasswordAPI  = resetPasswordAPI + queryStringChar + "email=" + $scope.email;

            window.bfUtils.http.get(myResetPasswordAPI, {
                headers: {'Content-Type': 'application/x-www-form-urlencoded'}
            }).success(function () {


                var options = {
                    data: {
                        title: ' ',
                        body: resetPasswordMessage || 'An email has been sent, please check your email.',
                        disableCancel: true
                    }
                };

                window.openDialog(options, function () {
                    $scope.showLogin(function(err, result) {
                        authAPI._setCurrentUser(result);

                        authAPI.triggerOnLogin(result);

                        $rootScope.allowCancel = true;
                        $rootScope.showMenu = true;
                        $scope.hideLogin();
                        if (!$scope.$$phase)
                            $scope.$apply();
                    });
                });



                cpSync.SSO.log("Succeed...");
            }).error(function (data, status, headers, config) {
                if (data)
                    console.error(data);
                if(bfUtils.isEmulatorCP) {
                    if(!data && status == "0")
                        cpSync.SSO.log('Error while testing SSO Login , CORS policy ..');
                    else {
                        if(status)
                            cpSync.SSO.log('Error status:' + status );
                        if(data)
                            cpSync.SSO.log('Error details:' + JSON.stringify(data));
                    }
                }
            });
        }
    };

    function buildfireLogin(obj, callback) {

        if (!window.appContext || !window.appContext.currentApp ){
            console.error('invalid appContext');
            return;
        }

        $scope.invalidCredentials = false;

        if (!callback)
            callback = $scope.loginCallback;

        var pushSDK = null;
        if (typeof(push) == 'undefined')
            pushSDK = {};
        else
            pushSDK = push;

        var email = $scope.userObj.email;
        if(!email){
            email = obj.email;
        }
        if(!$scope.password){
            $scope.password = obj.password;
        }

        if(userLoginDomainSettingsAccess == 'enabled' && domainSuffix && !email.includes("@")){
            email = email + domainSuffix;
        }

        console.warn('email', email);

        var loginData = {
            email: email,
            password: $scope.password,
            deviceId: pushSDK.deviceId,
            osType: pushSDK.platform ? pushSDK.platform.toLowerCase() : 'web',
            externalAppId: window.appContext.currentApp.appId
        };
        if (obj) {
            loginData.email = obj.email;
            loginData.password = obj.password;
        }

        var data = {
            "id": 1, "method": "users/login",
            "params": loginData
        };

        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        window.bfUtils.http.jsonp(url, {bypassInterceptorForStatus: 404})
            .success(function (result) {
                if (result && result.result && result.result.userToken) {

                    authAPI._setCurrentUser(result.result);
                    $rootScope.$broadcast('loginSuccessfully', result.result);
                    if (callback)
                        callback(null, result.result);
                }
                else {
                    $scope.invalidCredentials = true;

                    var error = null;
                    if (result && result.error) {
                        console.warn('login error: ', result.error);
                        error = result.error;
                    }
                    if (error && error.message)
                        $scope.msgError = error.message;
                    else
                        $scope.msgError = 'Invalid Email or Password';
                    if (callback)
                        callback(error, null);
                }
            })
            .error(function (data, status, headers, config) {
                $scope.invalidCredentials = true;

                console.error(data);
                if (callback)
                    callback(data, null);
            });
    }

    function authSSOLogin(result, callback){
        var ssoUserObj = JSON.parse(window.localStorage.getItem("SSO_USER"));
        if (!ssoUserObj)
            ssoUserObj = {};
        if (typeof result == "string") {
            try{
                result = JSON.parse(result);
            }
            catch(e){
                console.warn('Unexpected parsing issue', e);
            }
        }
        if (result && result.access_token) {
            ssoUserObj.ssoUserToken = result.access_token;     //save SSO token
        } else {
            ssoUserObj.ssoUserToken = result.replace(/["]+/g, '');
        }
        if (result && result.expires_in && result.issued_at) {
            ssoUserObj.ssoExpiresAt = result.issued_at + result.expires_in;
        } else {
            ssoUserObj.ssoExpiresAt = 1902608081000;  //if they do not send expiration info, set 10 years in future.
        }

        window.localStorage.setItem("SSO_USER", JSON.stringify(ssoUserObj));

        var pushSDK = null;
        if (typeof(push) == 'undefined')
            pushSDK = {};
        else
            pushSDK = push;

        //strip out the hop if it is there
        var passedAccessTokenAPI = accessTokenAPI.replace(window.siteConfig.endPoints.hopHost, "");

        var loginData = {
            accessToken: ssoUserObj.ssoUserToken,
            accessTokenAPI: passedAccessTokenAPI,
            deviceId: pushSDK.deviceId,
            osType: pushSDK.platform ? pushSDK.platform.toLowerCase() : 'web',
            externalAppId: window.appContext.currentApp.appId,
            loginProviderType: 'SSO',
            email: $scope.userObj.username,
            contentType: contentType
        };
        var data = {
            "id": 1, "method": "users/loginSSO",
            "params": loginData
        };

        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        window.bfUtils.http.jsonp(url, {bypassInterceptorForStatus: 404})
            .success(function (result) {
                if (result && result.result) {
                    authAPI._setCurrentUser(result.result);
                    $rootScope.$broadcast('loginSuccessfully', result.result);
                    callback(null, result.result);

                    if(bfUtils.isEmulatorCP)
                        cpSync.SSO.log("Succeed...");
                }
                else {
                    $scope.invalidRegister = true;

                    var error = null;
                    if (result && result.error) {
                        $scope.msgError = result.error.message;
                        $scope.invalidCredentials = true;
                        console.error(result.error);

                        if(bfUtils.isEmulatorCP)
                            cpSync.SSO.log(result.error);
                    } else {
                        if (result = "Could not retrieve profile info.") {
                            $scope.msgError = result;
                            $scope.invalidCredentials = true;
                            console.error(result);

                            if(bfUtils.isEmulatorCP)
                                cpSync.SSO.log(result);
                        }
                    }
                }
            })
            .error(function (data, status, headers, config) {
                console.error(data);
                if (callback)
                    callback(data, null);

                if(bfUtils.isEmulatorCP)
                    cpSync.SSO.log('Error while testing SSO Login..');
            });
    }

    function SSOLogin(obj, callback) {
        var options = {headers: { 'Content-Type': 'application/x-www-form-urlencoded' }};
        var email = $scope.userObj.username;

        if(userLoginDomainSettingsAccess == 'enabled' && domainSuffix && !email.includes("@")){
            email = email + domainSuffix;
        }

        if (contentType == "application/x-www-form-urlencoded") {
            var loginObj = encodeURIComponent("grant_type") + "=" + encodeURIComponent("password")   + "&" +
                           encodeURIComponent("username")   + "=" + encodeURIComponent(email) + "&" +
                           encodeURIComponent("password") + "=" + encodeURIComponent($scope.password) + "&" +
                           encodeURIComponent("client_id")  + "=" + encodeURIComponent(clientId) + "&" +
                           encodeURIComponent("client_secret") + "=" + encodeURIComponent(clientSecret);
        } else if (contentType == "multipart/form-data") {
            options = {transformRequest: angular.identity, headers: { 'Content-Type': undefined }};
            var loginObj = new FormData();
            loginObj.append('username',email);
            loginObj.append('password',$scope.password);
        } else {
            var loginObj = {
                grant_type: "password",
                username: email,
                password: $scope.password,
                client_id: clientId,
            };
        }
        window.bfUtils.http.post(loginAPI, loginObj, options)
            .success(function (result) {
                authSSOLogin(result, callback);
            })
            .error(function (data, status, headers, config) {
                $scope.invalidCredentials = true;

                if (data && data.error_description) {
                    console.error(data);
                    $scope.msgError = data.error_description;
                } else
                    $scope.msgError = "Login Failed";

                if (callback)
                    callback("Login Failed", null);

                if(bfUtils.isEmulatorCP) {
                    if(!data && status == "0")
                        cpSync.SSO.log('Error while testing SSO Login , CORS policy ..');
                    else {
                        if(status)
                            cpSync.SSO.log('Error status:' + status );
                        if(data)
                            cpSync.SSO.log('Error details:' + JSON.stringify( data));
                    }
                }

            });
    }

    $scope.showBackLogin = function(){
        authAPI.login();
    };

    $scope.login = function (obj, callback) {
        if (window.spinner && window.spinner.show) {
            window.spinner.show(true);
        }

        if (signOnStrategy != "SSOLogin") {
            buildfireLogin(obj, function(err, result) {
                if (err || !result) {

                    var invalidLoginMessage = null;

                    if(err) {
                        switch (err.code) {
                            case 1303:
                                invalidLoginMessage = err.message; // user blocked. too many login attempts
                                break;
                            default:
                                invalidLoginMessage = "Invalid Login";
                        }
                    } else {
                        // no result returned
                        invalidLoginMessage = "To log in, please make sure you have a valid connection.";
                    }

                    var options = {
                        data: {
                            title: ' ',
                            body: invalidLoginMessage,
                            disableCancel: true
                        }
                    };

                    window.openDialog(options, function(){});

                    console.error(err);
                    if (callback)
                        callback(err, null)
                } else {
                    if (!callback)
                        callback = $scope.loginCallback;

                    if(callback)callback(null, result)
                }
                if(window.spinner && window.spinner.hide) {
                    window.spinner.hide(true);
                }
            });
        } else {
            SSOLogin(obj, function(err, result) {
                if (err) {
                    console.error(err);

                     var options = {
                        data: {
                            title: ' ',
                            body: 'Invalid Login',
                            disableCancel: true
                        }
                    };

                    window.openDialog(options, function(){});

                    if (callback)
                        callback(err, null);
                }  else {
                    if (!callback)
                        callback = $scope.loginCallback;
                    callback(null, result);
                }
                if(window.spinner && window.spinner.hide) {
                    window.spinner.hide(true);
                }
            });
        }
    };

    var update = function (userData, callback) {
        var data = {
            "id": 1, "method": "users/update",
            "params": userData
        };

        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        window.bfUtils.http.jsonp(url, {bypassInterceptorForStatus: 404})
            .success(function (result) {
                if (result.error) {
                    var error = null;
                    if (result && result.error) {
                        console.error(result.error);
                        error = result.error;
                    }
                    if (callback)
                        callback(error, null);
                }
                else {
                    var currentUser = authAPI.getCurrentUser();
                    if (currentUser != null) {
                        currentUser.firstName = userData.firstName;
                        currentUser.lastName = userData.lastName;
                        currentUser.displayName = userData.displayName;
                        currentUser.imageUrl = userData.imageUrl;
                        authAPI._setCurrentUser(currentUser);
                    }
                    if (callback)
                        callback(null, currentUser);
                }
            })
            .error(function (data, status, headers, config) {
                console.error(data);
                if (callback)
                    callback(data, null);
            });
    };

    $scope.getGDPR = function(options, callback) {
        var email = $scope.userObj.email;

        var url = siteConfig.endPoints.crmHost + "/documents/" + options.key + "/check?userKey=" + encodeURIComponent( email) + "&withDetails=true";

        bfUtils.http.get(url)
            .success(function (result) {
                let content = {};
                content.title = $sce.trustAsHtml(result[options.key].title);
                content.subtitle = $sce.trustAsHtml(result[options.key].subtitle);
                content.details = $sce.trustAsHtml(result[options.key].details);
                content.defaultContentKey = options.defaultContentKey;
                content.defaultContentLabel = options.defaultContentLabel;
                callback(null, content);
            }).error(
            function (err) {
                console.error(err);
                callback(err, null);
            }
        );
    };

    $scope.loadGDPR = function (key, defaultContentKey, defaultContentLabel) {
        $scope.getGDPR({key : key, defaultContentKey: defaultContentKey, defaultContentLabel: defaultContentLabel}, function(err, gdprContent){
            if(gdprContent) {
                $scope.GDPR_content = gdprContent;
                $scope.showGDPR = true;
                $rootScope.$broadcast('hideNav');
                if (!$scope.$$phase) $scope.$apply();
            }
        });
    };

    $scope.loadGDPR_Additional = function (key) {
        if (!$scope.GDPR_content_additional) {
            $scope.getGDPR({key : key}, function(err, gdprContent){
                if(gdprContent) {
                    $scope.GDPR_content_additional = gdprContent;
                    $scope.showGDPR_additional = true;
                    if (!$scope.$$phase) $scope.$apply();
                }
            });
        } else {
            $scope.showGDPR_additional = true;
        }
    };

    $scope.hideGDPR = function() {
        $rootScope.$broadcast('displayNav');

        $scope.showGDPR = false;
        $scope.showGDPR_additional = false;
        $scope.GDPR_content = null;
        $scope.GDPR_content_additional = null;
    };

    $scope.hideGDPR_additional = function() {
        $scope.showGDPR_additional = false;
    };

    $scope.showTermsOfService = function() {
        $scope.loadGDPR('bf_terms_and_conditions');
    }

    $scope.showPrivacyPolicy = function() {
        $scope.loadGDPR('bf_privacy_policy');
    }

    $scope.showAppTerms = function() {
        window.open(appContext.currentApp.config.TermsOfUse, '_system');
    }

    $scope.shouldShowAppTerms = shouldShowAppTerms();

    $scope.saveGDPR=function(options, saveGDPRCallback) {
        var termsConditionsKey = "bf_terms_and_conditions";
        var privacyPolicyKey = "bf_privacy_policy";

        var getInfo=function (callback) {
            window.$http.get("https://ipapi.co/json/")
                .success(function (data) {
                    if (data) {
                        var formattedData = {
                            ipInfo: {
                                city: data.city,
                                country: data.country_name,
                                countryCode: data.country,
                                lat: data.latitude,
                                lon: data.longitude,
                                regionName: data.region,
                                timezone: data.timezone,
                                zip: data.postal,
                                ip: data.ip
                            }
                        };
                        callback(null, formattedData);
                    }
                    else {
                        callback(null, null);
                    }
                })
                .error(function (response) {
                    callback(null, null);
                });
        }

        getInfo(function (err, data) {
            var info = {};
            if (data) info = data;
            info.appId = appContext.currentApp.appId;

            let acceptGDPR = function(keys, callback) {
                if(keys) {
                    let acceptUrl = siteConfig.endPoints.crmHost + "/documents/" + keys + "/accept";
                    bfUtils.http.post(acceptUrl, {
                        userKey: options ? options.email.toLowerCase() : $scope.userObj.email.toLowerCase(),
                        info: info,
                        source:"app"
                    }).success(function (result) {
                        callback(null,result);
                    }).error(function (err) {
                        callback(err);
                        console.error(err);
                    });
                } else {
                    callback(null, null);
                }
            };

            let keys = [termsConditionsKey, privacyPolicyKey];
            if(options.customTermsAndConditionsKey) keys.push(options.customTermsAndConditionsKey);
            if(options.customPrivacyPolicyKey) keys.push(options.customPrivacyPolicyKey);

            acceptGDPR(keys.join(","), function(){
                if(saveGDPRCallback)saveGDPRCallback();
            });
        });
    };

    $scope.register = function (registerOptions, callback) {

        if (!window.appContext || !window.appContext.currentApp ){
            console.error('invalid appContext');
            return;
        }

        $scope.invalidRegister = false;

        if (!callback)
            callback = $scope.loginCallback;

        var pushSDK = null;
        if (typeof(push) == 'undefined')
            pushSDK = {};
        else
            pushSDK = push;

        var obj = registerOptions ? registerOptions.user : undefined;

        var regData = obj || {
            firstName: $scope.firstName || $scope.userObj.email,
            lastName: $scope.lastName || '',
            email: $scope.userObj.email,
            password: $scope.password
        };

        regData.deviceId = pushSDK.deviceId;
        regData.osType = pushSDK.platform ? pushSDK.platform.toLowerCase() : 'web';
        regData.passwordStrength = $scope.customRegistrationRules ? $scope.customRegistrationRules.passwordStrength : null;
        regData.externalAppId = window.appContext.currentApp.appId;

        var data = {
            "id": 1, "method": "users/register",
            "params": regData
        };

        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(angular.toJson(data));

        $scope.isRegistering = true;

        window.bfUtils.http.jsonp(url, {bypassInterceptorForStatus: 404})
            .success(function (result) {
                if (result && result.result) {
                    let gdprOptions = { email: regData.email };
                    if(registerOptions) {
                        gdprOptions.customTermsAndConditionsKey = registerOptions.customTermsAndConditionsKey;
                        gdprOptions.customPrivacyPolicyKey = registerOptions.customPrivacyPolicyKey;
                    }
                    $scope.saveGDPR(gdprOptions, function() {
                        $scope.login({email: regData.email, password: regData.password}, function (err, result) {

                            if (regData.userProfile) {
                                userTags.setRegistrationTags(regData.userProfile, true, function (err, result) {
                                    if (err)
                                        console.log(err);
                                });
                            }

                            if (result && result.userToken) {
                                $scope.upload($scope.uploadFile, function (err, result) {
                                    if (err) {
                                        $scope.isRegistering = false;
                                        if (callback)
                                            callback(err, null);
                                    }
                                    else {
                                        var currentUser = authAPI.getCurrentUser();
                                        if (result) {
                                            var userData = {
                                                userToken: currentUser.userToken,
                                                firstName: regData.firstName,
                                                lastName: regData.lastName,
                                                displayName: regData.firstName + ' ' + regData.lastName,
                                                imageUrl: result.result,
                                                externalAppId: window.currentAppId
                                            };

                                            update(userData, function(err, result) {
                                                $scope.isRegistering = false;
                                                if (callback)
                                                    callback(err, result);
                                            });
                                        }
                                        else {
                                            $scope.isRegistering = false;
                                            if (callback)
                                                callback(null, currentUser);
                                        }
                                    }
                                });
                                authAPI.trackRegister(result);
                            } else {
                                $scope.isRegistering = false;
                            }
                        });
                    });
                }
                else {
                    $scope.isRegistering = false;
                    $scope.invalidRegister = true;

                    var error = null;
                    if (result && result.error) {
                        let message = result.error.message;
                        if(result.error.code === 1301 && registerOptions && registerOptions.messages && registerOptions.messages.emailAlreadyInUse) { // email exists
                            message = registerOptions.messages.emailAlreadyInUse;
                        }

                        var options = {
                            data: {
                                title: ' ',
                                body: message,
                                disableCancel: true
                            }
                        };

                        window.openDialog(options, function(){});
                        console.warn(result.error);
                        error = result.error;
                    }
                }
            })
            .error(function (data, status, headers, config) {
                console.error(data);
                $scope.isRegistering = false;
            });
    };

    $scope.upload = function (files, callback) {
        var currentUser = authAPI.getCurrentUser();
        if (currentUser != null) {
            var url = window.siteConfig.endPoints.authHost + "/src/server.js?method=users/uploadImage";
            if (files && files.length == 1) {
                var file = files[0];
                Upload.upload({
                    url: url,
                    fields: {'userToken': currentUser.userToken, externalAppId: window.currentAppId},
                    file: file
                }).progress(function (evt) {
                    $scope.progressMessage = true;
                    var progressPercentage = parseInt(100.0 * evt.loaded / evt.total);
                    console.log('progress: ' + progressPercentage + '% ' + evt.config.file.name);
                }).success(function (data, status, headers, config) {
                    console.log('file ' + config.file.name + 'uploaded.');

                    if (callback)
                        callback(null, data);
                }).error(function (err) {
                    $scope.msgError = '';
                    $scope.invalidRegister = true;

                    if (callback)
                        callback(err, null);
                });
            }
            else {
                if (callback)
                    callback(null, null);
            }
        }
        else {
            if (callback)
                callback({message: "Invalid user"}, null);
        }
    };

    $scope.requestLoginProvider = function (loginProviderType) {
        var data = {
            "id": 1, "method": "secretCode/request",
            "params": {externalAppId: window.currentAppId}
        };
        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        if (!$scope.refWindow || $scope.refWindow.closed) {
            window.bfUtils.http.jsonp(url, {bypassInterceptorForStatus: 404})
                .success(function (result) {
                    if (result != null && result.result != null && result.result.code) {
                        $scope.secretCodeProvider = result.result.code;

                        if (loginProviderType === "apple") {
                            $scope.refWindow = window.open(window.siteConfig.endPoints.authHost
                                + '/api/sso/apple?code=' + encodeURIComponent($scope.secretCodeProvider)
                                + '&externalAppId=' + encodeURIComponent(window.currentAppId)
                                , '_blank', 'location=no,enableViewportScale=yes');
                        } else {
                            $scope.refWindow = window.open(window.siteConfig.endPoints.authHost
                                + '/website/index.html?v=2.0&code=' + encodeURIComponent($scope.secretCodeProvider)
                                + '&loginProviderType=' + loginProviderType
                                + '&externalAppId=' + encodeURIComponent(window.currentAppId)
                                , '_blank', 'location=no,enableViewportScale=yes');
                        }

                        if ($scope.refWindow && $scope.refWindow.addEventListener) {
                            $scope.refWindow.addEventListener('exit', function () {
                                $scope.refWindow = null;
                            });
                        }

                        var attempts = 120;
                        setTimeout(secretCodeLogin, 1000, attempts);
                    }
                }, function (e) {
                    console.log(JSON.stringify(e));
                    //callback({ error: { code: -1, message: "failed to communicate with the server" } });
                });
        }
    };

    var secretCodeLogin = function (attempts) {

        if (!window.appContext || !window.appContext.currentApp ){
            console.error('invalid appContext');
            return;
        }

        if (attempts > 0) {
            var data = {
                "id": 1, "method": "users/secretCodeLogin",
                "params": {
                    code: $scope.secretCodeProvider,
                    deviceId: push.deviceId,
                    osType: push.platform ? push.platform.toLowerCase() : 'web',
                    externalAppId: window.appContext.currentApp.appId
                }
            };

            var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

            window.bfUtils.http.jsonp(url, {bypassInterceptorForStatus: 404})
                .success(function (result) {
                    if (result.error) {
                        var failedLogin = false;
                        if (result.error.code == 1300) {
                            failedLogin = true;
                        }
                        if (result.error.code == 1303) {
                            failedLogin = true;
                        }
                        if (failedLogin) {
                            $scope.secretCodeProvider = null;
                            if ($scope.refWindow != null) {
                                $scope.refWindow.close();
                                $scope.refWindow = null;
                            }
                        }
                    }
                    else {
                        if (result.result != null && result.result.userToken != null) {
                            authAPI._setCurrentUser(result.result);

                            //insert registration tags for Social Registrations
                            let fiveMinutesAgo = new Date();
                            fiveMinutesAgo.setMinutes(fiveMinutesAgo.getMinutes() - 5);
                            let userCreatedOn = new Date(result.result.createdOn);

                            //This is to check if the user is new or old (Registration or Login)
                            if (userCreatedOn && userCreatedOn.getTime() >= fiveMinutesAgo.getTime()) {
                                userTags.setRegistrationTags(null, true, function (err, result) {
                                    if (err)
                                        console.log(err);
                                });
                            }

                            if ($scope.refWindow != null) {
                                $scope.refWindow.close();
                                $scope.refWindow = null;
                            }
                            if ($scope.loginCallback)
                                $scope.loginCallback(null, authAPI.getCurrentUser());
                        }
                        else {
                            //to handle if some one closed the popup window
                            if ($scope.refWindow != null && $scope.refWindow.closed) {
                                $scope.refWindow.close();
                                $scope.secretCodeProvider = null;
                                $scope.refWindow = null;
                            }
                            else {
                                setTimeout(secretCodeLogin, 1000, attempts - 1);
                            }
                        }
                    }
                }, function (e) {
                    console.log(JSON.stringify(e));
                    //callback({ error: { code: -1, message: "faild to communicate with the server" } });
                });
        }
        else {
            $scope.secretCodeProvider = null;
            if ($scope.refWindow != null) {
                $scope.refWindow.close();
                $scope.refWindow = null;
            }
            if ($scope.loginCallback) {
                $scope.invalidCredentials = true;
                $scope.msgError = 'Invalid Login';
                $scope.loginCallback(null, null);
            }
        }
    };

    $scope.setThemeType = function (data) {
        if (!data) {
            data = {};
        }
        let color = null;

        if (data.customLoginUI && data.customLoginUI.background && data.customLoginUI.background.active && data.customLoginUI.background.activeColor) {
            if (data.customLoginUI.background.color) {
                if (data.customLoginUI.background.color.colorType === 'solid') {
                    color = data.customLoginUI.background.color.solid.colorHex;
                }
            }
        } else if (data.colors && data.colors.backgroundColor) {
            color = data.colors.backgroundColor;
        }

        if (color) {
            // Variables for red, green, blue values
            var r, g, b, hsp;

            // Check the format of the color, HEX or RGB?
            if (color.match(/^rgb/)) {

                // If HEX --> store the red, green, blue values in separate variables
                color = color.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/);

                r = color[1];
                g = color[2];
                b = color[3];
            } else {
                // If RGB --> Convert it to HEX: http://gist.github.com/983661
                color = +("0x" + color.slice(1).replace(
                    color.length < 5 && /./g, '$&$&'));

                r = color >> 16;
                g = color >> 8 & 255;
                b = color & 255;
            }

            // HSP (Highly Sensitive Poo) equation from http://alienryderflex.com/hsp.html
            hsp = Math.sqrt(
                0.299 * (r * r) +
                0.587 * (g * g) +
                0.114 * (b * b)
            );

            // Using the HSP value, determine whether the color is light or dark
            if (hsp > 127.5) {
                $scope.themeType = 'light';
            } else {

                $scope.themeType = 'dark';
            }
        }
    };
}]);

"use strict";
/**
 * Created by Ayman on 9/10/2015.
 */

var authAPI = {
	authCtrlScope: null,
	init: function (context) {
		this.context = context;
		/*var currentUser = authAPI.getCurrentUser();
		if (currentUser)
			authAPI.triggerOnLogin(currentUser);*/
	},
    initRefresh: function () {

		let refresh = function(){
            let user = authAPI.getCurrentUser();
            if(user) {
                authAPI.getUserByAccessToken({ accessToken: user.accessToken}, function(err, refreshedUser){
                	if (refreshedUser) {
                        // do not compare user & refreshed as both are coming from different APIs and may not be exact match
                        let currentUserUpdateFactors = { isActive: user.isActive, appTags: user.tags ? user.tags[window.currentAppId] : null };
                        let refreshedUserUpdateFactors = { isActive: refreshedUser.isActive, appTags: refreshedUser.tags ? refreshedUser.tags[window.currentAppId] : null };
                        authAPI._setCurrentUser(refreshedUser); // update anyway
                        if (JSON.stringify(currentUserUpdateFactors) !== JSON.stringify(refreshedUserUpdateFactors)) {
                        	console.log("user update found during sync");
                            authAPI.triggerOnUpdate(refreshedUser);
                        }
					}
				});
            }
		};

		if(bfUtils.isApp) {
            setTimeout(refresh, 3000);
            setInterval(refresh, 3000 * 100);
		}
    },
	getUserByAccessToken: function (options, callback) {
        let data = {
            "id": 1, "method": "users/getUserByAccessToken",
            "params": {
                accessToken: options.accessToken,
                externalAppId: window.currentAppId
            }
        };

        let url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        window.bfUtils.http.jsonp(url, {bypassInterceptorForStatus: 404})
            .success(function (result) {
                if(result) {
                	if(result.error) {
                        if(result.error.code === 1311) { // invalid access token error; could be a stale or bad token
                            var options = {
                                data: {
                                    title: 'Login Required',
                                    body: "Please login again",
                                    disableCancel: true
                                }
                            };

                            authAPI.logout();
                            callback(null, null);
                            window.openDialog(options, function () {
                            });
                        } else if(result.error.code === 1309) { // user is no longer active
                            authAPI.logout();
                        } else {
                            console.error(result.error);
                            callback(result.error, null);
                        }
					} else {
                        callback(null, result.result);
					}
                } else {
                    callback(null, null);
                }
            })
            .error(function (data, status, headers, config) {
                console.error(data);
                callback(data, null);
            });
    },
	login: function (options, callback) {
		var currentUser = this.getCurrentUser();
		if (currentUser) {
			if (callback)callback(null, currentUser);
			authAPI.triggerOnLogin(currentUser);
		}
		else {
            authAPI.authCtrlScope.loginOptions = options;
			authAPI.authCtrlScope.showLogin(function (err, result) {
				if (!err && result) {
					authAPI._setCurrentUser(result);

					authAPI.triggerOnLogin(result);
					authAPI._checkGDPR(result);
					authAPI.authCtrlScope.hideLogin();
					if (!authAPI.authCtrlScope.$$phase)
						authAPI.authCtrlScope.$apply();
				}
				if (callback)
					callback(err, result);
			});
			if (!authAPI.authCtrlScope.$$phase)
				authAPI.authCtrlScope.$apply();
		}
	},
	_setCurrentUser: function (user) {
		localStorage.setItem('AUTH_CURRENT_USER', JSON.stringify(user));
	},
	///don't delete this is used for areas that needs to override this function
	secondaryUserLookup: function () {
		return null;
	},
	getCurrentUser: function (data, callback) {
		if (typeof(data) == 'function') {
			callback = data;
		}
		var user = this.secondaryUserLookup();
		if(!user){
			user = localStorage.getItem('AUTH_CURRENT_USER');
			user = JSON.parse(user);

		}
		if (!(user && user.userToken)) {
			user = null;
		}
		if (callback)
			callback(null, user);
		else
			return user;
	},
	_checkGDPR:function(user) {
		if (!user)
			return;

        let termsConditionsKey = "bf_terms_and_conditions";
        let privacyPolicyKey = "bf_privacy_policy";

        customRegistration.getSettings(null, function(err, result) {
            let keys = [termsConditionsKey, privacyPolicyKey];
        	if(!err && result) {
                let termsConditionsAndPrivacyPolicy = result.singlePage.formControls.find(function(item){return item && item.id === 'termsConditionsAndPrivacyPolicy'});
                if(termsConditionsAndPrivacyPolicy.settings && termsConditionsAndPrivacyPolicy.active && termsConditionsAndPrivacyPolicy.settings.termsAndConditionsDocumentKey)
				{
                    keys.push(termsConditionsAndPrivacyPolicy.settings.termsAndConditionsDocumentKey);
				}
                if(termsConditionsAndPrivacyPolicy.settings && termsConditionsAndPrivacyPolicy.active && termsConditionsAndPrivacyPolicy.settings.privacyPolicyDocumentKey)
                {
                    keys.push(termsConditionsAndPrivacyPolicy.settings.privacyPolicyDocumentKey);
                }
			}
            let url = siteConfig.endPoints.crmHost + "/documents/" + keys.join(",") + "/check?userKey=" + encodeURIComponent(user.username);
            if ((bfUtils.isAppHtml5Version || bfUtils.isMobileDevice ||bfUtils.isPwaAndroid||bfUtils.isPwaiOS)
                && window.appContext && window.appContext.liveMode==1 ) {
                bfUtils.http.get(url).success(function (result) {
                    if (result) {
                    	for(let keyIndex = 0; keyIndex < keys.length; keyIndex++) {
                    		if(result[keys[keyIndex]] && !result[keys[keyIndex]].isAccepted) {
                                window.location.hash = 'gdpr';
                                break;
							}
						}
                    }
                }).error(
                    function (err) {
                        console.error(err);
                    }
                );
            }
		});
	},
	logout: function () {
		this._setCurrentUser(null);
		authAPI.triggerOnLogout(null);
	},
	trackRegister: function(user) {
		//track register only on live mode
        if (window.appContext && window.appContext.liveMode) {
			var analyticsAPI = new AnalyticsAPI(authAPI.context);
			analyticsAPI.setUserProperties({email: user.email, username: user.username, firstName: user.firstName, lastName: user.lastName});
			analyticsAPI.trackAction('app/userRegistered');

			var historyUsersItem = localStorage.getItem('HISTORY_USERS');
			if(historyUsersItem) {
				var historyUsers = JSON.parse(historyUsersItem);
				if(historyUsers.length && historyUsers.indexOf(user._id) == -1) {
					historyUsers.push(user._id);
					localStorage.setItem('HISTORY_USERS', JSON.stringify(historyUsers));
				}
			} else {
				localStorage.setItem('HISTORY_USERS', JSON.stringify([user._id]));
			}
		}
	},
	onLogin: function (callback) {
		document.addEventListener('AUTH_CURRENT_USER_ON_LOGIN', callback, false);
	},
	onLogout: function (callback) {
		document.addEventListener('AUTH_CURRENT_USER_ON_LOGOUT', callback, false);
	},
	onUpdate: function (callback) {
		document.addEventListener('AUTH_CURRENT_USER_ON_UPDATE', callback, false);
	},
	triggerOnUpdate: function (user) {
		if (!user)
			user = authAPI.getCurrentUser();
		var onUpdateEvent = new CustomEvent('AUTH_CURRENT_USER_ON_UPDATE', {'detail': user});
		document.dispatchEvent(onUpdateEvent);
	},
	triggerOnLogin: function (user) {
		var onUpdateEvent = new CustomEvent('AUTH_CURRENT_USER_ON_LOGIN', {'detail': user});
		document.dispatchEvent(onUpdateEvent);
	},
	triggerOnLogout: function () {
		var onUpdateEvent = new CustomEvent('AUTH_CURRENT_USER_ON_LOGOUT', {'detail': null});
		document.dispatchEvent(onUpdateEvent);
	},
	openProfile: function (userId) {
		if (userId) return open(userId);

		let user = this.getCurrentUser();
		if (user && user._id) return open(user._id);

		this.login({}, function (err, user) {
			if (!err && user && user._id) {
				open(user._id);
			};
		});

		function open(id) {
			window.location.hash = "userProfile/" + id;
		}
	},
	getUserProfile: function (options, callback) {
		if (!options || !options.userId) {
			throw new Error("userId have not been provided to getUserInfo");
			return;
		}

		var userInfo = null;

		var getUserSocial = function () {
			var data = {
				"id": 1, "method": "users/getUserProfile",
				"params": {userId: options.userId}
			};

			var url = window.siteConfig.endPoints.socialHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

            bfUtils.http.jsonp(url, {bypassInterceptorForStatus: 404})
				.success(function (result) {
                        if (callback) {
                            if (result && result.result) {
                                userInfo = angular.extend({}, result.result, userInfo);
                                if (userInfo) {
                                    callback(null, userInfo);
                                }
                                else
                                    callback(null, null);
                            }else
                                callback(null, userInfo);
                        }
				})
				.error(function (data, status, headers, config) {
					if (callback)
						callback(data, null);
				});
		};

		var data = {
			"id": 1, "method": "users/getPublicUser",
			"params": {userId: options.userId, externalAppId: window.currentAppId}
		};

		var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        bfUtils.http.jsonp(url, {bypassInterceptorForStatus: 404})
			.success(function (result) {
				if (callback) {
					if (result && result.result) {
						userInfo = result.result;
						getUserSocial();
					}
					else
						callback(null, null);
				}
			})
			.error(function (data, status, headers, config) {
				console.error(data);
				if (callback)
					callback(data, null);
			});
	},
	getUsersByEmail: function (options, callback) {
		if (!options || !options.emails) {
			throw new Error("No emails have not been provided to getUserByEmail");
			return;
		}

		var mergeResults = function(users , profiles){
			for(var i=0;i < users.length ; i++){
				for(var j=0 ; j < profiles.length ;j++){
                    if(users[i].email == profiles[j].email){
                        users[i].phone = profiles[j].phone;
					}
				}
			}

			callback(null,users);

		};

		var getProfiles = function(users){
            var data = {
                "id": 1, "method": "users/getUsersProfilesByEmail",
                "params": {emails: options.emails}
            };

            var url = window.siteConfig.endPoints.socialHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

            bfUtils.http.jsonp(url, {bypassInterceptorForStatus: 404})
                .success(function (result) {
                    if (callback) {
                        if (result && result.result) {
                            mergeResults(users , result.result);
                        }
                        else
                            callback(null, users);
                    }
                })
                .error(function (data, status, headers, config) {
                    console.error(data);
                    if (callback)
                        callback(data, null);
                });
		};


        var data = {
            "id": 1, "method": "users/getUsersByEmail",
            "params": {emails: options.emails, externalAppId: window.currentAppId}
        };

        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        bfUtils.http.jsonp(url, {bypassInterceptorForStatus: 404})
            .success(function (result) {
                if (callback) {
                    if (result && result.result) {
                        getProfiles(result.result);
                    }
                    else
                        callback(null, null);
                }
            })
            .error(function (data, status, headers, config) {
                console.error(data);
                if (callback)
                    callback(data, null);
            });
    },
	getUserPictureUrl:function (params) {
        var key = null;
        var value = null;
        if (!params) {
            params = {};
        }
        if (params.userId) {
            key = 'userId';
            value = params.userId;
        }
        if (params.email) {
            key = 'email';
            value = params.email;
        }
        if (params.username) {
            key = 'username';
            value = params.username;
        }
        if(!key || !value)
        	throw Error('Invalid user picture params');

        value = encodeURIComponent(value);

        return window.siteConfig.endPoints.authHost + "/src/server.js/user/picture?" + key + "=" + value
			+ '&externalAppId=' + encodeURIComponent(window.currentAppId);
    }
};
authAPI.initRefresh();
$app.controller('modalCtrl', ['$scope', '$dialog', '$data', function ($scope, $dialog, $data) {
    $scope.modal = {};

    $scope.modal.body = $data.body;

    $scope.modal.title = ($data.title) ? $data.title : 'Confirm';
    $scope.modal.okText = ($data.okText) ? $data.okText : "OK";
    $scope.modal.cancelText = ($data.cancelText) ? $data.cancelText : "Cancel";
    $scope.modal.disableCancel = ($data.disableCancel) ? $data.disableCancel : false;

    $scope.close = function () {
        $dialog.close(false);
    };

    $scope.confirm = function () {
        $dialog.close(true);
    };
}]);
setTimeout(function(){
    if(sessionStorage.getItem('notification')){
        try{
            var notification = JSON.parse(sessionStorage.getItem('notification'));
            LocalNotificationsAPI.navToPlugin(notification);
        }
        finally{
            sessionStorage.removeItem('notification');
        }
    }
}, 2000);

var LocalNotificationsAPI = function(){
    var webNotificationsQueue = {};
    var pluginMissingError = "Cordova notification plugin not installed";

    function _LocalNotificationsAPI(context){
        this.context = context;
    }

    _LocalNotificationsAPI.prototype = {
        schedule: function (notification, callback) {
            var id = generateId();
            var now = new Date();

            if (_LocalNotificationsAPI.isPluginAvailable()) {
                //Don't allow users to specify badge options
                notification.badge = 0;

                //If the send time isn't specified, send it real soon
                if(!notification.at){
                    notification.at = new Date(now.getTime() + 250);
                }
                else{
                    notification.at = Date.parse(notification.at);
                }

                notification.id = id;

                notification.data = {
                    actionItem: notification.actionItem,
                    pluginData: notification.data,
                    returnInstanceId: notification.returnToPluginInstanceId || this.context.instanceId,
                    launchInstanceId: this.context.instanceId,
                    pluginId: this.context.pluginId,
                    analyticsData: notification.analyticsData
                };

                cordova.plugins.notification.local.schedule(notification);

                callback(null, {id: notification.id});
            }
            else {
                var diff = Math.abs(Date.parse(notification.at) - Date.now());

                //Don't send old notifications, give or take a few seconds
                if (diff < -2000) {
                    return;
                }

                notification.data = {
                    actionItem: notification.actionItem,
                    pluginData: notification.data,
                    returnInstanceId: notification.returnToPluginInstanceId || this.context.instanceId,
                    launchInstanceId: this.context.instanceId,
                    pluginId: this.context.pluginId,
                    analyticsData: notification.analyticsData
                };

                var timer = setTimeout(function () {
                    if (notificationInWebQueue(id)) {
                        _LocalNotificationsAPI.notificationModal(notification);
                        removeFromWebQueue(id);
                    }
                }, diff);

                webNotificationsQueue[id] = timer;
                callback(null, {id: id});
            }
        }
        , cancel: function (id, callback) {
            if (_LocalNotificationsAPI.isPluginAvailable()) {
                cordova.plugins.notification.local.cancel(id);
                callback(null, {id: id});
            }
            else if (!isDevice()) {
                removeFromWebQueue(id);
                callback(null, {id: id});
            }
            else {
                callback(new Error(pluginMissingError), null);
            }
        }

        , checkPermission: function (data, callback) {
            if(!isDevice()){
                //Special permissions aren't required in web, so we return true
                if (callback) callback(null, true);
                return;
            }

            if (!_LocalNotificationsAPI.isPluginAvailable()) {
                if (callback) callback(new Error(pluginMissingError), false);

                console.warn(pluginMissingError);
                return;
            }

            cordova.plugins.notification.local.hasPermission(function (granted) {
                if (callback) callback(null, granted);
            });
        }

        , requestPermission: function (data, callback) {
            if(!isDevice()){
                //Special permissions aren't required in web, so we return true
                if (callback) callback(null, true);
                return;
            }

            /// ask only if permission hasn't been granted
            if (!_LocalNotificationsAPI.isPluginAvailable()) {
                if (callback) callback(new Error(pluginMissingError), false);

                console.warn(pluginMissingError);
                return;
            }

            cordova.plugins.notification.local.hasPermission(function (granted) {
                if (granted) {
                    if (callback)callback(null, true);
                }
                else {
                    cordova.plugins.notification.local.registerPermission(function (registerGranted) {
                        if (registerGranted) {
                            if (callback)callback(null, true);
                        }
                        else {
                            console.warn('Permission not granted for local notifications');
                            if (callback)callback(null, false);
                        }
                    });
                }
            });
        }
    };

    function generateId(){
        //Note: ID must be 9 digits or less
        return Math.floor(Math.random() * 1000000000);
    }

    function notificationInWebQueue(id){
        return (webNotificationsQueue.hasOwnProperty(id));
    }

    function removeFromWebQueue(id){
        if(notificationInWebQueue(id)){
            clearTimeout(webNotificationsQueue[id]);
            delete webNotificationsQueue[id];
        }
    }

    function isDevice(){
        return (typeof(cordova) != "undefined");
    }

    _LocalNotificationsAPI.isPluginAvailable = function(){
        var isAvailable = true;

        if(typeof(cordova) == "undefined"
            || !cordova.plugins
            || !cordova.plugins.notification
            || !cordova.plugins.notification.local) {

            isAvailable = false;
        }

        return isAvailable;
    };

    _LocalNotificationsAPI.getPlatform = function(){
        return device.platform ? device.platform.toLowerCase()  : '';
    };

    _LocalNotificationsAPI.notificationModal = function(notification){
        if (!notification || (!notification.title && !notification.text)) {
            return;
        }
        var options = {
            data: {title: notification.title, body: notification.text}
        };

        window.openDialog(options, function(result){

            if(result){
                _LocalNotificationsAPI.navToPlugin(notification);
            }
        });
    };

    _LocalNotificationsAPI.navToPlugin = function(notification){
        var _nav = function() {
            var delay = 2000;
            var actions = {
                    doNothing: 0,
                    sendToLauncher: 1,
                    sendToPlugin: 2
                },
                action = actions.sendToPlugin,
                returnInstanceId;

            if(typeof notification.data !== 'object' )
                notification.data = JSON.parse(notification.data);

            // if an action is available apply the action
            if(notification.data.actionItem){
                //Perform action
                ActionItemsAPI.prototype.execute(notification.data.actionItem, function(err, wasSuccess){
                });
            }

            returnInstanceId = (notification.data.returnInstanceId)
                ? notification.data.returnInstanceId.toLowerCase() : '';

            if(returnInstanceId == 'home' || returnInstanceId == 'none')
                action = actions.doNothing;
            else if(postMaster.launcherPluginAPI && postMaster.launcherPluginAPI.context &&
                postMaster.launcherPluginAPI.context.instanceId == returnInstanceId)
                action = actions.sendToLauncher;

            if(action === actions.doNothing){
                return;
            }

            if (actions === actions.sendToLauncher) {
                delay = 500;

                postMaster.launcherPluginAPI.navigation.navigateHome();
            }
            else{
                action = actions.sendToPlugin;

                if (postMaster.widgetPluginAPI && postMaster.widgetPluginAPI.context &&
                    postMaster.widgetPluginAPI.context.instanceId == notification.data.returnInstanceId){
                    delay = 500;
                }
                else{
                    postMaster.launcherPluginAPI.navigation.navigateToPluginInstance({
                        instanceId: notification.data.returnInstanceId
                    });
                }
            }

            setTimeout(function(){
                var packet = new Packet(null, 'notifications.localNotification.onClick', notification.data.pluginData);

                if(action === actions.sendToLauncher){
                    postMaster.launcherPluginAPI.sendMessage(null, packet);
                }
                else {
                    postMaster.widgetPluginAPI.sendMessage(null, packet);
                }
            }, delay);
        };

        var initialDelay = postMaster.launcherPluginAPI ? 0 : 1500;
        setTimeout(function(){
            if(postMaster.launcherPluginAPI){
                _nav();
            }
        }, initialDelay);
    };

    _LocalNotificationsAPI.sendAnalytics = function (notification) {
        if (notification && notification.data) {
            if (typeof notification.data !== 'object')
                notification.data = JSON.parse(notification.data);
            if (notification.data && notification.data.analyticsData && notification.data.analyticsData.eventName) {
                var analyticsAPI = new AnalyticsAPI(window.appContext.currentApp.appId, notification.data.pluginId, notification.data.launchInstanceId, window.appContext.liveMode);
                analyticsAPI.trackAction(notification.data.analyticsData.eventName, notification.data.analyticsData.metaData);
            }
        }
    };

    return _LocalNotificationsAPI;
}();

if (bfUtils.isMobileDevice) {
    appState.subscribe({state: appState.RUNNING}, function () {
        if(LocalNotificationsAPI.isPluginAvailable()){
            //iOS: Triggers when a notification fires and the app is in focus
            //Android: Triggers when a notification fires, regardless of the app being in focus or not
            cordova.plugins.notification.local.on("trigger", function(notification) {
                console.log('*** notification trigger ***');
                LocalNotificationsAPI.sendAnalytics(notification);
                if(LocalNotificationsAPI.getPlatform() == "ios"){
                    LocalNotificationsAPI.notificationModal(notification);
                }
            });

            //Fired when user clicks on a notification
            //iOS: A notification is only fired if the app is not in focus
            //Android: A notification is always fired.
            cordova.plugins.notification.local.on("click", function(notification) {
                console.log('*** notification click ***');
                LocalNotificationsAPI.sendAnalytics(notification);
                LocalNotificationsAPI.navToPlugin(notification);
            });
        }
    });
}

/**
 * Created by danielhindi on 9/14/16.
 */

var localStorageAPI = {
    _prefix : '_bfls_'
    ,setItem: function(keyValue,callback){
        if(!keyValue
            || !keyValue.key
            || !keyValue.value)
            callback(new Error("invalid parameters. Expected Key/Value object"));
        else{
            localStorage.setItem(localStorageAPI._prefix   + keyValue.key, keyValue.value);
            callback(null,true);
        }
    }
    ,getItem: function(key,callback){

        if(key && key.key) key=key.key;

        if(!key
            || !callback)
            callback(new Error("invalid parameters. Expected Key and Callback"));
        else{
            var val = localStorage.getItem(localStorageAPI._prefix + key);
            callback(null,val);
        }
    }
    ,removeItem: function(key,callback){

        if(key && key.key) key=key.key;

        if(!key
            || !callback)
            callback(new Error("invalid parameters. Expected Key and Callback"));
        else{
            localStorage.removeItem(localStorageAPI._prefix + key);
            callback(null,true);
        }
    }
};


var validator = {
    validatePassword: function(password, options) {
        let simplePasswordValidation = options && options.simplePasswordValidation;
        if(simplePasswordValidation) {
            return password && password.length >= 6 && password.length <= 60
        } else {
            //8 char min, Capital and small, number and symbol
            if (!password || password.length < 8 || password.length > 60)
                return false;
            var hasUpperCase = /[A-Z]/.test(password);
            var hasLowerCase = /[a-z]/.test(password);
            var hasNumbers = /\d/.test(password);
            var hasNonalphas = /\W/.test(password);

            return (hasUpperCase && hasLowerCase && hasNumbers && hasNonalphas);
        }

    },
    validateEmail: function(email) {
        if (!email)
            return false;
        return /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,24}$/.test(email);
    },
    passwordPattern: {
        test: function (value) {
            return validator.validatePassword(value);
        }
    }
};
"use strict";

/**
 * Created by Ayman on 1/10/2018.
 */

function PushNotificationsAPI(context) {
    this.context = context;
}

PushNotificationsAPI.prototype = {
    ///params: {title, text, at, groupName, users, usersTags, queryString}
    schedule: function (params, callback) {
        if (!params || !params.text || !params.title) {
            if (callback)
                callback('text or title is empty');
            return;
        }
        if (!this.context || !this.context.instanceId) {
            if (callback)
                callback('instanceId is null, unable to build groupID');
            return;
        }
        if (!params.at)
            params.at = new Date();
        if (!params.groupName) {
            params.groupName = '';
        }

        var data = {
            groupID: PushNotificationsAPI._getGroupID(this.context, params.groupName),
            users: params.users,
            userTags: params.userTags,
            title: params.title,
            message: params.text,
            sendAfter: params.at,
            source: "plugin",
            richMessage: params.inAppMessage || undefined
        };
        data.sourceId = window.appContext.currentApp.appId + "_" + this.context.instanceId + "_" + data.source;

        if(params.actionItem !== false){
            if(params.actionItem){
                data.actionItem = params.actionItem;
            }
            else {
                data.actionItem = {
                    title: 'View',
                    action: 'linkToApp',
                    instanceId: this.context.instanceId,
                    queryString: params.queryString
                };
            }
        }

        authAPI.getCurrentUser(function (err, user) {
            data.authCreatedBy = (user && user._id) ? user._id.toString() : null;

            bfUtils.http.post(window.siteConfig.endPoints.pushV2 + "/api/app/" + window.appContext.currentApp.appId + "/notification/", data)
                .success(function (result) {
                    if (callback)
                        callback(null, result);
                })
                .error(function (data, status, headers, config) {
                    if (callback)
                        callback(data);
                });
        });
    },
    ///params: id
    cancel: function (id, callback) {
        if (!id) {
            if (callback)
                callback('id is empty');
            return;
        }
        if (!this.context || !this.context.instanceId) {
            if (callback)
                callback('instanceId is null, unable to build groupID');
            return;
        }
        var data = {
            source: "plugin"
        };
        data.sourceId = window.appContext.currentApp.appId + "_" + this.context.instanceId + "_" + data.source;

        authAPI.getCurrentUser(function (err, user) {
            data.authCanceledBy = (user && user._id) ? user._id.toString() : null;

            bfUtils.http.post(window.siteConfig.endPoints.pushV2 + "/api/app/" + window.appContext.currentApp.appId +
                "/notification/" + id + '/cancel', data)
                .success(function (result) {
                    if (callback)
                        callback(null, true);
                })
                .error(function (data, status, headers, config) {
                    if (callback)
                        callback(data);
                });
        });
    },
    ///params: {groupName}
    subscribe: function (params, callback) {
        if (!params)
            params = {};
        if (!params.groupName)
            params.groupName = '';
        if (!this.context || !this.context.instanceId) {
            if (callback)
                callback('instanceId is null, unable to build groupID');
            return;
        }
        var groupID = PushNotificationsAPI._getGroupID(this.context, params.groupName);
        PushNotificationsAPI._subscribe({groupID: groupID}, callback);
    },
    ///params: {groupName}
    unsubscribe: function (params, callback) {
        if (!params)
            params = {};
        if (!params.groupName)
            params.groupName = '';
        if (!this.context || !this.context.instanceId) {
            if (callback)
                callback('instanceId is null, unable to build groupID');
            return;
        }
        var groupID = PushNotificationsAPI._getGroupID(this.context, params.groupName);
        PushNotificationsAPI._unsubscribe({groupID: groupID}, callback);
    }
};

PushNotificationsAPI._getGroupID = function (context, groupName) {
    return window.appContext.currentApp.appId + "_" + context.instanceId + "_" + groupName;
};

PushNotificationsAPI._unsubscribe = function (params, callback) {
    if (!window.push || !window.push.deviceId || !window.push.platform) {
        if (callback)
            callback('Device not ready to get the deviceId');
        return;
    }
    if (!params) {
        params = {};
    }
    if (!params.groupID) {
        callback('groupID is not specified');
        return;
    }

    authAPI.getCurrentUser(function (err, user) {
        params.deviceID = push.deviceId;
        params.os = window.push.platform ? window.push.platform.toLowerCase() : '';
        params.authUserId = (user && user._id) ? user._id.toString() : null;

        bfUtils.http.post(window.siteConfig.endPoints.pushV2 + "/api/app/" + window.appContext.currentApp.appId + "/unsubscribe/", params)
            .success(function (result) {
                if (callback)
                    callback(null, true);
            })
            .error(function (data, status, headers, config) {
                if (callback)
                    callback(data);
            });
    });
};

PushNotificationsAPI._getSubscriptions = function(callback) {
    if (!window.push || !window.push.deviceId || !window.push.platform) {
        if (callback)
            callback('Device not ready to get the deviceId');
        return;
    }

    let pushV2 = window.siteConfig.endPoints.pushV2;
    let appId = window.appContext.currentApp.appId;
    let url = `${pushV2}/api/app/${appId}/subscriptions/`;

    let options = {
        deviceID: push.deviceId,
        os: window.push.platform ? window.push.platform.toLowerCase() : ''
    };

    bfUtils.http.post(url, options)
        .success(result => callback(null, result))
        .catch(err => callback(err, null));
};

PushNotificationsAPI._subscribe = function (params, callback) {
    if (!window.push || !window.push.deviceId || !window.push.platform) {
        if (callback)
            callback('Device not ready to get the deviceId');
        return;
    }
    if (!params) {
        params = {};
    }
    if (!params.groupID) {
        params.groupID = '';
    }

    authAPI.getCurrentUser(function (err, user) {
        var pushSupportsFCM = typeof(PushNotification) !== "undefined" && typeof(PushNotification.listChannels) !== "undefined";
        var isFCM = device.platform && device.platform.toLowerCase() === "android" && pushSupportsFCM;

        params.deviceID = push.deviceId;
        params.os = window.push.platform ? window.push.platform.toLowerCase() : '';
        params.authUserId = (user && user._id) ? user._id.toString() : null;
        params.device = typeof device !== 'undefined' ? device : null;
        params.deliveryMethod = isFCM ? 'FCM' : null;

        var currentPushDeviceID = localStorage.getItem("currentPushDeviceID");
        if(currentPushDeviceID && currentPushDeviceID !== push.deviceId) {
            params.oldDeviceID = currentPushDeviceID;
        }

        bfUtils.http.post(window.siteConfig.endPoints.pushV2 + "/api/app/" + window.appContext.currentApp.appId + "/subscribe/", params)
            .success(function (result) {
                localStorage.setItem("currentPushDeviceID", push.deviceId);
                if (callback)
                    callback(null, true);
            })
            .error(function (data, status, headers, config) {
                if (callback)
                    callback(data);
            });
    });
};

(function () {
    authAPI.onLogin(function () {
        setTimeout(function () {
            PushNotificationsAPI._subscribe();
        }, 2000);
    });
    authAPI.onLogout(function () {
        setTimeout(function () {
            PushNotificationsAPI._subscribe();
        }, 2000);
    });
})();

"use strict";

/**
 * Created by Ayman on 4/4/2018.
 */

function FirebaseAPI(context) {
    this.context = context;
}

FirebaseAPI.prototype = {
    createCustomToken: function (params, callback) {
        var self = this;

        function firebaseLogin(user) {
            FirebaseAPI._getUser({
                instanceId: self.context.instanceId,
                appId: window.appContext.currentApp.appId,
                integrationToken: params.integrationToken
            }, function (err, currentUser) {
                if (!currentUser || (params && params.forceLogin)) {
                    //call login api
                    bfUtils.http.post(window.siteConfig.endPoints.appHost + "/api/user/firebase/login",
                        {
                            authUserId: user._id,
                            authAccessToken: user.accessToken,
                            pluginTypesToken: self.context.pluginId,
                            appId: window.appContext.currentApp.appId,
                            instanceId: self.context.instanceId,
                            integrationToken: params.integrationToken
                        })
                        .success(function (result) {
                            FirebaseAPI._setUser({
                                instanceId: self.context.instanceId,
                                appId: window.appContext.currentApp.appId,
                                integrationToken: params.integrationToken
                            }, result);
                            if (callback)
                                callback(null, result);
                        })
                        .error(function (data, status, headers, config) {
                            if (status == 401 || status == 403) {
                                authAPI.logout();
                                authAPI.login({}, function (err, user) {
                                    if (user) {
                                        firebaseLogin(user);
                                    }
                                    else {
                                        if (callback)
                                            callback(null, null);
                                    }
                                });
                            }
                            else {
                                if (callback)
                                    callback(data);
                            }
                        });
                }
                else {
                    if (callback)
                        callback(null, currentUser);
                }
            });
        }

        authAPI.getCurrentUser(function (err, user) {
            if (user) {
                firebaseLogin(user);
            }
            else {
                authAPI.login({}, function (err, user) {
                    if (user) {
                        firebaseLogin(user);
                    }
                    else {
                        if (callback)
                            callback(null, null);
                    }
                });
            }
        });
    }
};

(function () {
    //cache the custom user login per appId and instanceId for max 1 hour
    var users = {};

    FirebaseAPI._getUser = function (params, callback) {
        var key = params.appId + "_" + params.instanceId + "_" + params.integrationToken;
        var user = users[key];
        var prvHour = new Date();
        prvHour.setMinutes(prvHour.getMinutes() - 60);
        if (user && user.createdOn > prvHour) {
            callback(null, user.value);
        }
        else {
            users[key] = undefined;
            callback(null, null);
        }
    };
    FirebaseAPI._setUser = function (params, value) {
        var key = params.appId + "_" + params.instanceId + "_" + params.integrationToken;
        users[key] = {
            createdOn: new Date(),
            value: value
        };
    };

    authAPI.onLogout(function () {
        users = {};
    });
})();
function PublicFilesAPI(context) {
    this.context = context;
    this.currentUser = null;
};

PublicFilesAPI.prototype = {
    showDialog: function (options, callback) {
        if (!options)
            options = {};

        var self = this;

        var form;

        form = document.getElementById('publicFiles_input_form');

        if (!form) {
            form = document.createElement('form');
            form.setAttribute("id", "publicFiles_input_form");
            document.body.appendChild(form);
        } else {
            form.innerHTML = '';
        }

        var fileInput = document.createElement('input');
        fileInput.setAttribute("type", "file");
        fileInput.setAttribute("style", "display:none");
        fileInput.setAttribute("id", "publicFilesHiddenInput" + new Date().toISOString());
        form.appendChild(fileInput);

        if (options && options.allowMultipleFilesUpload) {
            fileInput.setAttribute("multiple", "");
            fileInput.setAttribute("name", "files[]");
        }

        if (options && options.filter)
            fileInput.accept = options.filter.join(',');

        fileInput.addEventListener("change", function () {
            self.uploadFiles(this.files, options, callback);
        }, false);

        // setTimeout(function () {
        fileInput.click();
        // });
    }, 
    uploadFiles: function (files, options, callback) {
        var promises = [];
        var onProgressResult = [];
        var self = this;

        if (!callback && typeof options === 'function') {
            callback = options;
            options = {};
        }

        if (!options) options = {};

        var analyticsAPI = new AnalyticsAPI(self.context.appId, self.context.pluginId, self.context.instanceId, window.appContext.liveMode);

        authAPI.getCurrentUser(function (err, user) {
            if (user) {
                self.currentUser = user;
            }

            _uploadFiles(files);
        });

        function upload(file, resultFile) {
            return new Promise(function (resolve, reject) {
                var valid = true;
                if (options.filter && !validateFileExtension(file, options.filter)) {
                    resultFile.status = 'failed';
                    resultFile.error = 'invalid File Format';
                    if (self._onComplete)
                        self._onComplete(resultFile);
                    valid = false;
                    resolve(resultFile);
                }

                if (!validateFileSize(file)) {
                    resultFile.status = 'failed';
                    resultFile.error = 'invalid File Size';
                    if (self._onComplete)
                        self._onComplete(resultFile);
                    valid = false;
                    resolve(resultFile);
                }

                if (valid) {
                    var formData = new FormData();
                    formData.append("file", file);
                    formData.append('pluginId', self.context.pluginId);
                    formData.append('instanceId', self.context.instanceId);
                    formData.append('appId', self.context.appId);

                    if (self.currentUser && self.currentUser.accessToken)
                        formData.append('accessToken', self.currentUser.accessToken);

                    var xhr = new XMLHttpRequest();
                    xhr.upload.addEventListener("progress", function (e) {
                        if (e.lengthComputable) {
                            var percentage = Math.round((e.loaded * 100) / e.total);
                            resultFile.percentage = percentage;
                            if (self._onProgress)
                                self._onProgress(resultFile);
                        }
                    }, false);

                    xhr.onload = function () {

                        var result = null;
                        if (xhr.responseText) {
                            try {
                                result = JSON.parse(xhr.responseText);
                            } catch (e) {
                            }
                        }

                        if (xhr.status == 200) {
                            resultFile.url = result.url;
                            resultFile.size = result.size;
                            resultFile.type = result.type;
                            resultFile.status = 'success';

                            var analyticsMetaData = {
                                data: {
                                    url: result.url,
                                    size: result.size,
                                    type: result.type
                                },
                                _buildfire : {aggregationValue: result.size}
                            };

                            //send to Analytics
                            if (window.siteConfig.scope == 'app') {
                                analyticsAPI.trackAction('app/publicFilesUpload', analyticsMetaData);
                            }
                            else {
                                analyticsAPI.trackAction('cp/publicFilesUpload', analyticsMetaData);
                            }
                        } else {
                            resultFile.status = 'failed';
                            if (result.message)
                                resultFile.error = result.message;
                            else
                                resultFile.error = "An error has occurred";
                        }

                        if (self._onComplete)
                            self._onComplete(resultFile);
                        resolve(resultFile);
                    };

                    xhr.onerror = function () {
                        resultFile.status = 'failed';
                        if (self._onComplete)
                            self._onComplete(resultFile);
                        resolve(resultFile);
                    };

                    xhr.timeout = 60000;
                    xhr.open("POST", window.siteConfig.endPoints.publicFilesHost + "/publicFiles/upload/");
                    xhr.send(formData);
                }
            });
        }

        function validateFileExtension(file, filter) {
            for (var i = 0; i <= filter.length; i++) {
                if (filter[i] == file.type) {
                    return true;
                }
            }

            return false;
        };

        function validateFileSize(file) {
            if (file.size > 26214400)/*25MB*/
                return false;
            else
                return true;
        };

        function _uploadFiles(files) {
            for (var i = 0; i < files.length; i++) {
                var _resultFile = {fileId: i, filename: files[i].name};
                files[i].fileId = i;
                onProgressResult.push(_resultFile);
                promises.push(upload(files[i], _resultFile));
            }

            Promise.all(promises).then(function (files) {
                callback(null, files);
            }).catch(() => {
                callback(true, null);
            });
        };
    },
    onProgress: function (callback) {
        this._onProgress = callback;
    }, onComplete: function (callback) {
        this._onComplete = callback;
    }
};

const imagePreviewerAPI = {

  /**
   * Shows the image slider
   */
  show(options, callback) {
    if (!this.initialized) this.renderHTML();
    let pswpElement = document.querySelectorAll('.pswp')[0];
    callback = callback || Function.prototype;

    let pswpOptions = {
      index: options.index >= 0 ? options.index : 0,
      history: false,
      counterEl: false,
      captionEl: false,
      fullscreenEl: false,
      zoomEl: false,
      arrowEl: false,
      preloaderEl: false,
      shareEl: false,
      tapToToggleControls: false,
      correctOrientation: true
    };

    let ui = window.PhotoSwipeUI_Default;

    if(!options || !options.images || !options.images.length){
      return;
    }

    // Fix for those that don't follow the spec
    if (options.images[0] && options.images[0].name) {
      options.images = options.images.map(img => img.name);
    }

    let imagePromises = [];
    function preLoad() {
      options.images.forEach(src => {
          let promise = new Promise((resolve) => {
            let image = new Image();
            image.onload = () => resolve(image);
            image.src = `https://czi3m2qn.cloudimg.io/cdno/n/q1/${src}`;
          });
          imagePromises.push(promise);
      });
    }
    window.spinner.show();
    preLoad();

    Promise.all(imagePromises).then(images => {
      let itemPromises = [];
      images.forEach(preloadedImg => {
        itemPromises.push(new Promise(resolve => {
          EXIF.getData(preloadedImg, function() {
            let orientation = EXIF.getTag(this, 'Orientation');
            let { src, naturalHeight, naturalWidth } = preloadedImg;
            src = src.replace(/q1/, 'n');
            if (orientation === 3 || orientation === 6) {
              resolve({
                src: `https://czi3m2qn.cloudimg.io/crop/${naturalHeight}x${naturalWidth}/q100.i1/${src}`,
                msrc: `https://czi3m2qn.cloudimg.io/crop/${Math.round(naturalHeight / 3)}x${Math.round(naturalWidth / 3)}/q25.i1/${src}`,
                w: naturalHeight,
                h: naturalWidth
              })
            } else {
              resolve({
                src: `https://czi3m2qn.cloudimg.io/crop/${naturalWidth}x${naturalHeight}/q100.i1/${src}`,
                msrc: `https://czi3m2qn.cloudimg.io/crop/${Math.round(naturalWidth / 3)}x${Math.round(naturalHeight / 3)}/q25.i1/${src}`,
                w: naturalWidth,
                h: naturalHeight
              })
            }
          });
        }))
      });

      Promise.all(itemPromises).then(items => {
        window.pswp = new PhotoSwipe(pswpElement, ui, items, pswpOptions);
        window.pswp.listen('close', callback);
        window.pswp.init();
        window.spinner.hide();
      });
    });
  },

  /**
   * Renders the initial html needed for the image previewer.
   * Should be run only once.
   */
  renderHTML() {
    let container = document.createElement('div');
    container.style.position = 'relative';
    container.style.zIndex = 99999999;

    container.innerHTML = `
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
    <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

        <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
        <div class="pswp__bg"></div>

        <!-- Slides wrapper with overflow:hidden. -->
        <div class="pswp__scroll-wrap">

            <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
            <div class="pswp__container">
                <div class="pswp__item"></div>
                <div class="pswp__item"></div>
                <div class="pswp__item"></div>
            </div>

            <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
            <div class="pswp__ui pswp__ui--hidden">

                <div class="pswp__top-bar" style="background: transparent !important; padding-top: env(safe-area-inset-top); padding-top: const(safe-area-inset-top);">

                    <!--  Controls are self-explanatory. Order can be changed. -->

                    <div class="pswp__counter"></div>

                    <span class="glyphicon glyphicon-remove pswp__button pswp__button--close" title="Close (Esc)" style="color: #FFF !important;font-size: 20pt;padding: 15px;width:55px;height:55px">
                    </span>

                    <button class="pswp__button pswp__button--share" title="Share"></button>

                    <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                    <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                    <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                    <!-- element will get class pswp__preloader--active when preloader is running -->
                    <div class="pswp__preloader">
                        <div class="pswp__preloader__icn">
                          <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                          </div>
                        </div>
                    </div>
                </div>

                <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                    <div class="pswp__share-tooltip"></div>
                </div>

                <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
                </button>

                <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
                </button>

                <div class="pswp__caption">
                    <div class="pswp__caption__center"></div>
                </div>

            </div>

        </div>

    </div>
    `;

    if (window.location.pathname.toLowerCase().indexOf('plugintester') >= 0) {
      document.getElementById('app').appendChild(container);
    } else {
      document.body.appendChild(container);
    }

    this.initialized = true;
  }

};

function searchEngineAPI(context) {
    this.context = context;
};

searchEngineAPI.prototype = {
    _sendRequest: function (verb, method, data, cb) {
        var json = "";
        var xhr = new XMLHttpRequest();
        var url = window.siteConfig.endPoints.searchEngineHost + "/search_engine/" + method;

        verb = verb.toUpperCase();
        if (verb === "GET" && data) {
            var query = "?";

            for (var key in data) {
                if (data.hasOwnProperty(key)) {
                    query += key + "=" + encodeURIComponent(data[key]) + "&";
                }
            }

            query = query.slice(0, -1);
            url += query;
        } else {
            json = JSON.stringify(data);
        }

        xhr.open(verb, url, true);
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.setRequestHeader("app_id", this.context.appId);
        xhr.setRequestHeader("x-api-key", "GpzNPRVIld3WxoKDAXJZM7cjoUA5p0rS6pqYkCqy");//keep this hardcoded
        xhr.onreadystatechange = function () {
            var response = null;
            try {
                response = JSON.parse(xhr.responseText);
            } catch (e) {

            }
            if (xhr.readyState == 4) {
                if (xhr.status === 200) {
                    if (cb)
                        cb(null, response);
                } else {
                    if (cb)
                        cb(response);
                }
            }
        };
        xhr.send(json);
    },
    /**
     * Search data in buildfire search engine.
     * @param {Object} options - search options.
     * @param {string} options.searchText - Your search text.
     * @param {boolean} [options.linkedUser] - If true this will return all public data and the data added by the current logged user.
     * @param {string} [options.pageSize = 50]  - Number of data returned per page size.
     * @param {string} [options.pageIndex = 0] - Number of returned page.
     * @param {string} [options.preHighlightTag] - Use in conjunction with post_tags to define the HTML tags to use for the highlighted text.
     * @param {string} [options.postHighlightTag] - Use in conjunction with pre_tags to define the HTML tags to use for the highlighted text.
     */

    /**
     * @callback cb
     * @param {Object} error
     *
     * @param {Object} response
     * @param {Object} response.hits
     * @param {Object} response.hits.total
     * @param {Object} response.hits.max_score
     * @param {Object[]} response.hits.hits - Array of matched documents/
     */
    search: function (params, callback) {
        var self = this;
        if (!params) {
            if (callback)
                callback("invalid params", null);
            return;
        }

        /*
        if (!params.searchText) {
            if (callback)
                callback("Missing searchText parameter", null);
            return;
        }
         */

        var data = {
            instance_id: this.context.instanceId,
            plugin_id: this.context.pluginId,
            tag: params.tag,
            page_index: params.pageIndex,
            page_size: params.pageSize,
            search_text: params.searchText,
            pre_highlight_tag: params.preHighlightTag,
            post_highlight_tag: params.postHighlightTag
        };

        function _send() {
            self._sendRequest('POST', 'search', data, function (err, data) {
                if (callback)
                    callback(err, data);
            });
        }

        if (params.linkedUser) {
            window.authAPI.getCurrentUser(function (err, user) {
                data.user_id = (user && user._id) ? user._id.toString() : null;
                if (!data.user_id) {
                    if (callback)
                        callback({message: 'no user found'});
                } else {
                    _send();
                }
            });
        } else {
            _send();
        }
    },
    /**
     * Insert data in buildfire search engine.
     * @param {Object} options - insert options.
     * @param {boolean} [options.linkedUser] - This will make the data linked to the current logged user, which means it will be private.
     * @param {string} options.tag - A unique key for your data, this is important for categorizing your data.
     * @param {string} options.title - Title for your data, this will be searchable by our search engine.
     * @param {string} [options.description] - Description for your data, this will be searchable by our search engine.
     * @param {string} [options.keywords] - Any keywords related to your data, this will be searchable by our search engine.
     * @param {string} [options.imageUrl].
     * @param {Object} [options.data] - You can add whatever you want here, this won't be searchable by our search engine.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     * @param {string} response.id - The id of the newly inserted document.
     */
    insert: function (params, callback) {
        var self = this;

        if (!params) {
            if (callback)
                callback({message: "invalid params"}, null);
            return;
        }

        if (!params.tag) {
            if (callback)
                callback({message: "Missing params tag"}, null);
            return;
        }

        if (!params.title) {
            if (callback)
                callback({message: "Missing params title"}, null);
            return;
        }

        var data = {
            instance_id: this.context.instanceId,
            plugin_id: this.context.pluginId,
            tag: params.tag,
            title: params.title,
            description: params.description,
            keywords: params.keywords,
            image_url: params.imageUrl,
            data: params.data
        };

        function _send() {
            self._sendRequest('POST', '', data, function (err, data) {
                if (callback)
                    callback(err, data);
            });
        }

        if (params.linkedUser) {
            window.authAPI.getCurrentUser(function (err, user) {
                data.user_id = (user && user._id) ? user._id.toString() : null;

                if (!data.user_id) {
                    if (callback)
                        callback({message: 'no user found'});
                } else {
                    _send();
                }
            });
        } else {
            _send();
        }
    },
    /**
     * save data in buildfire search engine.
     * @param {Object} options - save options.
     * @param {boolean} [options.linkedUser] - This will make the data linked to the current logged user, which means it will be private.
     * @param {string} options.key - A unique key for your document, this will be the id of your document.
     * @param {string} options.tag - A unique key for your data, this is important for categorizing your data.
     * @param {string} options.title - Title for your data, this will be searchable by our search engine.
     * @param {string} [options.description] - Description for your data, this will be searchable by our search engine.
     * @param {string} [options.keywords] - Any keywords related to your data, this will be searchable by our search engine.
     * @param {string} [options.imageUrl].
     * @param {Object} [options.data] - You can add whatever you want here, this won't be searchable by our search engine.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     * @param {string} response.id - The id of the saved document.
     */
    save: function (params, callback) {
        var self = this;

        if (!params) {
            if (callback)
                callback({message: "invalid params"}, null);
            return;
        }

        if (!params.key) {
            if (callback)
                callback({message: "Missing params key"}, null);
            return;
        }

        if (!params.tag) {
            if (callback)
                callback({message: "Missing params tag"}, null);
            return;
        }

        if (!params.title) {
            if (callback)
                callback({message: "Missing params title"}, null);
            return;
        }

        var data = {
            instance_id: this.context.instanceId,
            plugin_id: this.context.pluginId,
            key: params.key,
            tag: params.tag,
            title: params.title,
            description: params.description,
            keywords: params.keywords,
            image_url: params.imageUrl,
            data: params.data
        };

        function _send() {
            self._sendRequest('POST', 'save', data, function (err, data) {
                if (callback)
                    callback(err, data);
            });
        }

        if (params.linkedUser) {
            window.authAPI.getCurrentUser(function (err, user) {
                data.user_id = (user && user._id) ? user._id.toString() : null;

                if (!data.user_id) {
                    if (callback)
                        callback({message: 'no user found'});
                } else {
                    _send();
                }
            });
        } else {
            _send();
        }
    },
    /**
     * Update data in buildfire search engine.
     * @param {Object} options - update options.
     * @param {string} options.id - An id for your document to update it.
     * @param {boolean} [options.linked_user] - This will make the data linked to the current logged user, which means it will be private.
     * @param {string} options.tag - A unique key for your data, this is important for categorizing your data.
     * @param {string} options.title - Title for your data, this will be searchable by our search engine.
     * @param {string} [options.description] - Description for your data, this will be searchable by our search engine.
     * @param {string} [options.keywords] - Any keywords related to your data, this will be searchable by our search engine.
     * @param {string} [options.image_url].
     * @param {Object} [options.data] - You can add whatever you want here, this won't be searchable by our search engine.
     */

    /**
     * @callback cb
     * @param {Object} error
     *
     * @param {Object} response
     * @param {string} response.id - The id of the updated document.
     */
    update: function (params, callback) {
        var self = this;

        if (!params) {
            if (callback)
                callback({message: "invalid params"}, null);
            return;
        }

        if (!params.id) {
            if (callback)
                callback({message: "Missing params id"}, null);
            return;
        }

        if (!params.tag) {
            if (callback)
                callback({message: "Missing params tag"}, null);
            return;
        }

        if (!params.title) {
            if (callback)
                callback({message: "Missing params title"}, null);
            return;
        }

        var data = {
            id: params.id,
            instance_id: this.context.instanceId,
            plugin_id: this.context.pluginId,
            tag: params.tag,
            title: params.title,
            description: params.description,
            keywords: params.keywords,
            image_url: params.imageUrl,
            data: params.data
        };

        function _send() {
            self._sendRequest('PUT', '', data, function (err, data) {
                if (callback)
                    callback(err, data);
            });
        }

        if (params.linkedUser) {
            window.authAPI.getCurrentUser(function (err, user) {
                data.user_id = (user && user._id) ? user._id.toString() : null;

                if (!data.user_id) {
                    if (callback)
                        callback({message: 'no user found'});
                } else {
                    _send();
                }
            });
        } else {
            _send();
        }
    },
    /**
     * Delete data in buildfire search engine.
     * @param {Object} options - delete options.
     * @param {string} options.id - An id for your document to delete it.
     * @param {string} options.tag - A unique key for your data, this is important for categorizing your data.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {boolean} response
     */
    delete: function (params, callback) {
        var self = this;

        if (!params) {
            if (callback)
                callback({message: "invalid params"}, null);
            return;
        }

        if (!params.id) {
            if (callback)
                callback({message: "Missing params id"}, null);
            return;
        }

        if (!params.tag) {
            if (callback)
                callback({message: "Missing params tag"}, null);
            return;
        }

        var data = {
            id: params.id,
            instance_id: this.context.instanceId,
            plugin_id: this.context.pluginId,
            tag: params.tag
        };

        function _send() {
            self._sendRequest('DELETE', '', data, function (err, data) {
                if (callback)
                    callback(err, data);
            });
        }

        window.authAPI.getCurrentUser(function (err, user) {
            data.user_id = (user && user._id) ? user._id.toString() : null;
            _send();
        });
    },
    get feeds() {
        var parentThis = this;
        return {
            /**
             * Attach feed in buildfire search engine.
             * @param {Object} options - attach options.
             * @param {string} options.tag - A unique key for your data, this is important for categorizing your data.
             * @param {string} options.title - Title for your data.
             * @param {string} options.feedType - feed type, available types : [rss].
             * @param {Object} options.feedConfig
             * @param {string} options.feedConfig.url - Your feed service url.
             * @param {Object} [options.feedItemConfig]
             * @param {string} [options.feedItemConfig.uniqueKey - Your feed unique id]
             * @param {string} [options.feedItemConfig.titleKey]
             * @param {string} [options.feedItemConfig.descriptionKey]
             * @param {string} [options.feedItemConfig.urlKey]
             * @param {string} [options.feedItemConfig.publishDateKey]
             * @param {string} [options.feedItemConfig.imageUrlKey]
             */

            /**
             * @callback cb
             * @param {Object} error
             * @param {Object} response
             * @param {string} response - return true.
             */
            insert: function (params, callback) {
                if (!params) {
                    if (callback)
                        callback({message: "invalid params"}, null);
                    return;
                }

                if (!params.tag) {
                    if (callback)
                        callback({message: "Missing params tag"}, null);
                    return;
                }

                if (!params.title) {
                    if (callback)
                        callback({message: "Missing params title"}, null);
                    return;
                }

                if (!params.feedType) {
                    if (callback)
                        callback({message: "Missing params feedType"}, null);
                    return;
                }

                if (!params.feedConfig || !params.feedConfig.url) {
                    if (callback)
                        callback({message: "Missing params feedConfig.url"}, null);
                    return;
                }

                if (!params.feedItemConfig) {
                    params.feedItemConfig = {};
                }

                var data = {
                    instance_id: parentThis.context.instanceId,
                    plugin_id: parentThis.context.pluginId,
                    tag: params.tag,
                    title: params.title,
                    description: params.description,
                    feed_type: params.feedType,
                    feed_config: {url: params.feedConfig.url},
                    feed_item_config: {
                        unique_key: params.feedItemConfig.uniqueKey,
                        title_key: params.feedItemConfig.titleKey,
                        description_key: params.feedItemConfig.descriptionKey,
                        url_key: params.feedItemConfig.urlKey,
                        publish_date_key: params.feedItemConfig.publishDateKey,
                        image_url_key: params.feedItemConfig.imageUrlKey
                    }
                };

                function _send() {
                    parentThis._sendRequest('POST', 'feeds', data, function (err, data) {
                        if (callback)
                            callback(err, data);
                    });
                }

                _send();
            },

            /**
             * delete feed from buildfire search engine.
             * @param {Object} options - delete options.
             * @param {string} options.tag - A unique key for your data, this is important for categorizing your data.
             * @param {string} options.feedId - Feed Id returned from feeds.get method.
             * @param {boolean} [options.removeFeedData] - If true, this will remove all feed data inside the app that's related to this feed.
             */

            /**
             * @callback cb
             * @param {Object} error
             * @param {boolean} response
             */
            delete: function (params, callback) {
                if (!params) {
                    if (callback)
                        callback({message: "invalid params"}, null);
                    return;
                }

                if (!params.tag) {
                    if (callback)
                        callback({message: "Missing params tag"}, null);
                    return;
                }

                if (!params.feedId) {
                    if (callback)
                        callback({message: "Missing params feedId"}, null);
                    return;
                }

                var data = {
                    instance_id: parentThis.context.instanceId,
                    plugin_id: parentThis.context.pluginId,
                    tag: params.tag,
                    feed_id: params.feedId,
                    remove_feed_data: params.removeFeedData
                };

                function _send() {
                    parentThis._sendRequest('DELETE', 'feeds', data, function (err, data) {
                        if (callback)
                            callback(err, data);
                    });
                }

                _send();
            },

            /**
             * get feeds from buildfire search engine.
             * @param {Object} options - get options.
             * @param {string} options.tag - A unique key for your data, this is important for categorizing your data.
             * @param {string} options.feedType - feed type, available types : [rss].
             */

            /**
             * @callback cb
             * @param {Object} error
             * @param {Object} response
             * @param {string} response - return array of feeds.
             */
            get: function (params, callback) {
                if (!params) {
                    if (callback)
                        callback({message: "invalid params"}, null);
                    return;
                }

                if (!params.tag) {
                    if (callback)
                        callback({message: "Missing params tag"}, null);
                    return;
                }

                if (!params.feedType) {
                    if (callback)
                        callback({message: "Missing params feedType"}, null);
                    return;
                }

                var data = {
                    instance_id: parentThis.context.instanceId,
                    plugin_id: parentThis.context.pluginId,
                    tag: params.tag,
                    feed_type: params.feedType
                };

                function _send() {
                    parentThis._sendRequest('GET', 'feeds', data, function (err, data) {
                        if (callback)
                            callback(err, data);
                    });
                }

                _send();
            }
        };
    }
};
function CreditsAPI(context) {
    this.context = context;
    if (!this.context) {
        throw Error('invalid creditsSystem context');
    }
    if (this.context.apiKeys) {
        this.secretKey = this.context.apiKeys.creditsSystemSecretKey;
    }
};

CreditsAPI.prototype = {
    _sendRequest: function (verb, method, data, cb) {
        var json = "";
        var public_key = undefined;
        var secret_key = undefined;
        if (data.public_key) {
            public_key = data.public_key;
        }
        if (data.secret_key) {
            secret_key = data.secret_key;
        }
        delete data.public_key;
        delete data.secret_key;

        var xhr = new XMLHttpRequest();
        var url = window.siteConfig.endPoints.creditSystemHost + "/credit_system/" + method;

        verb = verb.toUpperCase();
        if (verb === "GET" && data) {
            var query = "?";

            for (var key in data) {
                if (data.hasOwnProperty(key)) {
                    query += key + "=" + encodeURIComponent(data[key]) + "&";
                }
            }

            query = query.slice(0, -1);
            url += query;
        } else {
            json = JSON.stringify(data);
        }

        xhr.open(verb, url, true);
        xhr.setRequestHeader("Content-Type", "application/json");
        if (public_key) {
            xhr.setRequestHeader("public_key", public_key);
        }
        if (secret_key) {
            xhr.setRequestHeader("secret_key", secret_key);
        }

        xhr.setRequestHeader("x-api-key", "ZBtYjI3ZlNaKdhWApTjIF3NYaynO4snJ1zikGTDr");
        /*keep this hardcoded, after discussion between Danny and Ayman, they decide to create generic API Key
           for credit system in order to keep track of AWSGateway API Request for credit system
         */
        xhr.onreadystatechange = function () {
            var response = null;
            try {
                response = JSON.parse(xhr.responseText);
            } catch (e) {

            }
            if (xhr.readyState == 4) {
                if (xhr.status === 200) {
                    if (cb)
                        cb(null, response);
                } else {
                    if (cb)
                        cb(response);
                }
            }
        };
        xhr.send(json);
    },

    /**
     * get merchant bundles
     * @param {object} params.jsonConfig - json object representing the configurations for the Merchant.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    updateMerchant: function (params, callback) {
        var self = this;

        appApiKeys.get(function(err, keys){
            var data = {
                secret_key: self.secretKey,
                json_config: params.jsonConfig
            };

            function _send() {
                self._sendRequest('PUT', 'merchants', data, function (err, data) {
                    if (callback)
                        callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                data.user_token = (user && user._id) ? user._id.toString() : null;
                if (!data.user_token) {
                    if (callback)
                        callback({message: 'no logged in user'});
                } else {
                    _send();
                }
            });
        });
    },

    /**
     * add credit for user.
     * @param {string} params.bundle_id - the bundle id which has been selected by the user
     * @param {string} params.memo
     * @param {string} options.xRef1
     * @param {string} options.xRef2
     * @param {string} options.xRef3
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    purchaseBundle: function (params, callback) {
        var self = this;
        if (!params) {
            if (callback)
                callback("invalid params", null);
            return;
        }

        if (!params.bundleId) {
            if (callback)
                callback("Missing bundleId parameter", null);
            return;
        }

        function purchase({sessionId, transactionId}) {
            if (!transactionId) {
                if (callback)
                    callback("Missing transactionId parameter in purchase", null);
                return;
            }

            if (!sessionId) {
                if (callback)
                    callback("Missing sessionId parameter in purchase", null);
                return;
            }


            appApiKeys.get(function(err, keys){
                var data = {
                    public_key: keys.creditsSystemPublicKey,
                    payment_provider: params.paymentProvider,
                    transaction_id: transactionId,
                    stripe: {
                        session_id: sessionId
                    },
                    bundle_id: params.bundleId,
                    access_token: params.access_token
                };

                function _send() {
                    self._sendRequest('POST', 'credits/purchase', data, function (err, data) {
                        if (callback)
                            callback(err, data);
                    });
                }

                window.authAPI.getCurrentUser(function (err, user) {
                    data.access_token = (user && user.accessToken) ? user.accessToken.toString() : null;

                    if (!data.access_token) {
                        if (callback)
                            callback({message: 'no logged in user'});
                    } else {
                        _send();
                    }
                });
            });


        }

        function start() {
            params.paymentProvider = 'stripe';

            appApiKeys.get(function(err, keys){
                var data = {
                    public_key: keys.creditsSystemPublicKey,
                    payment_provider: params.paymentProvider,
                    bundle_id: params.bundleId,
                    memo: params.memo,
                    x_ref_1: params.xRef1,
                    x_ref_2: params.xRef2,
                    x_ref_3: params.xRef3,
                    access_token: params.access_token
                };

                self._sendRequest('POST', 'credits/transactions', data, function (err, data) {
                    if (err) {
                        callback(err)
                    } else if (data && data.transactionId && data.stripe && data.stripe.clientReferenceId) {
                        //create stripe api instance
                        let stripeApi = new StripeAPI(self.context);

                        //run stripe checkout
                        stripeApi.purchase({
                            items: [{sku: data.stripe.skuId}],
                            clientReferenceId: data.stripe.clientReferenceId
                        }, function (err, result) {
                            if (!err) {
                                purchase({
                                    transactionId: data.transactionId,
                                    sessionId: result.id
                                });
                            }
                        });
                    } else {
                        callback({message: "missing stripe data in transaction"});
                    }
                });
            });



        }

        window.authAPI.getCurrentUser(function (err, user) {
            params.access_token = (user && user.accessToken) ? user.accessToken.toString() : null;

            if (!params.access_token) {
                if (callback)
                    callback({message: 'no logged in user'});
            } else {
                start();
            }
        });
    },

    /**
     * get merchant
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    getMerchant: function (params, callback) {
        var self = this;

        appApiKeys.get(function(err, keys){
            var data = {
                public_key: keys.creditsSystemPublicKey,
                secret_key: self.secretKey
            };

            function _send() {
                self._sendRequest('GET', 'merchants', data, function (err, data) {
                    if (callback)
                        callback(err, data);
                });
            }

            _send();
        });
    },

    /**
     * get merchant bundles
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    getBundles: function (params, callback) {
        var self = this;

        appApiKeys.get(function(err, keys){
            var data = {
                public_key: keys.creditsSystemPublicKey,
                secret_key: self.secretKey
            };

            function _send() {
                self._sendRequest('GET', 'bundles', data, function (err, data) {
                    if (callback)
                        callback(err, data);
                });
            }

            _send();
        });
    },

    deleteBundle: function (params, callback) {
        var self = this;
        if (!params) {
            if (callback)
                callback("invalid params", null);
            return;
        }

        appApiKeys.get(function(err, keys){
            var data = {
                secret_key: self.secretKey,
                bundle_id: params.bundleId
            };

            function _send() {
                self._sendRequest('DELETE', 'bundles', data, function (err, data) {
                    if (callback)
                        callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                data.user_token = (user && user._id) ? user._id.toString() : null;
                if (!data.user_token) {
                    if (callback)
                        callback({message: 'no logged in user'});
                } else {
                    _send();
                }
            });
        });
    },

    insertBundle: function (params, callback) {
        var self = this;
        if (!params) {
            if (callback)
                callback("invalid params", null);
            return;
        }

        appApiKeys.get(function(err, keys){
            var data = {
                secret_key: self.secretKey,
                name: params.name,
                stripe_product_id: params.stripeProductId,
                description: params.description,
                credit_amount: params.creditAmount,
                user_token: params.userToken,
                image_url: params.imageUrl
            };

            function _send() {
                self._sendRequest('POST', 'bundles', data, function (err, data) {
                    if (callback)
                        callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                data.user_token = (user && user._id) ? user._id.toString() : null;
                if (!data.user_token) {
                    if (callback)
                        callback({message: 'no logged in user'});
                } else {
                    _send();
                }
            });
        });
    },

    updateBundle: function (params, callback) {
        var self = this;
        if (!params) {
            if (callback)
                callback("invalid params", null);
            return;
        }

        appApiKeys.get(function(err, keys){
            var data = {
                secret_key: self.secretKey,
                name: params.name,
                stripe_product_id: params.stripeProductId,
                description: params.description,
                credit_amount: params.creditAmount,
                bundle_id: params.bundleId,
                user_token: params.userToken,
                image_url: params.imageUrl
            };

            function _send() {
                self._sendRequest('PUT', 'bundles', data, function (err, data) {
                    if (callback)
                        callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                data.user_token = (user && user._id) ? user._id.toString() : null;
                if (!data.user_token) {
                    if (callback)
                        callback({message: 'no logged in user'});
                } else {
                    _send();
                }
            });

        });
    },

    /**
     * Consume User Credits
     * @param {number} params.userToken - A token representing the user wants to consume credit.
     * @param {number} params.creditAmount - Credit Amount.
     * @param {string} params.xRef1 - Ref1.
     * @param {string} params.xRef2 - Ref2.
     * @param {string} params.xRef3 - Ref3.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    adjustCredits: function (params, callback) {
        var self = this;
        if (!params) {
            if (callback)
                callback("invalid params", null);
            return;
        }

        if (!params.userToken) {
            if (callback)
                callback("invalid userToken", null);
            return;
        }

        if (!params.creditAmount) {
            if (callback)
                callback("invalid creditAmount", null);
            return;
        }

        appApiKeys.get(function(err, keys){
            var data = {
                secret_key: self.secretKey,
                user_token: params.userToken,
                credit_amount: params.creditAmount,
                memo: params.memo,
                x_ref_1: params.xRef1,
                x_ref_2: params.xRef2,
                x_ref_3: params.xRef3
            };

            function _send() {
                self._sendRequest('POST', 'credits/adjust', data, function (err, data) {
                    if (callback)
                        callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                data.created_by_user_token = (user && user._id) ? user._id.toString() : null;
                if (!data.created_by_user_token) {
                    if (callback)
                        callback({message: 'no logged in user'});
                } else {
                    _send();
                }
            });
        });
    },

    /**
     * Consume User Credits
     * @param {number} params.creditAmount - Credit Amount
     * @param {string} params.xRef1 - Ref1.
     * @param {string} params.xRef2 - Ref2.
     * @param {string} params.xRef3 - Ref3.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    consumeCredits: function (params, callback) {
        var self = this;
        if (!params) {
            if (callback)
                callback("invalid params", null);
            return;
        }

        if (!params.creditAmount) {
            if (callback)
                callback("Missing creditAmount parameter", null);
            return;
        }

        appApiKeys.get(function(err, keys){
            var data = {
                public_key: keys.creditsSystemPublicKey,
                credit_amount: params.creditAmount,
                x_ref_1: params.xRef1,
                x_ref_2: params.xRef2,
                x_ref_3: params.xRef3,
                memo: params.memo
            };

            function _send() {
                self._sendRequest('POST', 'credits/consume', data, function (err, data) {
                    if (callback)
                        callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                data.access_token = (user && user.accessToken) ? user.accessToken.toString() : null;
                if (!data.access_token) {
                    if (callback)
                        callback({message: 'no logged in user'});
                } else {
                    _send();
                }
            });
        });
    },

    /**
     * Transfer Credits
     * @param {number} params.creditAmount - A token representing the users who you need credit balance for.
     * @param {string} params.receiverUserToken - A token representing the user who you need to transfer a credit.
     * @param {string} params.xRef1 - Ref1.
     * @param {string} params.xRef2 - Ref2.
     * @param {string} params.xRef3 - Ref3.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    transferCredits: function (params, callback) {
        var self = this;
        if (!params) {
            if (callback)
                callback("invalid params", null);
            return;
        }

        if (!params.creditAmount) {
            if (callback)
                callback("Missing creditAmount parameter", null);
            return;
        }

        if (!params.receiverUserToken) {
            if (callback)
                callback("Missing receiverUserToken parameter", null);
            return;
        }

        appApiKeys.get(function(err, keys){
            var data = {
                public_key: keys.creditsSystemPublicKey,
                credit_amount: params.creditAmount,
                receiver_user_token: params.receiverUserToken,
                x_ref_1: params.xRef1,
                x_ref_2: params.xRef2,
                x_ref_3: params.xRef3
            };

            function _send() {
                self._sendRequest('POST', 'credits/transfer', data, function (err, data) {
                    if (callback)
                        callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                data.access_token = (user && user.accessToken) ? user.accessToken.toString() : null;
                if (!data.access_token) {
                    if (callback)
                        callback({message: 'no logged in user'});
                } else {
                    _send();
                }
            });
        });
    },

    /**
     * Search Transactions
     * @param {array} params.usersTokens - A token representing the users who you need credit balance for.
     * @param {Number} params.pageSize - Page Size.
     * @param {Number} params.pageIndex - Page Index.
     * @param {Date} params.fromDate - From Date.
     * @param {Date} params.toDate - To Date.
     * @param {string} params.xRef1 - X Ref Value.
     * @param {string} params.xRef2 - X Ref Value.
     * @param {string} params.xRef3 - X Ref Value.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    searchTransactions: function (params, callback) {
        var self = this;
        if (!params) {
            if (callback)
                callback("invalid params", null);
            return;
        }

        appApiKeys.get(function(err, keys) {
            var data = {
                public_key: keys.creditsSystemPublicKey,
                secret_key: self.secretKey,
                users_tokens: params.usersTokens,
                page_size: params.pageSize,
                page_index: params.pageIndex,
                from_date: params.fromDate,
                to_date: params.toDate,
                x_ref_1: params.xRef1,
                x_ref_2: params.xRef2,
                x_ref_3: params.xRef3
            };

            function _send() {
                self._sendRequest('POST', 'credits/transactions/search', data, function (err, data) {
                    if (callback)
                        callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                if (data.public_key) {
                    data.access_token = (user && user.accessToken) ? user.accessToken.toString() : null;
                    if (!data.access_token) {
                        if (callback)
                            callback({message: 'no logged in user'});
                        return;
                    }
                }
                _send();
            });
        });
    },

    /**
     * get user
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    getUser: function (params, callback) {
        var self = this;
        if (!params) {
            if (callback)
                callback("invalid params", null);
            return;
        }

        appApiKeys.get(function(err, keys) {
            var data = {
                public_key: keys.creditsSystemPublicKey
            };
            if (params.secretKey) {
                data.secret_key = params.secretKey;
            }

            function _send() {
                self._sendRequest('GET', 'credits/user', data, function (err, data) {
                    if (callback)
                        callback(err, data);
                });
            }

            window.authAPI.getCurrentUser(function (err, user) {
                data.access_token = (user && user.accessToken) ? user.accessToken.toString() : null;
                if (!data.access_token) {
                    if (callback)
                        callback({message: 'no logged in user'});
                } else {
                    _send();
                }
            });
        });
    },

    /**
     * search users
     * @param {array} params.usersTokens - A token representing the users who you need credit balance for.
     * @param {Number} params.pageSize - Page Size.
     * @param {Number} params.pageIndex - Page Index.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    searchUsers: function (params, callback) {
        var self = this;
        if (!params) {
            if (callback)
                callback("invalid params", null);
            return;
        }

        appApiKeys.get(function(err, keys) {
            var data = {
                secret_key: self.secretKey,
                users_tokens: params.usersTokens,
                page_size: params.pageSize,
                page_index: params.pageIndex
            };

            function _send() {
                self._sendRequest('POST', 'credits/users', data, function (err, data) {
                    if (callback)
                        callback(err, data);
                });
            }

            _send();
        });
    },
    /**
     * Get Transaction logs

     * @param {transactionId} transaction id.

     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    getTransactionsLogs: function (params, callback) {
        var self = this;
        if (!params) {
            if (callback)
                callback("invalid params", null);
            return;
        }

        appApiKeys.get(function(err, keys) {
            if (!params.creditTransactionId) {
                if (callback)
                    callback("Missing creditTransactionId parameter", null);
                return;
            }

            var data = {
                secret_key: self.secretKey,
            };

            function _send() {
                self._sendRequest('GET', 'credits/transaction/' + params.creditTransactionId + '/logs', data, function (err, data) {
                    if (callback)
                        callback(err, data);
                });
            }

            _send();
        });
    }
};
function StripeAPI(context) {
    this.context = context;
    if (!this.context) {
        throw Error('stripeAPI: invalid context');
    }
};

StripeAPI.prototype = {
    _sendRequest: function (verb, method, data, header, cb) {
        var json = "";
        var xhr = new XMLHttpRequest();
        var url = window.siteConfig.endPoints.stripeHost + "/stripe/" + method;

        verb = verb.toUpperCase();
        if (verb === "GET" && data) {
            var query = "?";

            for (var key in data) {
                if (data.hasOwnProperty(key)) {
                    if (typeof data[key] != "undefined") {
                        query += key + "=" + encodeURIComponent(data[key]) + "&";
                    }
                }
            }

            query = query.slice(0, -1);
            url += query;
        } else {
            json = JSON.stringify(data);
        }

        xhr.open(verb, url, true);
        xhr.setRequestHeader("Content-Type", "application/json");
        if (header) {
            for (var key in header) {
                if (header.hasOwnProperty(key)) {
                    xhr.setRequestHeader(key, header[key]);
                }
            }
        }

        xhr.onreadystatechange = function () {
            var response = null;
            try {
                response = JSON.parse(xhr.responseText);
            } catch (e) {

            }
            if (xhr.readyState == 4) {
                if (xhr.status === 200) {
                    if (cb)
                        cb(null, response);
                } else {
                    if (cb)
                        cb(response);
                }
            }
        };
        xhr.send(json);
    },
    _loadScript: function (options, callback) {
        var script = document.createElement("script");
        script.type = "text/javascript";

        // If the browser is Internet Explorer.
        if (script.readyState) {
            script.onreadystatechange = function () {
                if (script.readyState == "loaded" || script.readyState == "complete") {
                    script.onreadystatechange = null;
                    if (callback)
                        callback();
                }
            };
            // For any other browser.
        } else {
            script.onload = function () {
                if (callback)
                    callback();
            };
        }

        script.src = options.url;
        if (options.attr) {
            for (var key in options.attr) {
                script.setAttribute(key, options.attr[key]);
            }
        }

        var scripts = document.getElementsByTagName('script');
        for (var i = scripts.length; i--;) {
            if (scripts[i].src == options.url) {
                if (callback)
                    callback();
                return true;
            }
        }

        document.getElementsByTagName("head")[0].appendChild(script);
    },
    _guid: function () {
        function S4() {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }

        return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4());
    },
    _openStripeCheckout: function ({items, successUrl, cancelUrl, submitType, customerEmail, sessionId, clientReferenceId, domain, events}, callback) {
        var self = this;
        var checkInterval = null;
        var timeoutWithNoVisibility = false;
        var stripePopupWindow = null;
        var successCallback = false;


        function _closeStripeWindow(options) {
            if (!options) {
                options = {};
            }

            clearInterval(checkInterval);

            if (options.invokeDismiss || typeof options.invokeDismiss == "undefined") {
                if (window.richModal) {
                    window.richModal.close();
                }
            }

            if (stripePopupWindow) {
                stripePopupWindow.close();
            }

            if (events && typeof events.onClose === 'function') {
                events.onClose();
            }
        }

        function _checkCheckoutAPI() {

            self._sendRequest('GET', 'checkout/sessions', {
                session_id: sessionId,
                client_reference_id: clientReferenceId
            }, {
                "x-api-key": self.context.apiKeys.awsApiPublicKey
            }, function (err, data) {
                if (data) {
                    //to prevent multiple callbacks
                    if (successCallback) {
                        return;
                    }
                    successCallback = true;

                    _closeStripeWindow();
                    if (callback) {
                        callback(err, data);
                    }
                }
            });
        }

        function _checkCheckoutSession() {
            //start checking every 5 seconds for 15 minutes
            checkInterval = setInterval(function () {

                if (stripePopupWindow && stripePopupWindow.closed) {
                    _closeStripeWindow();
                }

                //check if window is foreground aka Active
                var documentVisibility = window.document.visibilityState;
                if (documentVisibility == "visible") {
                    _checkCheckoutAPI();
                } else {
                    if (!timeoutWithNoVisibility) {
                        timeoutWithNoVisibility = true;

                        setTimeout(function () {
                            timeoutWithNoVisibility = false;
                            _checkCheckoutAPI();
                        }, 60 * 1000);
                    }
                }
            }, 5000);

            // cancel after 15 min
            setTimeout(function () {
                _closeStripeWindow();
            }, 15 * 60 * 1000);
        }

        var url = domain + '/payments/checkout?stripeKey=' + (self.context.apiKeys.stripePublicKey);

        if (sessionId) {
            url += "&sessionId=" + encodeURIComponent(sessionId);
        }

        if (clientReferenceId) {
            url += "&clientReferenceId=" + encodeURIComponent(clientReferenceId);
        }

        if (successUrl) {
            url += "&successUrl=" + encodeURIComponent(successUrl);
        }

        if (cancelUrl) {
            url += "&cancelUrl=" + encodeURIComponent(cancelUrl);
        }

        if (submitType) {
            url += "&submitType=" + encodeURIComponent(submitType);
        }

        if (customerEmail) {
            url += "&customerEmail=" + encodeURIComponent(customerEmail);
        }

        if (items) {
            url += "&items=" + encodeURIComponent(JSON.stringify(items));
        }

        //open popup to show cancel button for the user
        if (window.richModal) {
            window.richModal.display({
                title: "",
                showDismissButton: false,
                richContent: "<div style='text-align:center;'>Payment in progress <br/> Please wait...</div>", action: {
                    title: "Cancel", handler: function () {
                        _closeStripeWindow({invokeDismiss: false});
                    }
                }
            });
        }

        if (events && typeof events.onProgress === 'function') {
            events.onProgress(openPaymentWindow);
        }

        function openPaymentWindow() {
            stripePopupWindow = window.open(url, '_blank', 'location=no');
            _checkCheckoutSession();
        }

        if (self.openPaymentWindow === false) {
            //do nothing
        }
        else {
            openPaymentWindow();
        }
    },
    _checkApiKeys : function (callback) {
        var self = this;

        if (self.context.apiKeys && self.context.apiKeys.awsApiPublicKey) {
            if(callback)
                callback();

            return;
        }

        function _updateKeys() {
            //fetch the keys and save in memory to be ready when it needs
            appApiKeys.get(function(err, keys){
                self.context.apiKeys = keys;
                if (callback) {
                    callback();
                }
            });
        }

        if (window.appContext.currentApp.apiKeys) {
            if (Object.keys(window.appContext.currentApp.apiKeys).length === 0 && window.appContext.currentApp.apiKeys.constructor === Object) {
                _updateKeys();
            } else {
                self.context.apiKeys = window.appContext.currentApp.apiKeys;

                if (callback) {
                    callback();
                }
            }
        } else {
            _updateKeys();
        }
    },
    /**
     * show stripe popup window.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    pay: function (params, callback) {
        var self = this;
        self._checkApiKeys(function () {
            if (!self.context.apiKeys.stripePublicKey) {
                if (callback)
                    callback("Missing stripePublicKey in context", null);
                return;
            }

            self._loadScript({
                url: "https://checkout.stripe.com/checkout.js"
            }, function () {
                var handler = StripeCheckout.configure({
                    key: self.context.apiKeys.stripePublicKey,
                    image: 'https://stripe.com/img/documentation/checkout/marketplace.png',
                    locale: 'auto',
                    token: function (token) {
                        // You can access the token ID with `token.id`.
                        // Get the token ID to your server-side code for use.
                        handler.close();

                        if (callback)
                            callback(null, {sourceToken: token});
                    }
                });

                // Open Checkout with further options:
                handler.open({});

                // Close Checkout on page navigation:
                window.addEventListener('popstate', function () {
                    handler.close();
                });
            });
        });
    },
    /**
     * charge dynamic products using stripe checkout.
     * @param {Object} params.
     * @param {Array.<Object>} params.items - a list of items.
     * @param {string} params.items[].name - The name for the line item.
     * @param {string} [params.items[].description] - The description for the line item.
     * @param {integer} params.items[].amount - The amount to be collected per unit of the line item.
     * @param {string} [params.items[].currency = "usd"] - Three-letter ISO currency code, in lowercase. Must be a supported, for more details check [https://stripe.com/docs/currencies].
     * @param {integer} [params.items[].quantity = 1] - The quantity of the line item being purchased.
     * @param {string} [params.submitType] - Describes the type of transaction being performed by Checkout in order to customize relevant text on the page, such as the submit button. Supported values are "auto, book, donate, or pay".
     * @param {string} [params.customerId] - ID of an existing customer, if one exists. If blank, Checkout will create a new customer object based on information provided during the session. The email stored on the customer will be used to prefill the email field on the Checkout page. If the customer changes their email on the Checkout page, the Customer object will be updated with the new email.
     * @param {string} [params.customerEmail] - If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the customer field.
     * @param {Object} [params.events]
     * @param {function} [params.events.onProgress]
     * @param {function} [params.events.onClose]
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    charge: function (params, callback) {
        var self = this;
        self._checkApiKeys(function () {
            if (!self.context.apiKeys.stripePublicKey) {
                if (callback)
                    callback("Missing stripePublicKey in context", null);
                return;
            }

            if (!self.context.apiKeys.awsApiPublicKey) {
                if (callback)
                    callback("Missing awsApiPublicKey in context", null);
                return;
            }

            if (!params) {
                if (callback)
                    callback("invalid params", null);
                return;
            }

            self.openPaymentWindow = params.openPaymentWindow;

            if (!params.items || params.items.length == 0) {
                if (callback)
                    callback("Missing items", null);
                return;
            }

            var _lineItems = [];

            //validate line items required fields
            for (var i = 0; i < params.items.length; i++) {
                if (!params.items[i].name) {
                    if (callback)
                        callback("Missing name in items index " + i, null);
                    return;
                }

                if (!params.items[i].amount) {
                    if (callback)
                        callback("Missing amount in items index " + i, null);
                    return;
                }

                _lineItems.push({
                    name: params.items[i].name,
                    description: params.items[i].description || undefined,
                    amount: params.items[i].amount,
                    currency: params.items[i].currency || "usd",
                    quantity: params.items[i].quantity || 1
                });
            }

            var domain = window.siteConfig.endPoints.appHost;
            // if (window.location.protocol && window.location.protocol.indexOf('http') == 0) {
            //     domain = window.location.protocol + "//" + window.location.host;
            // }

            var _clientRefId = "app_id_" + self.context.appId + "_ref_id_" + self._guid();

            var data = {
                type: 'line_items',
                line_items: _lineItems,
                client_reference_id: _clientRefId,
                success_url: domain + "/payments/success",
                cancel_url: domain + "/payments/cancel",
            };

            if (params.submitType) {
                data["submit_type"] = params.submitType;
            }

            if (params.customerId) {
                data["customer_id"] = params.customerId;
            }

            if (params.customerEmail) {
                data["customer_email"] = params.customerEmail;
            }

            self._sendRequest('POST', 'checkout/sessions', data, {
                "x-api-key": self.context.apiKeys.awsApiPublicKey
            }, function (err, data) {
                if (err) {
                    if (callback)
                        callback(err, data);
                } else {
                    var sessionId = data.sessionId;
                    self._openStripeCheckout({
                        sessionId: sessionId,
                        clientReferenceId: _clientRefId,
                        domain: domain,
                        events: params.events
                    }, function (err, data) {
                        if (callback) {
                            callback(err, data);
                        }
                    });
                }
            });
        });
    },

    /**
     * subscribe to specific stripe plan using stripe checkout.
     * @param {Object} params.
     * @param {Array.<Object>} params.items - a list of items.
     * @param {string} params.items[].planId - Plan ID for this item.
     * @param {integer} [params.items[].quantity = 1] - Quantity for this item.
     * @param {integer} [params.trialPeriodDays ] - The number of trial period days before the customer is charged for the first time. Has to be at least 1.
     * @param {string} [params.customerId] - ID of an existing customer, if one exists. If blank, Checkout will create a new customer object based on information provided during the session. The email stored on the customer will be used to prefill the email field on the Checkout page. If the customer changes their email on the Checkout page, the Customer object will be updated with the new email.
     * @param {string} [params.customerEmail] - If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the customer field.
     * @param {string} [params.metaData] - If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the customer field.
     * @param {Object} [params.events]
     * @param {function} [params.events.onProgress]
     * @param {function} [params.events.onClose]
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    subscribe: function (params, callback) {
        var self = this;

        self._checkApiKeys(function () {
            if (!self.context.apiKeys.stripePublicKey) {
                if (callback)
                    callback("Missing stripePublicKey in context", null);
                return;
            }

            if (!self.context.apiKeys.awsApiPublicKey) {
                if (callback)
                    callback("Missing awsApiPublicKey in context", null);
                return;
            }

            if (!params) {
                if (callback)
                    callback("invalid params", null);
                return;
            }
            self.openPaymentWindow = params.openPaymentWindow;

            if (!params.items || params.items.length == 0) {
                if (callback)
                    callback("Missing items", null);
                return;
            }

            var _subscriptionData = [];

            //validate subscription data required fields
            for (var i = 0; i < params.items.length; i++) {
                if (!params.items[i].planId) {
                    if (callback)
                        callback("Missing planId in items index " + i, null);
                    return;
                }

                _subscriptionData.push({
                    plan_id: params.items[i].planId,
                    quantity: params.items[i].quantity || 1
                });
            }

            var domain = window.siteConfig.endPoints.appHost;
            // if (window.location.protocol && window.location.protocol.indexOf('http') == 0) {
            //     domain = window.location.protocol + "//" + window.location.host;
            // }

            var _clientRefId = "app_id_" + self.context.appId + "_ref_id_" + self._guid();

            var data = {
                type: 'subscription',
                subscription_data: _subscriptionData,
                client_reference_id: _clientRefId,
                success_url: domain + "/payments/success",
                cancel_url: domain + "/payments/cancel",
            };

            if (params.trialPeriodDays) {
                data["trial_period_days"] = params.trialPeriodDays;
            }

            if (params.customerId) {
                data["customer_id"] = params.customerId;
            }

            if (params.customerEmail) {
                data["customer_email"] = params.customerEmail;
            }

            if (params.metaData) {
                data["metadata"] = params.metaData;
            }

            self._sendRequest('POST', 'checkout/sessions', data, {
                "x-api-key": self.context.apiKeys.awsApiPublicKey
            }, function (err, data) {
                if (err) {
                    if (callback)
                        callback(err, data);
                } else {
                    var sessionId = data.sessionId;
                    self._openStripeCheckout({
                        sessionId: sessionId,
                        clientReferenceId: _clientRefId,
                        domain: domain,
                        events: params.events
                    }, function (err, data) {
                        if (callback) {
                            callback(err, data);
                        }
                    });
                }
            });
        });
    },

    /**
     * purchase stripe products using stripe checkout.
     * @param {Object} params.
     * @param {Array.<Object>} params.items - a list of items.
     * @param {string} params.items[].sku - The ID of the SKU that the customer would like to purchase.
     * @param {integer} [params.items[].quantity = 1] - The quantity of the line item being purchased.
     * @param {string} [params.submitType] - Describes the type of transaction being performed by Checkout in order to customize relevant text on the page, such as the submit button. Supported values are "auto, book, donate, or pay".
     * @param {string} [params.customerEmail] - If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the customer field.
     * @param {string} [params.clientReferenceId] - If provided, this value will be replace the auto-generated clientReferenceId.
     * @param {Object} [params.events]
     * @param {function} [params.events.onProgress]
     * @param {function} [params.events.onClose]
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    purchase: function (params, callback) {
        var self = this;

        self._checkApiKeys(function () {
            if (!self.context.apiKeys.stripePublicKey) {
                if (callback)
                    callback("Missing stripePublicKey in context", null);
                return;
            }

            if (!self.context.apiKeys.awsApiPublicKey) {
                if (callback)
                    callback("Missing awsApiPublicKey in context", null);
                return;
            }

            if (!params) {
                if (callback)
                    callback("invalid params", null);
                return;
            }

            if (!params.items || params.items.length == 0) {
                if (callback)
                    callback("Missing items", null);
                return;
            }

            var _items = [];

            //validate items required fields
            for (var i = 0; i < params.items.length; i++) {
                if (!params.items[i].sku) {
                    if (callback)
                        callback("Missing sku in items index " + i, null);
                    return;
                }

                _items.push({
                    sku: params.items[i].sku,
                    quantity: params.items[i].quantity || 1
                });
            }

            var domain = window.siteConfig.endPoints.appHost;

            // if (window.location.protocol && window.location.protocol.indexOf('http') == 0) {
            //     domain = window.location.protocol + "//" + window.location.host;
            // }

            var _clientRefId = "app_id_" + self.context.appId + "_ref_id_" + self._guid();

            //if provided, replace the auto-generated clientReferenceId
            if (params.clientReferenceId) {
                _clientRefId = params.clientReferenceId;
            }

            var data = {
                items: _items,
                clientReferenceId: _clientRefId,
                successUrl: domain + "/payments/success",
                cancelUrl: domain + "/payments/cancel",
                submitType: params.submitType,
                customerEmail: params.customerEmail,
                domain: domain,
                events: params.events
            };

            self._openStripeCheckout(data, function (err, data) {
                if (callback) {
                    callback(err, data);
                }
            });
        });
    },

    /**
     * get stripe subscription details.
     * @param {Object} params.
     * @param {string} params.subscriptionId - stripe subscription id.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    getSubscription: function (params, callback) {
        var self = this;

        self._checkApiKeys(function () {
            if (!self.context.apiKeys.stripePublicKey) {
                if (callback)
                    callback("Missing stripePublicKey in context", null);
                return;
            }

            if (!self.context.apiKeys.awsApiPublicKey) {
                if (callback)
                    callback("Missing awsApiPublicKey in context", null);
                return;
            }

            if (!params) {
                if (callback)
                    callback("invalid params", null);
                return;
            }

            if (!params.subscriptionId) {
                if (callback)
                    callback("Missing params subscriptionId", null);
                return;
            }

            var data = {
                subscription_id: params.subscriptionId
            };

            self._sendRequest('GET', 'customer/subscription', data, {
                "x-api-key": self.context.apiKeys.awsApiPublicKey
            }, function (err, data) {
                if (callback)
                    callback(err, data);
            });
        });
    },

    /**
     * cancel stripe subscription.
     * @param {Object} params.
     * @param {string} params.subscriptionId - stripe subscription id.
     * @param {string} params.customerId - stripe customer id.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    cancelSubscription: function (params, callback) {
        var self = this;
        self._checkApiKeys(function () {
            if (!self.context.apiKeys.stripePublicKey) {
                if (callback)
                    callback("Missing stripePublicKey in context", null);
                return;
            }

            if (!self.context.apiKeys.awsApiPublicKey) {
                if (callback)
                    callback("Missing awsApiPublicKey in context", null);
                return;
            }

            if (!params) {
                if (callback)
                    callback("invalid params", null);
                return;
            }

            if (!params.subscriptionId) {
                if (callback)
                    callback("Missing params subscriptionId", null);
                return;
            }

            if (!params.customerId) {
                if (callback)
                    callback("Missing params customerId", null);
                return;
            }

            var data = {
                subscription_id: params.subscriptionId,
                customer_id: params.customerId
            };

            self._sendRequest('DELETE', 'customer/subscription', data, {
                "x-api-key": self.context.apiKeys.awsApiPublicKey
            }, function (err, data) {
                if (callback)
                    callback(err, data);
            });
        });
    },

    /**
     * add customer card.
     * @param {Object} params.
     * @param {string} params.customerId - stripe customer id.
     * @param {string} [params.customerEmail] - If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the customer field.
     */

    /**
     * @callback cb
     * @param {Object} error
     * @param {Object} response
     */
    addCustomerCard: function (params, callback) {
        var self = this;
        self._checkApiKeys(function () {
            if (!self.context.apiKeys.stripePublicKey) {
                if (callback)
                    callback("Missing stripePublicKey in context", null);
                return;
            }

            if (!self.context.apiKeys.awsApiPublicKey) {
                if (callback)
                    callback("Missing awsApiPublicKey in context", null);
                return;
            }

            if (!params) {
                if (callback)
                    callback("invalid params", null);
                return;
            }

            if (!params.customerId) {
                if (callback)
                    callback("Missing params customerId", null);
                return;
            }

            var domain = window.siteConfig.endPoints.appHost;
            var _clientRefId = "app_id_" + self.context.appId + "_ref_id_" + self._guid();

            var data = {
                mode: "setup",
                type: "setup",
                client_reference_id: _clientRefId,
                success_url: domain + "/payments/success",
                cancel_url: domain + "/payments/cancel",
            };

            if (params.customerEmail) {
                data["customer_email"] = params.customerEmail;
            }

            self._sendRequest('POST', 'checkout/sessions', data, {
                "x-api-key": self.context.apiKeys.awsApiPublicKey
            }, function (err, data) {
                if (err) {
                    if (callback)
                        callback(err, data);
                } else {
                    var sessionId = data.sessionId;
                    self._openStripeCheckout({
                        sessionId: sessionId,
                        clientReferenceId: _clientRefId,
                        domain: domain
                    }, function (err, data) {
                        if (err) {
                            if (callback) {
                                callback(err, null);
                            }
                        } else if (data) {
                            //get setup_intent and send it along with customer_id to "stripe card post API"
                            var insertCustomerCardData = {
                                customer_id: params.customerId,
                                setup_intent: data.setup_intent
                            };

                            self._sendRequest('POST', 'customer/card', insertCustomerCardData, {
                                "x-api-key": self.context.apiKeys.awsApiPublicKey
                            }, function (err, data) {
                                if (callback) {
                                    callback(err, data);
                                }
                            });
                        } else {
                            if (callback) {
                                callback(null, null);
                            }
                        }
                    });
                }
            });
        });
    }
};
var richModal = (function () {

    // Prepare DOM for in-app notifications
    var container = document.createElement('div');
    container.id = "richModal";
    container.className = "hidden";

    // Black translucent background
    var screen = document.createElement('div');
    screen.className = 'focus-screen hidden';
    container.appendChild(screen);

    document.body.appendChild(container);

    var currentMessage = null;
    var queue = [];

    /**
     * Creates the node for the modal and populates with message data from the
     * queue.
     *
     * @private
     */
    function renderModal() {
        try {
            if (currentMessage) return;

            // Make sure the user isn't being requested an access code
            if (window.location.hash.indexOf('accessCode') >= 0) {
                return setTimeout(renderModal, 5000); // Try again later
            }

            // Make sure the user isn't on the login screen
            var loginHolder = document.getElementsByClassName('login-holder')[0];
            if (loginHolder && loginHolder.className.indexOf('ng-hide') === -1) {
                return setTimeout(renderModal, 5000); // Try again later
            }

            // Grab the first message from the queue and work with it
            currentMessage = queue.shift();
            var options = currentMessage.options;
            var callback = currentMessage.callback;

            // Remove hidden from container
            var richModalContainer = document.getElementById('richModal');
            richModalContainer.className = '';

            // Fade in focus screen
            var screen = document.getElementsByClassName('focus-screen')[0];
            screen.className = 'focus-screen animated fadeInScreen';

            // Create modal
            var modal = document.createElement('div');
            modal.className = 'detail-modal animated fadeInUp';

            if (options.title) {
                var title = document.createElement('h1');
                if (options.title.length > 30) {
                    options.title = options.title.substring(0, 27).trim() + '...';
                }
                title.innerHTML = options.title;
                if (options.design){
                    var _styles = "";
                    if (options.design.title && options.design.title.align) {
                        _styles += "text-align: " + options.design.title.align + " !important;";
                    }

                    if (options.design.textColor) {
                        _styles += "color: " + options.design.textColor + " !important;";
                    }

                    title.setAttribute('style', _styles);
                }
                modal.appendChild(title);
            }

            if (options.subtitle) {
                var subtitle = document.createElement('span');
                subtitle.className = 'subtitle';
                subtitle.innerHTML = options.subtitle;
                if (options.design) {
                    var _styles = "";
                    if (options.design.subtitle && options.design.subtitle.align) {
                        _styles += "text-align: " + options.design.subtitle.align + " !important;";
                    }

                    if (options.design.textColor) {
                        _styles += "color: " + options.design.textColor + " !important;";
                    }

                    subtitle.setAttribute('style', _styles);
                }
                modal.appendChild(subtitle);
            }

            var richContent = document.createElement('div');
            richContent.className = 'rich-content';
            richContent.innerHTML = options.richContent;
            modal.appendChild(richContent);

            var buttonContainer = document.createElement('div');
            buttonContainer.className = 'button-container';
            modal.appendChild(buttonContainer);

            if (options.showDismissButton || typeof options.showDismissButton == "undefined") {
                var dismissButton = document.createElement('button');
                dismissButton.className = options.action ? 'dismiss-button' : 'dismiss-button dismiss-large';
                dismissButton.innerHTML = "Dismiss";
                dismissButton.onclick = function () {
                    dismissModal();
                    if (callback)
                        callback(null, {buttonType: 'dismiss'});
                };
                buttonContainer.appendChild(dismissButton);
            }

            var _customDesignStyles = "";
            if (options.design) {
                if (options.design.fullScreen) {
                    container.classList.add('fullScreen');
                }

                if (options.design.backgroundColor) {
                    _customDesignStyles += 'background : ' + options.design.backgroundColor + ' !important;';
                }

                if (options.design.textColor) {
                    _customDesignStyles += 'color : ' + options.design.textColor + ' !important';
                }

                modal.setAttribute('style', _customDesignStyles);
                dismissButton.setAttribute('style', _customDesignStyles);
            }
        } catch (err) {
            console.error('Failed to render rich modal', err);
        }

        if (options.action) {
            try {
                var actionButton = document.createElement('button');
                actionButton.className = 'action-button';
                if (options.showDismissButton === false) {
                    actionButton.className = 'action-button action-button-large';
                }
                if (options.action.title && options.action.title.length > 11) {
                    options.action.title = options.action.title.substring(0, 8).trim() + '...';
                }
                actionButton.innerHTML = options.action.title || "[ Click ]";

                actionButton.onclick = function () {
                    if (options.action.handler)
                        options.action.handler();
                    else {
                        var actionAPI = new ActionItemsAPI();
                        actionAPI.execute(options.action, function (err, result) {
                        });
                        if (callback)
                            callback(null, {buttonType: 'action', value: options.action});
                    }
                    if(!options.action.preventAutoClose) {
                        dismissModal();
                    }
                };

                if (options.design && _customDesignStyles) {
                    actionButton.setAttribute('style', _customDesignStyles);
                }

                buttonContainer.appendChild(actionButton);
            } catch (err) {
                console.error('Failed to bind action to rich modal', err);
            }

        }
        // Show notification
        document.getElementById('richModal').appendChild(modal);
    }

    /**
     * Fade out the modal and check if anything is remaning on the queue
     */
    function dismissModal() {
        var screen = document.getElementsByClassName('focus-screen')[0];
        if (screen) {
            screen.className = 'focus-screen animated fadeOutScreen';
        }

        var modal = document.getElementsByClassName('detail-modal')[0];
        if (modal) {
            modal.className = 'detail-modal animated fadeOut';
        }

        var modalContainer = document.getElementById('richModal');
        setTimeout(function () {
            if (modal) {
                modal.remove();
            }
            currentMessage = null;

            // If queue has items, continue working on it, or hide modal container
            if (queue.length > 0) {
                setTimeout(renderModal, 300)
            } else {
                if (modalContainer) {
                    modalContainer.className = "hidden";
                }
            }
        }, 700)
    }

    return {
        /**
         * Adds the message to the queue and tries to render it into a modal
         */
        display: function (options, callback) {
            queue.push({options: options, callback: callback});
            renderModal();
        },
        close: function () {
            dismissModal();
        }
    };
})();

/**
 * @class BleCentralAPI
 * @summary enables communication between a phone
 * and Bluetooth Low Energy (BLE) peripherals.
 * @since v3.33.8 02/07/2020
 * @author Christopher Berger
 * @link documentation: {{ TBD }}
 */

class BleCentralAPI {
	constructor() {
		this.mockMode = typeof window.ble != 'undefined' ? false : true;

		if (this.mockMode) return console.warn('mock bleCentral interaction');

		this.ble = window.ble;
	}
	//////////////////////////////////// EVENT HANDLING ////////////////////////////////////
	/**
	 * @method onDeviceDiscovered
	 * 	triggers when a device is discovered
	 * 	via any scan method. Sends the device
	 * 	back to the SDK to be handled
	 * @param {Object} device discovered device
	 */
	onDeviceDiscovered(device) {
		const packet = new Packet(null, 'services.bluetooth.bleCentral.triggerOnDeviceDiscovered', device, null);
		postMaster.broadcast(packet);
	}
	/**
	 * @method onDeviceConnected
	 * 	triggers when a device is connected. Sends
	 * 	the device back to the SDK to be handled
	 * @param {Object} device connected device
	 */
	onDeviceConnected(device) {
		const packet = new Packet(null, 'services.bluetooth.bleCentral.triggerOnDeviceConnected', device, null);
		postMaster.broadcast(packet);
	}
	/**
	 * @method onDeviceDisconnected
	 * 	triggers when a device is disconnected.
	 * 	Sends info back to the SDK to be handled
	 * @param {*} info any info returned from ble
	 */
	onDeviceDisconnected(info) {
		const packet = new Packet(null, 'services.bluetooth.bleCentral.triggerOnDeviceDisconnected', info, null);
		postMaster.broadcast(packet);
	}
	/**
	 * @method onNotification
	 * 	Triggers when the value of a characteristic
	 * 	changes. Sends data back to the SDK to be handled
	 * @param {Object} data characteristic data
	 */
	onNotification(data) {
		const packet = new Packet(null, 'services.bluetooth.bleCentral.triggerOnNotification', data, null);
		postMaster.broadcast(packet);
	}
	/**
	 * @method onStateNotification
	 * 	Triggers when Bluetooth state changes. Sends
	 * 	state back to the SDK to be handled.
	 * @param {String} state new Bluetooth state
	 */
	onStateNotification(state) {
		const packet = new Packet(null, 'services.bluetooth.bleCentral.triggerOnStateNotification', state, null);
		postMaster.broadcast(packet);
	}
	/////////////////////////////////////// SCANNING ///////////////////////////////////////
	/**
	 * 	@method scan
	 * 		scans for BLE devices. The success callback is
	 * 		called each time a peripheral is discovered.
	 * 		Scanning automatically stops after the specified
	 * 		number of seconds.
	 * 	@param {Object} options 
	 * 		@param {Array} services optional
	 * 		List of services to discover, or [] to find all devices
	 * 		@param {Number} seconds optional
	 * 		Number of seconds to run discovery
	 * 	@param {Function} callback optional
	 * 		@returns {Object} 
	 */
	scan(options, callback) {
		if (this.mockMode) {
			return console.warn('bleCentral mock scan!');
		}
		if (!options) options = {};
		if (!options.services) options.services = [];
		if (!options.seconds) options.seconds = 5;

		const onFail = error => {
			(callback || console.error)(error);
		};

		const onScanEnd = () => {
			if (callback) callback(null, { status: 'complete' });
		};

		const timeoutMillis = (options.seconds * 1000);

		setTimeout(onScanEnd, timeoutMillis);

		this.ble && this.ble.scan(
			options.services,
			options.seconds,
			this.onDeviceDiscovered,
			onFail
		);
	}
	/**
	 * 	@method startScan
	 * 		scans for BLE devices. The success callback is
	 * 		called each time a peripheral is discovered.
	 * 		Scanning will continue until stopScan is called.
	 * 	@param {Object} options 
	 * 		@param {Array} services
	 * 		List of services to discover, or [] to find all devices
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	startScan(options, callback) {
		if (this.mockMode) {
			return console.warn('bleCentral mock startScan!');
		}
		if (!options) options = {};
		if (!options.services) options.services = [];

		const onFail = error => {
			(callback || console.error)(error);
		}

		this.ble && this.ble.startScan(
			options.services,
			this.onDeviceDiscovered,
			onFail
		);
	}
	/**
	 *  @method startScanWithOptions
	 * 		scans for BLE devices. It operates similarly to
	 * 		the startScan function, but allows you to specify
	 * 		extra options. The success callback is called each
	 * 		time a peripheral is discovered. Scanning will
	 * 		continue until stopScan is called.
	 * 	@param {Object} options 
	 * 		@param {Array} services
	 * 		List of services to discover, or [] to find all devices
	 * 	  @param {Boolean} reportDuplicates
	 * 		Specifies if duplicate devices should be reported
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	startScanWithOptions(options, callback) {
		if (this.mockMode) {
			return console.warn('bleCentral mock startScanWithOptions!');
		}
		if (!options) options = {};
		if (!options.services) options.services = [];
		if (!options.reportDuplicates) options.reportDuplicates = false;

		const onFail = error => {
			(callback || console.error)(error);
		}

		/**
		 * reportDuplicates is the onlyscanOption
		 * availible as of plugin v1.2.4
		 */
		const scanOptions = {
			reportDuplicates: options.reportDuplicates
		}

		this.ble && this.ble.startScanWithOptions(
			options.services,
			scanOptions,
			this.onDeviceDiscovered,
			onFail
		);
	}
	/**
	 *  @method stopScan
	 * 		stops scanning for BLE devices.
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	stopScan(callback) {
		if (this.mockMode) {
			return console.warn('bleCentral mock stopScan!');
		}

		this.ble && this.ble.stopScan(success, fail);

		function success() {
			if (callback) callback(null, true);
		}

		function fail(error) {
			if (callback) callback(error, null);
		}
	}
	///////////////////////////////////// CONNECTIONS //////////////////////////////////////
	/**
	 *  @method connect
	 * 		connects to a BLE peripheral. The callback is long
	 * 		running. The connect callback will be called when
	 * 		the connection is successful. Service and
	 * 		characteristic info will be passed to the connect
	 * 		callback in the peripheral object.
	 *	@param {Object} options 
	 * 		@param {String} device_id
	 * 		UUID or MAC address of the peripheral
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	connect(options, callback) {
		if (!options || !options.device_id) {
			const error = new Error('No device_id provided to bleCentral.connect!');
			return (callback || console.error)(error);
		}
		if (this.mockMode) {
			return console.warn('bleCentral mock connect!');
		}

		const onConnect = result => {
			if (callback) callback(null, result);
			this.onDeviceConnected(result);
		}

		const onDisconnect = data => {
			this.onDeviceDisconnected(data);
		}

		this.ble && this.ble.connect(
			options.device_id,
			onConnect,
			onDisconnect
		);
	}
	/**
	 *  @method autoConnect
	 * 		Automatically connect to a device when it is in
	 * 		range of the phone. When the device connects, the
	 * 		connect callback is called with a peripheral object.
	 * 		The call to autoConnect will not time out. It will
	 * 		wait forever until the device is in range. When the
	 * 		peripheral disconnects, the disconnect callback is
	 * 		called with a peripheral object.
	 *	@param {Object} options 
	 * 		@param {String} device_id
	 * 		UUID or MAC address of the peripheral
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	autoConnect(options, callback) {
		if (!options || !options.device_id) {
			const error = new Error('No device_id provided to bleCentral.autoConnect!');
			return (callback || console.error)(error);
		}
		if (this.mockMode) {
			return console.warn('bleCentral mock connect!');
		}

		const onConnect = result => {
			this.onDeviceConnected(result);
		}

		const onDisconnect = data => {
			this.onDeviceDisonnected(data);
		}

		this.ble && this.ble.autoConnect(
			options.device_id,
			onConnect,
			onDisconnect
		);
	}
	/**
	 *  @method disconnect
	 * 		disconnects the selected device.
	 *	@param {Object} options 
	 * 		@param {String} device_id
	 * 		UUID or MAC address of the peripheral
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	disconnect(options, callback) {
		if (!options || !options.device_id) {
			const error = new Error('No device_id provided to bleCentral.disconnect!');
			return (callback || console.error)(error);
		}
		if (this.mockMode) {
			return console.warn('bleCentral mock connect!');
		}

		const success = result => {
			if (callback) callback(null, result);
			this.onDeviceDisconnected(result);
		}

		const fail = error => {
			if (callback) callback(error, null);
		}

		this.ble && this.ble.disconnect(
			options.device_id,
			success,
			fail
		);
	}
	/**
	 *  @method connectedPeripheralsWithServices
	 * 	Retreives a list of the peripherals
	 * 	(containing any of the specified services) currently connected
	 * 	to the system. The peripheral list is sent to the success callback.
	 * 	connectedPeripheralsWithServices will not return any devices
	 *  if services are not passed
	 *	@param {Object} options 
	 * 		@param {Array} services
	 * 		List of services to discover
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	connectedPeripheralsWithServices(options, callback) {
		if (!callback) {
			const error = new Error('No callback provided to bleCentral.connectedPeripheralsWithServices!');
			return console.error(error);
		}
		if (!options || !options.services || !options.services.length) {
			const error = new Error('No services provided to bleCentral.connectedPeripheralsWithServices!');
			return callback(error, null);
		}

		if (this.mockMode) {
			console.warn('bleCentral mock connectedPeripheralsWithServices!');
			return callback(null, []);
		}

		this.ble && this.ble.connectedPeripheralsWithServices(
			options.services,
			success,
			fail
		);

		function success(result) {
			callback(null, result);
		}

		function fail(error) {
			callback(error, null);
		}
	}
	/**
	 *  @method peripheralsWithIdentifiers
	 * 	Sends a list of known peripherals by their identifiers. 
	 *	peripheralsWithIdentifiers will not return any devices
	 *  if identifiers are not passed
	 * 	to the success callback. 
	 *	@param {Object} options 
	 * 		@param {Array} identifiers
	 * 		List of peripheral UUIDs
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	peripheralsWithIdentifiers(options, callback) {
		if (!callback) {
			const error = new Error('No callback provided to bleCentral.peripheralsWithIdentifiers!');
			return console.error(error);
		}
		if (!options || !options.identifiers) {
			const error = new Error('No identifiers provided to bleCentral.peripheralsWithIdentifiers!');
			return callback(error, null);
		}
		if (this.mockMode) {
			console.warn('bleCentral mock peripheralsWithIdentifiers!');
			return callback(null, []);
		}

		this.ble && this.ble.connectedPeripheralsWithServices(
			options.services,
			success,
			fail
		);

		function success(result) {
			if (callback) callback(null, result);
		}

		function fail(error) {
			if (callback) callback(error, null);
		}
	}
	////////////////////////////////////// READ/WRITE ///////////////////////////////////////
	/**
	 *  @method read
	 * 		Reads the value of the characteristic.
	 *	@param {Object} options 
	 * 		@param {String} device_id
	 * 		UUID or MAC address of the peripheral
	 * 		@param {String} service_uuid
	 * 		UUID of the BLE service
	 * 		@param {String} characteristic_uuid
	 * 		UUID of the BLE characteristic
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	read(options, callback) {
		if (typeof callback != 'function') {
			return console.error(new Error('No callback provided to bleCentral.read!'));
		}
		if (!options) {
			return callback(new Error('No options provided to bleCentral.read!'), null);
		}

		const { device_id, service_uuid, characteristic_uuid } = options;

		if (!device_id || !service_uuid || !characteristic_uuid) {
			const error = new Error(`Invalid device info provided to bleCentral.read: ${JSON.stringify(options)}`);
			return (callback || console.error)(error, null);
		}

		if (this.mockMode) {
			console.warn('bleCentral mock read!');
			return callback(null, null);
		}

		const success = result => {
			try {
				const data = this.bufferToArray(result);
				callback(null, data);
			} catch (error) {
				callback(error, null);
			}
		}

		const fail = error => {
			callback(error, null);
		}

		this.ble && this.ble.read(
			device_id,
			service_uuid,
			characteristic_uuid,
			success,
			fail
		);
	}
	/**
	 *  @method write
	 * 		Writes data to a characteristic.
	 *	@param {Object} options 
	 * 		@param {String} device_id
	 * 		UUID or MAC address of the peripheral
	 * 		@param {String} service_uuid
	 * 		UUID of the BLE service
	 * 		@param {String} characteristic_uuid
	 * 		UUID of the BLE characteristic
	 * 		@param {ArrayBuffer} data
	 * 		Bianary data to write to the characteristic
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	write(options, callback) {
		if (!options) {
			const error = new Error('No options provided to bleCentral.write!');
			return (callback || console.error)(error, null);
		}

		const { device_id, service_uuid, characteristic_uuid, data } = options;

		if (!device_id || !service_uuid || !characteristic_uuid) {
			const error = new Error(`Invalid device info provided to bleCentral.write: ${JSON.stringify(options)}`);
			return (callback || console.error)(error, null);
		}

		if (typeof data !== 'object' || typeof data.length !== 'number') {
			const error = new Error('Invalid data provided to bleCentral.write: Must be an array!', data);
			return (callback || console.error)(error, null);
		}

		if (this.mockMode) {
			console.warn('bleCentral mock write!');
			if (callback) callback(null, null);
			return;
		}

		let buffer = null;
		try {
			buffer = this.arrayToBuffer(data);
		} catch (error) {
			return (callback || console.error)(error, null);
		}

		this.ble && this.ble.write(
			options.device_id,
			options.service_uuid,
			options.characteristic_uuid,
			buffer,
			success,
			fail
		);

		function success(result) {
			if (callback) callback(null, result);
		}

		function fail(error) {
			if (callback) callback(error, null);
		}
	}
	/**
	 *  @method writeWithoutResponse
	 * 		Writes data to a characteristic without a response
	 * 		from the peripheral. You are not notified if the
	 * 		write fails in the BLE stack.
	 *	@param {Object} options 
	 * 		@param {String} device_id
	 * 		UUID or MAC address of the peripheral
	 * 		@param {String} service_uuid
	 * 		UUID of the BLE service
	 * 		@param {String} characteristic_uuid
	 * 		UUID of the BLE characteristic
	 * 		@param {ArrayBuffer} data
	 * 		Bianary data to write to the characteristic
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	writeWithoutResponse(options, callback) {
		if (!options) {
			const error = new Error('No options provided to bleCentral.writeWithoutResponse!');
			return (callback || console.error)(error, null);
		}

		const { device_id, service_uuid, characteristic_uuid, data } = options;

		if (!device_id || !service_uuid || !characteristic_uuid) {
			const error = new Error(`Invalid device info provided to bleCentral.writeWithoutResponse: ${JSON.stringify(options)}`);
			return (callback || console.error)(error, null);
		}

		if (typeof data !== 'object' || typeof data.length !== 'number') {
			const error = new Error('Invalid data provided to bleCentral.writeWithoutResponse: Must be an array!', data)
			return (callback || console.error)(error, null);
		}

		if (this.mockMode) {
			console.warn('bleCentral mock writeWithoutResponse!');
			if (callback) callback(null, null);
			return;
		}

		let buffer = null;
		try {
			buffer = this.arrayToBuffer(data);
		} catch (error) {
			return (callback || console.error)(error, null);
		}

		this.ble && this.ble.writeWithoutResponse(
			device_id,
			service_uuid,
			characteristic_uuid,
			buffer,
			success,
			fail
		);

		function success() {
			if (callback) callback(null);
		}

		function fail(error) {
			if (callback) callback(error);
		}
	}
	/**
	 *  @method readRSSI
	 * 	Samples the RSSI value on the connection to a bluetooth
	 * 	device. Requires that you have established a connection
	 * 	before invoking (otherwise an error will be thrown).
	 *	@param {Object} options 
	 * 		@param {String} device_id
	 * 		UUID or MAC address of the peripheral
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	readRSSI(options, callback) {
		if (!options || !options.device_id) {
			const error = new Error('No device_id provided to bleCentral.readRSSI!');
			return (callback || console.error)(error, null);
		}
		if (this.mockMode) {
			console.warn('bleCentral mock readRSSI!');
			if (callback) callback(null, null);
			return;
		}

		this.ble && this.ble.readRSSI(
			options.device_id,
			success,
			fail
		);

		function success(result) {
			if (callback) callback(null, result);
		}

		function fail(error) {
			if (callback) callback(error, null);
		}
	}
	///////////////////////////////////// NOTIFICATIONS /////////////////////////////////////
	/**
	 *  @method startNotification
	 *		Registers a callback that is called every time
	 *    the value of a characteristic changes. This method
	 * 		handles both notifications and indications.
	 *	@param {Object} options 
	 * 		@param {String} device_id
	 * 		UUID or MAC address of the peripheral
	 * 		@param {String} service_uuid
	 * 		UUID of the BLE service
	 * 		@param {String} characteristic_uuid
	 * 		UUID of the BLE characteristic
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	startNotification(options, callback) {
		if (!options) {
			const error = new Error('No options provided to bleCentral.startNotification!');
			return (callback || console.error)(error);
		}

		const { device_id, service_uuid, characteristic_uuid } = options;

		if (!device_id || !service_uuid || !characteristic_uuid) {
			const error = new Error(`Invalid device info provided to bleCentral.startNotification: ${JSON.stringify(options)}`);
			return (callback || console.error)(error);
		}

		if (this.mockMode) {
			console.warn('bleCentral mock startNotification!');
			if (callback) callback(null);
			return;
		}

		const success = result => {
			try {
				const data = this.bufferToArray(result);
				const obj = { device_id, service_uuid, characteristic_uuid, data };
				this.onNotification(obj);
			} catch (error) {
				console.error(error);
			}
		}

		function fail(error) {
			if (callback) callback(error);
		}

		this.ble && this.ble.startNotification(
			device_id,
			service_uuid,
			characteristic_uuid,
			success,
			fail
		);
	}
	/**
	 *  @method stopNotification
	 * 	Stops a previously registered notification callback.
	 *	@param {Object} options 
	 * 		@param {String} device_id
	 * 		UUID or MAC address of the peripheral
	 * 		@param {String} service_uuid
	 * 		UUID of the BLE service
	 * 		@param {String} characteristic_uuid
	 * 		UUID of the BLE characteristic
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	stopNotification(options, callback) {
		if (!options) {
			const error = new Error('No options provided to bleCentral.stopNotification!');
			return (callback || console.error)(error);
		}

		const { device_id, service_uuid, characteristic_uuid } = options;

		if (!device_id || !service_uuid || !characteristic_uuid) {
			const error = new Error(`Invalid device info provided to bleCentral.stopNotification: ${JSON.stringify(options)}`);
			return (callback || console.error)(error);
		}

		if (this.mockMode) {
			console.warn('bleCentral mock stopNotification!');
			if (callback) callback(null);
			return;
		}

		this.ble && this.ble.stopNotification(
			device_id,
			service_uuid,
			characteristic_uuid,
			success,
			fail
		);

		function success(result) {
			if (callback) callback(null, result);
		}

		function fail(error) {
			if (callback) callback(error, null);
		}
	}
	/**
	 *  @method startStateNotifications
	 * 	Calls the success callback when the Bluetooth is
	 * 	enabled or disabled on the device.
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	startStateNotifications(callback) {
		if (this.mockMode) {
			console.warn('bleCentral mock startStateNotifications!');
			if (callback) callback(null, null);
			return;
		}

		this.ble && this.ble.startStateNotifications(success, fail);

		function success(result) {
			if (callback) callback(null, result);
		}

		function fail(error) {
			if (callback) callback(error, null);
		}
	}
	/**
	 *  @method stopStateNotifications
	 * 	Calls the success callback when Bluetooth state
	 * 	notifications have been stopped.
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	stopStateNotifications(callback) {
		if (this.mockMode) {
			console.warn('bleCentral mock stopStateNotifications!');
			if (callback) callback(null, null);
			return;
		}

		this.ble && this.ble.stopStateNotifications(success, fail);

		function success(result) {
			if (callback) callback(null, result);
		}

		function fail(error) {
			if (callback) callback(error, null);
		}
	}
	///////////////////////////////////////// UTILS /////////////////////////////////////////
	/**
	 *  @method isConnected
	 * 		Calls the success callback when the peripheral is
	 * 		connected and the failure callback when not connected.
	 *	@param {Object} options 
	 * 		@param {String} device_id
	 * 		UUID or MAC address of the peripheral
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	isConnected(options, callback) {
		if (!callback) {
			return console.error(new Error('No callback provided to bleCentral.isConnected!'));
		}
		if (!options || !options.device_id) {
			const error = new Error('No device_id provided to bleCentral.isConnected!');
			return callback(error, null);
		}
		if (this.mockMode) {
			console.warn('bleCentral mock isConnected!');
			return callback(null, null);
		}

		this.ble && this.ble.isConnected(
			options.device_id,
			success,
			fail
		);

		function success(result) {
			callback(null, result);
		}

		function fail(error) {
			callback(error, null);
		}
	}
	/**
	 *  @method isEnabled
	 * 	Calls the success callback when Bluetooth is
	 * 	enabled and the failure callback when Bluetooth
	 * 	is not enabled.
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	isEnabled(callback) {
		if (!callback) {
			return console.error(new Error('No callback provided to bleCentral.isEnabled!'));
		}
		if (this.mockMode) {
			console.warn('bleCentral mock isEnabled!');
			return callback(null, null);
		}

		this.ble && this.ble.isEnabled(success, fail);

		function success(result) {
			callback(null, result);
		}

		function fail(error) {
			callback(error, null);
		}
	}
	/**
	 *  @method isLocationEnabled
	 * 	Calls the success callback when location services
	 * 	are enabled and the failure callback when location
	 * 	services are not enabled. On some devices, location
	 * 	services must be enabled in order to scan for peripherals.
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	isLocationEnabled(callback) {
		if (this.mockMode) {
			console.warn('bleCentral mock isLocationEnabled!');
			if (callback) callback(null, null);
			return;
		}

		this.ble && this.ble.isLocationEnabled(success, fail);

		function success(result) {
			if (callback) callback(null, result);
		}

		function fail(error) {
			if (callback) callback(error, null);
		}
	}
	/**
	 *  @method showBluetoothSettings
	 * 	Opens the Bluetooth settings for the operating systems.
	 * 	showBluetoothSettings is not available on iOS. 
	 */
	showBluetoothSettings(callback) {
		if (bfUtils.isIOS) {
			return (callback || console.warn)('bleCentral.showBluetoothSettings is not available on iOS!');
		}
		if (this.mockMode) {
			console.warn('bleCentral mock showBluetoothSettings!');
			if (callback) callback(null);
			return;
		}

		this.ble && this.ble.showBluetoothSettings(success, fail);

		function success() {
			if (callback) callback(null);
		}

		function fail(error) {
			if (callback) callback(error);
		}
	}
	/**
	 *  @method enable
	 * 	Prompts the user to enable Bluetooth. enable is only
	 * 	supported on Android and does not work on iOS.
	 *  @param {Function} callback 
	 * 		@returns {Object} 
	 */
	enable(callback) {
		if (bfUtils.isIOS) {
			return (callback || console.warn)('bleCentral.enable is not available on iOS!');
		}
		if (this.mockMode) {
			console.warn('bleCentral mock enable!');
			if (callback) callback(null, null);
			return;
		}

		this.ble && this.ble.enable(success, fail);

		function success(result) {
			if (callback) callback(null, result);
		}

		function fail(error) {
			if (callback) callback(error, null);
		}
	}
	/**
	 *  @method bondedDevices
	 * 	Sends a list of bonded low energy peripherals to
	 * 	the success callback.
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	bondedDevices(callback) {
		if (!callback) {
			return console.error(new Error('No callback provided to bleCentral.bondedDevices!'));
		}
		if (this.mockMode) {
			console.warn('bleCentral mock enable!');
			return callback(null, null);
		}

		this.ble && this.ble.bondedDevices(success, fail);

		function success(result) {
			callback(null, result);
		}

		function fail(error) {
			callback(error, null);
		}
	}
	/**
	 *  @method requestMtu
	 * 		When performing a write request operation (write without response), the
	 * 		data sent is truncated to the MTU size. This function may be used to request
	 * 		(on Android) a larger MTU size to be able to send more data at once.
	 *	@param {Object} options 
	 * 		@param {String} device_id
	 * 		UUID or MAC address of the peripheral
	 * 		@param {Number} mtu
	 * 		MTU size
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	requestMtu(options, callback) {
		if (!options || !options.device_id) {
			const error = new Error('No device_id provided to bleCentral.requestMtu!');
			return (callback || console.error)(error, null);
		}
		if (this.mockMode) {
			console.warn('bleCentral mock requestMtu!');
			if (callback) callback(null, null);
			return;
		}

		options.mtu = options.mtu || 100;

		this.ble && this.ble.requestMtu(
			options.device_id,
			options.mtu,
			success,
			fail
		);

		function success(result) {
			if (callback) callback(null, result);
		}

		function fail(error) {
			if (callback) callback(error, null);
		}
	}
	/**
	 *  @method refreshDeviceCache
	 * 		Some devices show old cached services and
	 * 		characteristics info. 
	 *	@param {Object} options 
	 * 		@param {String} device_id
	 * 		UUID or MAC address of the peripheral
	 * 		@param {Number} timeoutMillis
	 * 		Timeout in milliseconds after refresh before discovering services
	 * 	@param {Function} callback 
	 * 		@returns {Object} 
	 */
	refreshDeviceCache(options, callback) {
		if (!options || !options.device_id) {
			const error = new Error('No device_id provided to bleCentral.refreshDeviceCache!');
			return (callback || console.error)(error, null);
		}
		if (this.mockMode) {
			console.warn('bleCentral mock refreshDeviceCache!');
			if (callback) callback(null, null);
			return;
		}

		this.ble && this.ble.refreshDeviceCache(
			options.device_id,
			options.timeoutMillis,
			success,
			fail
		);

		function success(result) {
			if (callback) callback(null, result);
		}

		function fail(error) {
			if (callback) callback(error, null);
		}
	}
	/////////////////////////////////////// CONVERSION //////////////////////////////////////
	get arrayTypes() {
		return {
			'Int8': Int8Array,
			'Uint8': Uint8Array,
			'Int16': Int16Array,
			'Uint16': Uint16Array,
			'Int32': Int32Array,
			'Uint32': Uint32Array
		}
	}
	bufferToArray(buffer, type = 'Uint8') {
		if (!this.arrayTypes[type]) {
			console.error('Invalid array type! Defaulting to Uint8Array.');
			type = 'Uint8';
		}
		return Array.from(new this.arrayTypes[type](buffer));
	}
	arrayToBuffer(arr, type = 'Uint8') {
		if (!this.arrayTypes[type]) {
			console.error('Invalid array type! Defaulting to Uint8Array.');
			type = 'Uint8';
		}
		return new this.arrayTypes[type](arr).buffer;
	}
}
function ComponentUIAPI(context) {
    this.context = context;
    this.DRAWER_UI_ID = 'bottomDrawerContainer';
    this.SNACKBAR_UI_ID = 'snackbarhero';
    this.init();
}

ComponentUIAPI.prototype = {
    init: function () {
    },
    closeDrawer: function (options, callback) {
        if (!options) {
            options = {};
        }
        let _ui = document.getElementById(this.DRAWER_UI_ID);
        if (_ui) {
            if (options.force)
                _ui.remove();
            else {
                _ui.classList.add('closing');
                setTimeout(function () {
                    _ui.remove();
                }, 300);
            }
        }
    },
    openBottomDrawer: function (options, callback) {
        if (!options) {
            options = {};
        }
        let drawerUI = document.createElement('div');
        drawerUI.id = this.DRAWER_UI_ID;
        drawerUI.className = 'bottom-drawer-container';
        drawerUI.innerHTML = '<div class="bottom-drawer-backdrop"></div>\n' +
            '<div class="bottom-drawer-holder"><div class="bottom-drawer backgroundColorTheme"></div></div>\n';

        let bodyDrawer = drawerUI.querySelector('.backgroundColorTheme');
        drawerUI.querySelector('.bottom-drawer-backdrop').onclick = () => {
            this.closeDrawer();
        };

        if (options.header) {
            let headerUI = document.createElement('div');
            headerUI.className = 'bottom-drawer-header primaryBackgroundTheme';
            headerUI.innerHTML = options.header;

            bodyDrawer.appendChild(headerUI);
        }

        function buildList(items) {
            let listUI = document.createElement('ul');
            listUI.classList.add('action-list');

            function itemClick(itemUI, currentItem) {
                itemUI.onclick = function () {
                    callback(null, currentItem);
                };
            }

            for (let i = 0; i < items.length; i++) {
                if (items[i].text) {
                    let itemUI = document.createElement('li');
                    //no icons for now, we need to import the MD icons
                    itemUI.innerHTML = '<div class="item-icon"><span class="icon hide"></span></div>\n' +
                        '<span>' + items[i].text + '</span>';
                    itemClick(itemUI, items[i]);
                    listUI.appendChild(itemUI);
                }
            }
            return listUI;
        }

        if (options.richContent) {
            let contentUI = document.createElement('div');
            contentUI.className = 'drawer-content';
            contentUI.innerHTML = options.richContent;

            bodyDrawer.appendChild(contentUI);
        } else {
            if (options.listItems) {
                bodyDrawer.appendChild(buildList(options.listItems));
            } else {
                if (options.tabs && options.tabs) {
                    let tabsUI = document.createElement('div');
                    tabsUI.className = 'md-tabs-scroll';
                    let tabsInnerHTML = '';
                    for (let i = 0; i < options.tabs.length; i++) {
                        tabsInnerHTML += '<button class="btn-tab-drawer-' + i + (i == 0 ? " md-tab active" : " md-tab") + '">\n' +
                            options.tabs[i].text + '<div class="active-indicator primaryBackgroundTheme"></div></button>';
                    }
                    tabsInnerHTML = '<div class="md-tabs">' + tabsInnerHTML + '</div>';
                    tabsUI.innerHTML = tabsInnerHTML;

                    let count = 0;
                    let tabContainers = [];
                    let _buttons = tabsUI.querySelectorAll('button');
                    _buttons.forEach(function (b) {
                        b.setAttribute('data-tabindex', count);
                        b.onclick = function () {
                            _buttons.forEach(function (_b) {
                                _b.classList.remove('active');
                            });
                            b.classList.add("active");
                            let index = b.getAttribute('data-tabindex');
                            tabContainers.forEach(function (_container) {
                                _container.classList.add('hide');
                            });
                            tabContainers[index].classList.remove('hide');
                        };
                        count++;
                    });
                    bodyDrawer.appendChild(tabsUI);

                    for (let i = 0; i < options.tabs.length; i++) {
                        if (options.tabs[i].listItems) {
                            tabContainers.push(buildList(options.tabs[i].listItems));
                        } else {
                            let contentUI = document.createElement('div');
                            contentUI.className = 'drawer-content';
                            contentUI.innerHTML = options.tabs[i].richContent;

                            tabContainers.push(contentUI);
                        }
                        if (i > 0) {
                            tabContainers[i].classList.add('hide');
                        }
                        bodyDrawer.appendChild(tabContainers[tabContainers.length - 1]);
                    }
                }
            }
        }

        //remove the old Drawer
        this.closeDrawer({force: true});
        //attach drawerUI to body
        document.getElementById('appBody').appendChild(drawerUI);
    },
    showToastMessage: function (options, callback) {
        if (!options) {
            options = {};
        }

        let snackbarUI = document.getElementById(this.SNACKBAR_UI_ID);
        let message = snackbarUI.querySelector('.snackbar-message');
        message.innerText = options.text;

        let snackbarActions = snackbarUI.querySelector('.snackbar-actions');
        let snackbarAction = snackbarActions.querySelector('.snackbar-action');
        if (options.action && options.action.title) {
            snackbarAction.querySelector('span').innerText = options.action.title;
            snackbarAction.classList.remove('hide');
            snackbarAction.onclick = function () {
                if (callback)
                    callback(null, options.action);
            };
        } else {
            snackbarAction.classList.add('hide');
        }

        if (options.hideDismiss) {
            snackbarActions.querySelector('.dismiss').classList.add('hide');
        } else {
            snackbarActions.querySelector('.dismiss').classList.remove('hide');
            snackbarActions.querySelector('.dismiss').onclick = () => {
                this.closeToastMessage({force: true});
            }
        }

        snackbarUI.classList.remove('hide');
        snackbarUI.querySelector('.snackbar').classList.add('open');
        this.closeToastMessage();
    },
    closeToastMessage: function (options, callback) {
        if (!options) {
            options = {};
        }
        let snackbarUI = document.getElementById(this.SNACKBAR_UI_ID);
        if (options.force) {
            snackbarUI.querySelector('.snackbar').classList.remove('closing');
            snackbarUI.querySelector('.snackbar').classList.remove('open');
            snackbarUI.classList.add('hide');
        } else {
            snackbarUI.querySelector('.snackbar').classList.add('closing');
            setTimeout(function () {
                snackbarUI.querySelector('.snackbar').classList.remove('closing');
                snackbarUI.querySelector('.snackbar').classList.remove('open');
                snackbarUI.classList.add('hide');
            }, 8 * 1000);
        }
    }
};