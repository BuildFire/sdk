tinymce.PluginManager.add('bf_videolib', function (editor, url) {
  
  function showVideoDialog() {
    var selectedNode = editor.selection.getNode();
    var isEditing = selectedNode && (selectedNode.getAttribute('data-mce-object') || selectedNode.tagName === 'IFRAME' || selectedNode.tagName === 'VIDEO');
    
    var initialData = {
      source: '',
      width: '560',
      height: '314',
      embed: '',
      altsource: '',
      poster: ''
    };
    
    if (isEditing) {
      if (selectedNode.tagName === 'IFRAME') {
        initialData.source = selectedNode.src || '';
        initialData.width = selectedNode.width || '560';
        initialData.height = selectedNode.height || '314';
      } else if (selectedNode.tagName === 'VIDEO') {
        initialData.source = selectedNode.src || '';
        initialData.width = selectedNode.width || '560';
        initialData.height = selectedNode.height || '314';
        initialData.poster = selectedNode.poster || '';
      }
    }
    
    var dialog = editor.windowManager.openUrl({
      title: 'Insert/Edit Video',
      url: url + '/dialog.html',
      width: 500,
      height: 500,
      buttons: [
        {
          type: 'cancel',
          name: 'cancel',
          text: 'Cancel'
        },
        {
          type: 'custom',
          name: 'save',
          text: 'Save',
          primary: true
        }
      ],
      onAction: function (dialogApi, details) {
        if (details.name === 'save') {
          dialogApi.sendMessage({ action: 'getVideoData' });
        }
      },
      onMessage: function (dialogApi, message) {
        console.log('!!!!Received message from dialog:', message);
        if (message.mceAction === 'insertVideo' && message.data) {
          validateAndInsertVideo(message.data, dialogApi);
        }
      },
      onClose: function () {
        editor.focus();
      }
    });
    
    setTimeout(function() {
      dialog.sendMessage({
        action: 'setInitialData',
        data: initialData
      });
    }, 100);
  }
  
  function validateAndInsertVideo(data, dialogApi) {
    var source = data.source;
    
    // For direct video files, validate CDN URL first
    if (source && source.match(/\.(mp4|webm|ogg)(\?.*)?$/i)) {
      var qualityParam = data.quality ? ', quality: \'' + data.quality + '\'' : '';
      
      if (typeof buildfire !== 'undefined' && buildfire.videoLib && buildfire.videoLib.toCdnUrl) {
        try {
          var cdnUrl = buildfire.videoLib.toCdnUrl({ videoUrl: source + qualityParam });
          
          // Test if CDN URL is accessible
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', cdnUrl, true);
          xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) {
              if (xhr.status === 200) {
                // CDN URL works, proceed with video insertion
                var videoHtml = createVideoHtml(data);
                if (videoHtml) {
                  editor.insertContent(videoHtml);
                }
                dialogApi.close();
              } else if (xhr.status === 413) {
                // CDN failed with 413 (file too large)
                editor.windowManager.alert('Video exceeds CDN processing limits. Please use a shorter or smaller video file.');
              } else {
                // Other CDN error with details
                var errorMsg = 'Error processing video (HTTP ' + xhr.status + ')';
                if (xhr.responseText) {
                  errorMsg += ': ' + xhr.responseText;
                }
                editor.windowManager.alert(errorMsg);
              }
            }
          };
          xhr.send();
          return;
        } catch (e) {
          console.error('CDN validation error:', e);
        }
      }
    }
    
    // For non-video files or if CDN validation not needed, insert directly
    var videoHtml = createVideoHtml(data);
    if (videoHtml) {
      editor.insertContent(videoHtml);
    }
    dialogApi.close();
  }
  
  function createVideoHtml(data) {
    var source = data.source;
    var width = data.width || '300';
    var height = data.height || '150';
    var embed = data.embed;
    
    if (embed && embed.trim()) {
      return embed;
    }
    
    if (!source) {
      return '';
    }
    
    // Convert URLs like TinyMCE does
    source = editor.convertURL ? editor.convertURL(source, 'source') : source;
    if (data.altsource) {
      data.altsource = editor.convertURL ? editor.convertURL(data.altsource, 'source') : data.altsource;
    }
    if (data.poster) {
      data.poster = editor.convertURL ? editor.convertURL(data.poster, 'poster') : data.poster;
    } else {
      // Generate thumbnail expression if no poster provided
      var escapedVideoUrl = source.replace(/(?<!\\\\)'/g, "\\\\'");
      var atSecondParam = data.atSecond ? ', atSecond: \'' + data.atSecond + '\'' : '';
      data.posterExpr = '${buildfire.videoLib.toThumbnailCdnUrl({ videoUrl: \'' + escapedVideoUrl + '\'' + atSecondParam + ' })}';
      data.poster = data.posterExpr; // fallback
    }
    
    // YouTube patterns from TinyMCE media plugin
    var youtubeMatch = source.match(/youtu\.be\/([\w\-_\?&=.]+)/i) || 
                      source.match(/youtube\.com(.+)v=([^&]+)(&([a-z0-9&=\-_]+))?/i) ||
                      source.match(/youtube.com\/embed\/([a-z0-9\?&=\-_]+)/i);
    
    if (youtubeMatch) {
      var videoId = youtubeMatch[2] || youtubeMatch[1];
      var queryParams = youtubeMatch[4] || '';
      console.log('!!!!YouTube videoId:', videoId, 'queryParams:', youtubeMatch);
      var encodedVideoId = editor.dom.encode ? editor.dom.encode(videoId) : videoId;
      var encodedWidth = editor.dom.encode ? editor.dom.encode(width) : width;
      var encodedHeight = editor.dom.encode ? editor.dom.encode(height) : height;
      var embedUrl = 'https://www.youtube.com/embed/' + encodedVideoId + (queryParams ? '?' + queryParams : '');
      console.log('!!!!YouTube embedUrl:', embedUrl);
      return '<iframe src="' + embedUrl + '" width="' + encodedWidth + '" height="' + encodedHeight + '" allowfullscreen></iframe>';
    }
    
    // Vimeo patterns from TinyMCE media plugin
    var vimeoMatch = source.match(/vimeo\.com\/([0-9]+)/) ||
                    source.match(/vimeo\.com\/(.*)\/([0-9]+)/);
    
    if (vimeoMatch) {
      var videoId = vimeoMatch[2] || vimeoMatch[1];
      var encodedVideoId = editor.dom.encode ? editor.dom.encode(videoId) : videoId;
      var encodedWidth = editor.dom.encode ? editor.dom.encode(width) : width;
      var encodedHeight = editor.dom.encode ? editor.dom.encode(height) : height;
      return '<iframe src="https://player.vimeo.com/video/' + encodedVideoId + '?title=0&byline=0&portrait=0&color=8dc7dc" width="' + encodedWidth + '" height="' + encodedHeight + '" allowfullscreen></iframe>';
    }
    
    // Dailymotion patterns from TinyMCE media plugin
    var dailymotionMatch = source.match(/dailymotion\.com\/video\/([^_]+)/) ||
                          source.match(/dai\.ly\/([^_]+)/);
    
    if (dailymotionMatch) {
      var videoId = dailymotionMatch[1];
      var encodedVideoId = editor.dom.encode ? editor.dom.encode(videoId) : videoId;
      var encodedWidth = editor.dom.encode ? editor.dom.encode(width) : width;
      var encodedHeight = editor.dom.encode ? editor.dom.encode(height) : height;
      return '<iframe src="https://www.dailymotion.com/embed/video/' + encodedVideoId + '" width="' + encodedWidth + '" height="' + encodedHeight + '" allowfullscreen></iframe>';
    }
    
    // Google Maps pattern from TinyMCE media plugin
    var mapsMatch = source.match(/maps\.google\.([a-z]{2,3})\/maps\/(.+)msid=(.+)/);
    if (mapsMatch) {
      var encodedMsid = editor.dom.encode ? editor.dom.encode(mapsMatch[3]) : mapsMatch[3];
      var encodedWidth = editor.dom.encode ? editor.dom.encode(width) : width;
      var encodedHeight = editor.dom.encode ? editor.dom.encode(height) : height;
      return '<iframe src="https://maps.google.com/maps/ms?msid=' + encodedMsid + '&output=embed" width="' + encodedWidth + '" height="' + encodedHeight + '"></iframe>';
    }
    
    // Audio files - matching TinyMCE's audio template
    if (source.match(/\.(mp3|m4a|wav)$/i)) {
      var audioHtml = '<audio controls="controls" src="' + source + '">';
      if (data.altsource) {
        audioHtml += '\n<source src="' + data.altsource + '"';
        var altType = data.altsource.split('.').pop().toLowerCase();
        var mimeType = altType === 'mp3' ? 'audio/mpeg' : altType === 'm4a' ? 'audio/x-m4a' : 'audio/' + altType;
        audioHtml += ' type="' + mimeType + '" />\n';
      }
      audioHtml += '</audio>';
      return audioHtml;
    }
    
    // Flash/SWF files
    if (source.match(/\.swf$/i)) {
      var flashHtml = '<object data="' + source + '" width="' + width + '" height="' + height + '" type="application/x-shockwave-flash">';
      if (data.poster) {
        flashHtml += '<img src="' + data.poster + '" width="' + width + '" height="' + height + '" />';
      }
      flashHtml += '</object>';
      return flashHtml;
    }
    
    // Script tags for JavaScript-based media players
    // Many professional video hosting services provide JavaScript-based players that work this way
    // The JavaScript file then dynamically creates the video player in the page.
    if (source.match(/\.js$/i)) {
      return '<script src="' + source + '"><\/script>';
    }
    

    // Direct video files - matching TinyMCE's video template
    if (source.match(/\.(mp4|webm|ogg)(\?.*)?$/i)) {
      var escapedVideoUrl = source.replace(/(?<!\\\\)'/g, "\\\\'");
      var qualityParam = data.quality ? ', quality: \'' + data.quality + '\'' : '';
      var videoSrcExpr = '${buildfire.videoLib.toCdnUrl({ videoUrl: \'' + escapedVideoUrl + '\'' + qualityParam + ' })}';
      
      var posterSrc = data.poster;
      
      var videoHtml = '<video width="' + width + '" height="' + height + '"';
      if (data.posterExpr) {
        videoHtml += ' expr-poster="' + data.posterExpr + '"';
      }
      if (posterSrc && posterSrc !== source) {
        videoHtml += ' poster="' + posterSrc + '"';
      }
      videoHtml += ' controls="controls">\n';
      videoHtml += '<source expr-src="' + videoSrcExpr + '" src="' + source + '"';
      var sourceType = source.split('.').pop().toLowerCase();
      videoHtml += ' type="video/' + sourceType + '" />\n';
      if (data.altsource) {
        var escapedAltVideoUrl = data.altsource.replace(/(?<!\\\\)'/g, "\\\\'");
        var altVideoSrcExpr = '${buildfire.videoLib.toCdnUrl({ videoUrl: \'' + escapedAltVideoUrl + '\'' + qualityParam + ' })}';
        videoHtml += '<source expr-src="' + altVideoSrcExpr + '" src="' + data.altsource + '"';
        var altType = data.altsource.split('.').pop().toLowerCase();
        videoHtml += ' type="video/' + altType + '" />\n';
      }
      videoHtml += '</video>';
      return videoHtml;
    }
    
    return '<iframe src="' + source + '" width="' + width + '" height="' + height + '" allowfullscreen></iframe>';
  }
  
  editor.ui.registry.addButton('bf_videolib', {
    icon: 'embed',
    tooltip: 'Insert/edit video',
    onAction: function () {
      showVideoDialog();
    }
  });
  
  editor.ui.registry.addMenuItem('bf_videolib', {
    icon: 'embed',
    text: 'Insert/edit video',
    onAction: function () {
      showVideoDialog();
    }
  });
  
  editor.addCommand('mceBfVideolib', function () {
    showVideoDialog();
  });
  
  return {
    getMetadata: function () {
      return {
        name: 'BuildFire Video Library plugin',
        url: 'https://github.com/BuildFire/sdk'
      };
    }
  };
});